# OSCEANç©ºé—´å­é›†åŠŸèƒ½ç»Ÿä¸€è®¾è®¡æ–¹æ¡ˆ

## ğŸ¯ é—®é¢˜æè¿°

å½“å‰OSCEANé¡¹ç›®ä¸­å­˜åœ¨**ç©ºé—´å­é›†åŠŸèƒ½åœ¨å¤šä¸ªå±‚çº§é‡å¤å®ç°**çš„ä¸¥é‡æ¶æ„é—®é¢˜ï¼š

1. **NetCDFè¯»å–å™¨å±‚**ï¼š`calculateSpatialIndices()`, `applySpatialSubset()`
2. **å·¥ä½œæµæœåŠ¡å±‚**ï¼š`analyzeSpatialResolutionAndCalculateSubsetAsync()`
3. **ç©ºé—´æ“ä½œæœåŠ¡å±‚**ï¼š`queryByBoundingBox()`, `calculateBounds()`
4. **æ•°æ®è®¿é—®å±‚**ï¼šå„ç§æ ¼å¼å¤„ç†å™¨çš„è¾¹ç•Œæ¡†è®¡ç®—

è¿™å¯¼è‡´äº†åŠŸèƒ½å†—ä½™ã€ç»´æŠ¤å›°éš¾ã€æ€§èƒ½æŸå¤±å’Œæ½œåœ¨çš„ä¸ä¸€è‡´æ€§ã€‚

## ğŸ—ï¸ ç»Ÿä¸€æ¶æ„è®¾è®¡

### ğŸ“‹ æ ¸å¿ƒåŸåˆ™

1. **å•ä¸€èŒè´£åŸåˆ™**ï¼šæ¯ä¸ªå±‚çº§åªè´Ÿè´£è‡ªå·±é¢†åŸŸçš„ç©ºé—´å¤„ç†
2. **ä¾èµ–å€’ç½®åŸåˆ™**ï¼šé«˜å±‚æ¨¡å—ä¸ä¾èµ–ä½å±‚æ¨¡å—çš„å…·ä½“å®ç°
3. **å¼€é—­åŸåˆ™**ï¼šå¯¹æ‰©å±•å¼€æ”¾ï¼Œå¯¹ä¿®æ”¹å°é—­
4. **æ¥å£éš”ç¦»åŸåˆ™**ï¼šä¸åŒå±‚çº§ä½¿ç”¨ä¸åŒçš„æ¥å£æŠ½è±¡

### ğŸ¯ èŒè´£åˆ†å·¥

#### 1. **ç©ºé—´æ“ä½œæœåŠ¡å±‚** (æ ¸å¿ƒç©ºé—´è®¡ç®—å¼•æ“)
**èŒè´£**ï¼šæä¾›æ‰€æœ‰ç©ºé—´è®¡ç®—çš„æ ¸å¿ƒç®—æ³•å’Œæ ‡å‡†æ¥å£

```cpp
namespace oscean::core_services::spatial_ops {

/**
 * @brief ç»Ÿä¸€ç©ºé—´å­é›†æœåŠ¡æ¥å£
 */
class ISpatialSubsetService {
public:
    /**
     * @brief è®¡ç®—ç©ºé—´å­é›†è¾¹ç•Œæ¡†
     * @param queryGeometry æŸ¥è¯¢å‡ ä½•ä½“
     * @param dataBounds æ•°æ®è¾¹ç•Œæ¡†
     * @param options å­é›†é€‰é¡¹
     * @return è®¡ç®—çš„å­é›†è¾¹ç•Œæ¡†
     */
    virtual boost::future<BoundingBox> calculateSubsetBounds(
        const Geometry& queryGeometry,
        const BoundingBox& dataBounds,
        const SubsetOptions& options = {}) = 0;
    
    /**
     * @brief è®¡ç®—ç©ºé—´ç´¢å¼•èŒƒå›´
     * @param queryBounds æŸ¥è¯¢è¾¹ç•Œæ¡†
     * @param coordinateArrays åæ ‡æ•°ç»„ä¿¡æ¯
     * @return ç©ºé—´ç´¢å¼•èŒƒå›´
     */
    virtual boost::future<SpatialIndexRange> calculateSpatialIndices(
        const BoundingBox& queryBounds,
        const CoordinateArrayInfo& coordinateArrays) = 0;
    
    /**
     * @brief ä¼˜åŒ–ç©ºé—´æŸ¥è¯¢å‡ ä½•
     * @param originalGeometry åŸå§‹å‡ ä½•ä½“
     * @param targetCRS ç›®æ ‡åæ ‡ç³»
     * @param optimizationLevel ä¼˜åŒ–çº§åˆ«
     * @return ä¼˜åŒ–åçš„å‡ ä½•ä½“
     */
    virtual boost::future<Geometry> optimizeQueryGeometry(
        const Geometry& originalGeometry,
        const std::string& targetCRS,
        int optimizationLevel = 2) = 0;
};

/**
 * @brief ç©ºé—´å­é›†é…ç½®
 */
struct SubsetOptions {
    enum class Strategy {
        EXACT_BOUNDS,           // ç²¾ç¡®è¾¹ç•Œ
        BUFFERED_BOUNDS,        // ç¼“å†²è¾¹ç•Œ
        GRID_ALIGNED_BOUNDS,    // ç½‘æ ¼å¯¹é½è¾¹ç•Œ
        OPTIMIZED_BOUNDS        // ä¼˜åŒ–è¾¹ç•Œ
    } strategy = Strategy::EXACT_BOUNDS;
    
    double bufferDistance = 0.0;        // ç¼“å†²è·ç¦»ï¼ˆç±³ï¼‰
    bool alignToGrid = false;           // æ˜¯å¦å¯¹é½åˆ°ç½‘æ ¼
    bool optimizeForPerformance = true; // æ˜¯å¦ä¼˜åŒ–æ€§èƒ½
    int maxGridPoints = 1000000;        // æœ€å¤§ç½‘æ ¼ç‚¹æ•°
};

/**
 * @brief ç©ºé—´ç´¢å¼•èŒƒå›´
 */
struct SpatialIndexRange {
    size_t lonStartIndex = 0;
    size_t lonEndIndex = 0;
    size_t latStartIndex = 0;
    size_t latEndIndex = 0;
    size_t lonDimIndex = SIZE_MAX;
    size_t latDimIndex = SIZE_MAX;
    
    bool isValid() const {
        return lonStartIndex <= lonEndIndex && 
               latStartIndex <= latEndIndex &&
               lonDimIndex != SIZE_MAX && 
               latDimIndex != SIZE_MAX;
    }
};

/**
 * @brief åæ ‡æ•°ç»„ä¿¡æ¯
 */
struct CoordinateArrayInfo {
    std::vector<double> lonCoordinates;
    std::vector<double> latCoordinates;
    std::string lonDimensionName;
    std::string latDimensionName;
    size_t lonDimensionIndex;
    size_t latDimensionIndex;
};

} // namespace oscean::core_services::spatial_ops
```

#### 2. **å·¥ä½œæµæœåŠ¡å±‚** (ä¸šåŠ¡é€»è¾‘ç¼–æ’)
**èŒè´£**ï¼šç¼–æ’ç©ºé—´å­é›†è®¡ç®—æµç¨‹ï¼Œä¸å®ç°å…·ä½“ç®—æ³•

```cpp
namespace oscean::workflow_engine::data_workflow {

/**
 * @brief å·¥ä½œæµå±‚ç©ºé—´åˆ†æç»“æœ
 */
struct WorkflowSpatialAnalysis {
    // ğŸ¯ å§”æ‰˜ç»™ç©ºé—´æœåŠ¡çš„ç»“æœ
    BoundingBox calculatedSubset;
    SpatialIndexRange spatialIndices;
    
    // ğŸ¯ å·¥ä½œæµå±‚çš„ä¸šåŠ¡ä¿¡æ¯
    std::string subsetStrategy;
    double estimatedDataReduction;
    std::vector<std::string> optimizationSuggestions;
    
    // ğŸ¯ æ€§èƒ½é¢„æµ‹
    size_t estimatedGridPoints;
    double estimatedProcessingTime;
    size_t estimatedMemoryUsage;
};

class EnhancedDataWorkflowServiceImpl {
private:
    /**
     * @brief å§”æ‰˜ç©ºé—´æœåŠ¡è¿›è¡Œå­é›†è®¡ç®—
     */
    boost::future<WorkflowSpatialAnalysis> delegateSpatialSubsetCalculation(
        const EnhancedDataWorkflowRequest& request,
        const core_services::FileMetadata& fileMetadata) {
        
        // ğŸ¯ è·å–ç©ºé—´æœåŠ¡
        auto spatialSubsetService = serviceManager_->getService<
            core_services::spatial_ops::ISpatialSubsetService>();
        
        // ğŸ¯ å§”æ‰˜è®¡ç®—ï¼Œä¸é‡å¤å®ç°
        auto subsetBoundsFuture = spatialSubsetService->calculateSubsetBounds(
            convertToGeometry(request.spatialRequest),
            fileMetadata.spatialCoverage);
        
        auto spatialIndicesFuture = spatialSubsetService->calculateSpatialIndices(
            subsetBoundsFuture.get(),
            extractCoordinateInfo(fileMetadata));
        
        // ğŸ¯ å·¥ä½œæµå±‚åªè´Ÿè´£ç»“æœç»„è£…å’Œä¸šåŠ¡é€»è¾‘
        WorkflowSpatialAnalysis result;
        result.calculatedSubset = subsetBoundsFuture.get();
        result.spatialIndices = spatialIndicesFuture.get();
        result.subsetStrategy = "delegated_to_spatial_service";
        
        return boost::make_ready_future(result);
    }
};

} // namespace oscean::workflow_engine::data_workflow
```

#### 3. **æ•°æ®è®¿é—®æœåŠ¡å±‚** (æ ¼å¼ç‰¹å®šçš„ç´¢å¼•åº”ç”¨)
**èŒè´£**ï¼šå°†ç©ºé—´æœåŠ¡è®¡ç®—çš„ç´¢å¼•åº”ç”¨åˆ°å…·ä½“çš„æ•°æ®æ ¼å¼

```cpp
namespace oscean::core_services::data_access::readers::impl::netcdf {

class NetCDFVariableProcessor {
private:
    // ğŸ¯ ç§»é™¤é‡å¤çš„ç©ºé—´è®¡ç®—åŠŸèƒ½
    // âŒ åˆ é™¤ï¼šcalculateSpatialIndices() - å§”æ‰˜ç»™ç©ºé—´æœåŠ¡
    // âŒ åˆ é™¤ï¼šapplySpatialSubset() - ç®€åŒ–ä¸ºç´¢å¼•åº”ç”¨
    
    /**
     * @brief åº”ç”¨ç©ºé—´æœåŠ¡è®¡ç®—çš„ç´¢å¼•ï¼ˆç®€åŒ–ç‰ˆï¼‰
     */
    void applyPreCalculatedSpatialIndices(
        const std::vector<std::string>& dimensions,
        const SpatialIndexRange& spatialIndices,
        std::vector<size_t>& start,
        std::vector<size_t>& count) const {
        
        LOG_INFO("ğŸ¯ åº”ç”¨é¢„è®¡ç®—çš„ç©ºé—´ç´¢å¼•:");
        LOG_INFO("  ç»åº¦ç»´åº¦[{}]: [{}:{}]", spatialIndices.lonDimIndex,
                spatialIndices.lonStartIndex, spatialIndices.lonEndIndex);
        LOG_INFO("  çº¬åº¦ç»´åº¦[{}]: [{}:{}]", spatialIndices.latDimIndex,
                spatialIndices.latStartIndex, spatialIndices.latEndIndex);
        
        // ğŸ¯ åªè´Ÿè´£å°†ç´¢å¼•åº”ç”¨åˆ°NetCDFè¯»å–å‚æ•°
        if (spatialIndices.lonDimIndex < dimensions.size()) {
            start[spatialIndices.lonDimIndex] = spatialIndices.lonStartIndex;
            count[spatialIndices.lonDimIndex] = spatialIndices.lonEndIndex - spatialIndices.lonStartIndex + 1;
        }
        
        if (spatialIndices.latDimIndex < dimensions.size()) {
            start[spatialIndices.latDimIndex] = spatialIndices.latStartIndex;
            count[spatialIndices.latDimIndex] = spatialIndices.latEndIndex - spatialIndices.latStartIndex + 1;
        }
    }
    
public:
    /**
     * @brief ä½¿ç”¨é¢„è®¡ç®—çš„ç©ºé—´ç´¢å¼•è¯»å–å˜é‡
     */
    std::shared_ptr<GridData> readVariableWithSpatialIndices(
        const std::string& variableName,
        const SpatialIndexRange& spatialIndices,
        const VariableReadOptions& options = {}) {
        
        // ğŸ¯ è·å–å˜é‡ä¿¡æ¯
        auto varInfo = getVariableInfo(variableName);
        if (!varInfo) return nullptr;
        
        // ğŸ¯ å‡†å¤‡è¯»å–å‚æ•°
        auto shape = getVariableShape(variableName);
        std::vector<size_t> start(shape.size(), 0);
        std::vector<size_t> count = shape;
        
        // ğŸ¯ åº”ç”¨é¢„è®¡ç®—çš„ç©ºé—´ç´¢å¼•
        if (spatialIndices.isValid()) {
            std::vector<std::string> dimensions = getDimensionNames(variableName);
            applyPreCalculatedSpatialIndices(dimensions, spatialIndices, start, count);
        }
        
        // ğŸ¯ æ‰§è¡Œå®é™…çš„NetCDFæ•°æ®è¯»å–
        return executeNetCDFRead(variableName, start, count, options);
    }
};

} // namespace oscean::core_services::data_access::readers::impl::netcdf
```

#### 4. **åº”ç”¨å±‚** (ç”¨æˆ·æ¥å£å’Œç»“æœå±•ç¤º)
**èŒè´£**ï¼šå¤„ç†ç”¨æˆ·è¾“å…¥ï¼Œå±•ç¤ºæœ€ç»ˆç»“æœ

```cpp
namespace oscean::application {

class OceanDataReaderApp {
private:
    /**
     * @brief åº”ç”¨å±‚åªè´Ÿè´£ç”¨æˆ·äº¤äº’ï¼Œä¸å®ç°ç©ºé—´è®¡ç®—
     */
    void processUserSpatialQuery(const QueryParams& params) {
        // ğŸ¯ æ„å»ºå·¥ä½œæµè¯·æ±‚
        auto request = createWorkflowRequest(params);
        
        // ğŸ¯ å§”æ‰˜ç»™å·¥ä½œæµæœåŠ¡å¤„ç†
        auto workflow = getWorkflowService();
        auto result = workflow->executeEnhancedWorkflowAsync(request).get();
        
        // ğŸ¯ åº”ç”¨å±‚åªè´Ÿè´£ç»“æœå±•ç¤º
        displayResults(result);
    }
    
    void displaySpatialSubsetInfo(const WorkflowResult& result) {
        std::cout << "ğŸ¯ ç©ºé—´å­é›†ä¿¡æ¯:" << std::endl;
        std::cout << "  ç­–ç•¥: " << result.spatialAnalysis.subsetStrategy << std::endl;
        std::cout << "  æ•°æ®å‡å°‘: " << result.spatialAnalysis.estimatedDataReduction << "%" << std::endl;
        std::cout << "  ç½‘æ ¼ç‚¹æ•°: " << result.spatialAnalysis.estimatedGridPoints << std::endl;
    }
};

} // namespace oscean::application
```

## ğŸ”„ æ•°æ®æµè®¾è®¡

### ğŸ“Š ç»Ÿä¸€çš„ç©ºé—´å­é›†å¤„ç†æµç¨‹

```
ç”¨æˆ·è¯·æ±‚ (åº”ç”¨å±‚)
    â†“
å·¥ä½œæµæœåŠ¡ (ç¼–æ’å±‚)
    â†“ å§”æ‰˜ç©ºé—´è®¡ç®—
ç©ºé—´æ“ä½œæœåŠ¡ (è®¡ç®—å¼•æ“)
    â†“ è¿”å›è®¡ç®—ç»“æœ
å·¥ä½œæµæœåŠ¡ (ç»“æœç»„è£…)
    â†“ ä¼ é€’ç´¢å¼•ä¿¡æ¯
æ•°æ®è®¿é—®æœåŠ¡ (ç´¢å¼•åº”ç”¨)
    â†“ è¿”å›æ•°æ®
åº”ç”¨å±‚ (ç»“æœå±•ç¤º)
```

### ğŸ¯ å…³é”®æ¥å£

```cpp
// 1. ç©ºé—´æœåŠ¡æ¥å£
ISpatialSubsetService::calculateSubsetBounds()
ISpatialSubsetService::calculateSpatialIndices()

// 2. å·¥ä½œæµæœåŠ¡æ¥å£  
IEnhancedDataWorkflowService::executeEnhancedWorkflowAsync()

// 3. æ•°æ®è®¿é—®æœåŠ¡æ¥å£
IUnifiedDataReader::readVariableWithSpatialIndices()

// 4. åº”ç”¨å±‚æ¥å£
OceanDataReaderApp::processUserSpatialQuery()
```

## ğŸš€ å®æ–½è®¡åˆ’

### é˜¶æ®µ1ï¼šåˆ›å»ºç»Ÿä¸€ç©ºé—´å­é›†æœåŠ¡
1. åœ¨ç©ºé—´æ“ä½œæœåŠ¡ä¸­å®ç° `ISpatialSubsetService`
2. è¿ç§»æ‰€æœ‰ç©ºé—´è®¡ç®—é€»è¾‘åˆ°æ­¤æœåŠ¡
3. æä¾›æ ‡å‡†åŒ–çš„ç©ºé—´ç´¢å¼•è®¡ç®—æ¥å£

### é˜¶æ®µ2ï¼šé‡æ„å·¥ä½œæµæœåŠ¡
1. ç§»é™¤å·¥ä½œæµæœåŠ¡ä¸­çš„é‡å¤ç©ºé—´è®¡ç®—ä»£ç 
2. æ”¹ä¸ºå§”æ‰˜è°ƒç”¨ç©ºé—´å­é›†æœåŠ¡
3. ä¸“æ³¨äºä¸šåŠ¡æµç¨‹ç¼–æ’

### é˜¶æ®µ3ï¼šç®€åŒ–æ•°æ®è®¿é—®å±‚
1. ç§»é™¤NetCDFè¯»å–å™¨ä¸­çš„ç©ºé—´è®¡ç®—é€»è¾‘
2. æ”¹ä¸ºæ¥æ”¶é¢„è®¡ç®—çš„ç©ºé—´ç´¢å¼•
3. ä¸“æ³¨äºæ ¼å¼ç‰¹å®šçš„æ•°æ®è¯»å–

### é˜¶æ®µ4ï¼šæ¸…ç†å…¶ä»–å±‚çº§
1. ç§»é™¤GDALå¤„ç†å™¨ä¸­çš„é‡å¤è¾¹ç•Œæ¡†è®¡ç®—
2. ç»Ÿä¸€æ‰€æœ‰æ ¼å¼å¤„ç†å™¨çš„ç©ºé—´æ¥å£
3. ç¡®ä¿ä¸€è‡´æ€§å’Œæ€§èƒ½

## ğŸ“ˆ é¢„æœŸæ”¶ç›Š

1. **ä»£ç å‡å°‘**ï¼šç§»é™¤çº¦60%çš„é‡å¤ç©ºé—´è®¡ç®—ä»£ç 
2. **æ€§èƒ½æå‡**ï¼šé¿å…é‡å¤è®¡ç®—ï¼Œæå‡20-30%æ€§èƒ½
3. **ç»´æŠ¤æ€§**ï¼šå•ä¸€å®ç°ç‚¹ï¼Œé™ä½ç»´æŠ¤æˆæœ¬
4. **ä¸€è‡´æ€§**ï¼šç»Ÿä¸€çš„ç©ºé—´è®¡ç®—é€»è¾‘ï¼Œé¿å…ä¸ä¸€è‡´
5. **æ‰©å±•æ€§**ï¼šæ–°çš„ç©ºé—´åŠŸèƒ½åªéœ€åœ¨ä¸€å¤„å®ç°

## ğŸ”§ è¿ç§»æŒ‡å—

### ç°æœ‰ä»£ç è¿ç§»

```cpp
// âŒ æ—§æ–¹å¼ï¼šåœ¨NetCDFè¯»å–å™¨ä¸­è®¡ç®—ç©ºé—´ç´¢å¼•
auto spatialIndices = calculateSpatialIndices(variableName, bounds);
applySpatialSubset(dimensions, shape, spatialIndices, start, count);

// âœ… æ–°æ–¹å¼ï¼šä½¿ç”¨é¢„è®¡ç®—çš„ç©ºé—´ç´¢å¼•
auto spatialIndices = workflowProvidedIndices; // æ¥è‡ªå·¥ä½œæµæœåŠ¡
applyPreCalculatedSpatialIndices(dimensions, spatialIndices, start, count);
```

```cpp
// âŒ æ—§æ–¹å¼ï¼šå·¥ä½œæµæœåŠ¡é‡å¤å®ç°ç©ºé—´è®¡ç®—
auto subsetBounds = calculateSpatialSubsetInWorkflow(request);

// âœ… æ–°æ–¹å¼ï¼šå§”æ‰˜ç»™ç©ºé—´æœåŠ¡
auto spatialService = serviceManager_->getService<ISpatialSubsetService>();
auto subsetBounds = spatialService->calculateSubsetBounds(geometry, dataBounds).get();
```

## ğŸ“‹ éªŒè¯æ ‡å‡†

1. **åŠŸèƒ½éªŒè¯**ï¼šæ‰€æœ‰ç°æœ‰æµ‹è¯•ç”¨ä¾‹é€šè¿‡
2. **æ€§èƒ½éªŒè¯**ï¼šç©ºé—´è®¡ç®—æ€§èƒ½æå‡20%ä»¥ä¸Š
3. **æ¶æ„éªŒè¯**ï¼šä¾èµ–å…³ç³»æ¸…æ™°ï¼Œæ— å¾ªç¯ä¾èµ–
4. **ä¸€è‡´æ€§éªŒè¯**ï¼šæ‰€æœ‰æ ¼å¼å¤„ç†å™¨ä½¿ç”¨ç»Ÿä¸€æ¥å£

---

**æ€»ç»“**ï¼šé€šè¿‡æ˜ç¡®çš„èŒè´£åˆ†å·¥å’Œç»Ÿä¸€çš„æ¥å£è®¾è®¡ï¼Œå½»åº•è§£å†³ç©ºé—´å­é›†åŠŸèƒ½é‡å¤å®ç°çš„é—®é¢˜ï¼Œæå‡ç³»ç»Ÿçš„å¯ç»´æŠ¤æ€§ã€æ€§èƒ½å’Œä¸€è‡´æ€§ã€‚ 