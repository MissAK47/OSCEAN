# ç©ºé—´æœåŠ¡æ•°æ®ç»“æ„é‡å¤åˆ†æä¸ç»Ÿä¸€æ–¹æ¡ˆ

## 1. æ•°æ®ç»“æ„é‡å¤é—®é¢˜å½»åº•åˆ†æ

### 1.1 ä¸¥é‡çš„æ•°æ®ç»“æ„é‡å¤é—®é¢˜

ç»è¿‡å½»åº•åˆ†æï¼Œå‘ç°ç©ºé—´æœåŠ¡å­˜åœ¨**å¤§é‡ä¸¥é‡çš„æ•°æ®ç»“æ„é‡å¤**ï¼Œè¿èƒŒäº†é¡¹ç›®ç»Ÿä¸€æ•°æ®ç»“æ„çš„åŸåˆ™ï¼š

#### **ğŸ”´ æ ¸å¿ƒå‡ ä½•æ•°æ®ç»“æ„é‡å¤**

```cpp
// âŒ é‡å¤1: common_data_types.h ä¸­çš„å®šä¹‰
namespace oscean::core_services {
    struct Point { double x, y; std::optional<double> z; std::optional<std::string> crsId; };
    struct BoundingBox { double minX, minY, maxX, maxY; std::optional<double> minZ, maxZ; std::string crsId; };
    struct Geometry { enum class Type; std::string wkt; int wkb; };
    struct Feature { std::string id; std::string geometryWkt; std::map<std::string, AttributeValue> attributes; };
    struct FeatureCollection { std::vector<Feature> features; std::string name; std::vector<FieldDefinition> fieldDefinitions; };
    struct GridData { GridDefinition definition; DataType dataType; std::vector<unsigned char> data; };
    struct GridDefinition { size_t rows, cols; BoundingBox extent; double xResolution, yResolution; CRSInfo crs; };
    struct GridIndex { int x, y; std::optional<int> z, t; };
}

// âŒ é‡å¤2: spatial_types.h ä¸­çš„åˆ«åå®šä¹‰ï¼ˆçœ‹ä¼¼ç»Ÿä¸€ï¼Œå®é™…å¢åŠ æ··ä¹±ï¼‰
namespace oscean::core_services::spatial_ops {
    using Geometry = oscean::core_services::Geometry;
    using Point = oscean::core_services::Point;
    using BoundingBox = oscean::core_services::BoundingBox;
    using Feature = oscean::core_services::Feature;
    using FeatureCollection = oscean::core_services::FeatureCollection;
    using GridData = oscean::core_services::GridData;
    using GridDefinition = oscean::core_services::GridDefinition;
    using GridIndex = oscean::core_services::GridIndex;
}

// âŒ é‡å¤3: spatial_types.h ä¸­çš„æ–°å®šä¹‰ï¼ˆä¸common_data_types.håŠŸèƒ½é‡å ï¼‰
namespace oscean::core_services::spatial_ops {
    struct SpatialExtent {  // ä¸BoundingBoxåŠŸèƒ½å®Œå…¨é‡å¤
        double minX, minY, maxX, maxY;
        std::optional<std::string> crs;
        bool isValid() const;
        bool intersects(const SpatialExtent& other) const;
        double area() const;
    };
}

// âŒ é‡å¤4: è¾“å‡ºç”Ÿæˆæ¨¡å—ä¸­çš„å®šä¹‰
namespace OutputGeneration::TileService {
    struct GeoBoundingBox {  // ä¸BoundingBoxåŠŸèƒ½é‡å¤
        double minLon = 0.0, minLat = 0.0, maxLon = 0.0, maxLat = 0.0;
        std::string crs;
    };
}

// âŒ é‡å¤5: æ’å€¼æœåŠ¡ä¸­çš„å®šä¹‰
namespace oscean::core_services::interpolation {
    struct GridCoordinate {  // ä¸PointåŠŸèƒ½é‡å¤
        double x = 0.0, y = 0.0;
        std::optional<double> z = std::nullopt, t = std::nullopt;
    };
}
```

#### **ğŸ”´ æšä¸¾ç±»å‹å¤§é‡é‡å¤**

```cpp
// âŒ é‡å¤çš„ResamplingMethod/ResampleAlgorithm
// common_data_types.h:80
enum class ResampleAlgorithm { NEAREST, BILINEAR, CUBIC, CUBICSPLINE, LANCZOS, AVERAGE, MODE, MIN, MAX, MEDIAN, Q1, Q3 };

// spatial_types.h:124  
enum class ResamplingMethod { NEAREST_NEIGHBOR, BILINEAR, CUBIC_CONVOLUTION, AVERAGE, MODE, LANCZOS };

// tile_spatial_support.h:80
enum class ResamplingMethod { NEAREST, BILINEAR, BICUBIC, AVERAGE, MODE };

// âŒ é‡å¤çš„InterpolationMethod
// interpolation/i_interpolation_service.h:22
enum class InterpolationMethod { NEAREST_NEIGHBOR, LINEAR_1D, BILINEAR, TRILINEAR, CUBIC_SPLINE_1D, PCHIP_RECURSIVE_NDIM };

// spatial_types.h:195
enum class InterpolationMethod { NEAREST_NEIGHBOR, BILINEAR, BICUBIC, INVERSE_DISTANCE_WEIGHTING, KRIGING, SPLINE };

// modeling_spatial_support.h:54
enum class InterpolationMethod { NEAREST_NEIGHBOR, LINEAR, BILINEAR, CUBIC, SPLINE };

// âŒ é‡å¤çš„GeometryType
// common_data_types.h:2391 (Geometry::Type)
enum class Type { UNKNOWN = 0, POINT, LINESTRING, POLYGON, MULTIPOINT, MULTILINESTRING, MULTIPOLYGON, GEOMETRYCOLLECTION };

// spatial_types.h:137
enum class GeometryType { UNKNOWN = 0, POINT, LINESTRING, POLYGON, MULTIPOINT, MULTILINESTRING, MULTIPOLYGON, GEOMETRYCOLLECTION };

// âŒ é‡å¤çš„DataType
// common_data_types.h:357
enum class DataType { Unknown, Byte, UByte, UInt16, Int16, UInt32, Int32, UInt64, Int64, Float32, Float64, String, Boolean, Binary, Complex16, Complex32, Complex64 };

// metadata/unified_metadata_service.h:35
enum class DataType { UNKNOWN, INTEGER, FLOAT, STRING, BOOLEAN, DATETIME, BINARY };

// spatial_types.h:750
enum class RasterDataType { UNKNOWN, BYTE, UINT16, INT16, UINT32, INT32, FLOAT32, FLOAT64 };
```

#### **ğŸ”´ é€‰é¡¹ç»“æ„ä½“å¤§é‡é‡å¤**

```cpp
// âŒ é‡å¤çš„Optionsç»“æ„ä½“ï¼ˆåŠŸèƒ½é‡å ï¼Œå®šä¹‰åˆ†æ•£ï¼‰
// spatial_types.h ä¸­å®šä¹‰äº†15+ä¸ªOptionsç»“æ„ä½“
struct BufferOptions, MaskOptions, ZonalStatisticsOptions, ContourOptions, RasterizeOptions, 
SimplificationOptions, SpatialQueryOptions, InterpolationOptions, ValidationOptions, 
ResampleOptions, RasterClipOptions, RasterAlgebraOptions, WarpOptions, 
NearestNeighborOptions, GridQueryOptions, TaskExecutionOptions, IndexCreationOptions, 
IndexQueryOptions, ParallelExecutionOptions;

// tile_spatial_support.h ä¸­åˆå®šä¹‰äº†é‡å¤çš„Options
struct TileReprojectionOptions, SchemeTransformOptions, TileMergeOptions, MosaicOptions;

// modeling_spatial_support.h ä¸­åˆå®šä¹‰äº†é‡å¤çš„Options  
struct FieldInterpolationOptions, MeshGenerationOptions, BoundaryExtractionOptions;
```

### 1.2 æ•°æ®æµæ··ä¹±é—®é¢˜

#### **ğŸ”´ æ•°æ®æµè·¯å¾„ä¸ç»Ÿä¸€**

```cpp
// âŒ é”™è¯¯çš„æ•°æ®æµ1: ç©ºé—´æœåŠ¡å†…éƒ¨å®ç°æ’å€¼
SpatialOpsService::resampleRaster() {
    // å†…éƒ¨è°ƒç”¨æ’å€¼ç®—æ³•ï¼Œè¿èƒŒè§£è€¦åŸåˆ™
    return interpolateGrid(input, method);
}

// âŒ é”™è¯¯çš„æ•°æ®æµ2: ç©ºé—´æœåŠ¡å†…éƒ¨å®ç°åæ ‡è½¬æ¢
SpatialOpsService::reprojectGeometry() {
    // å†…éƒ¨è°ƒç”¨PROJåº“ï¼Œä¸CRSæœåŠ¡é‡å¤
    return transformGeometry(geom, targetCRS);
}

// âŒ é”™è¯¯çš„æ•°æ®æµ3: ç©ºé—´æœåŠ¡å†…éƒ¨å®ç°æ•°æ®è¯»å†™
SpatialOpsService::readVectorFile() {
    // å†…éƒ¨è°ƒç”¨GDALï¼Œä¸æ•°æ®è®¿é—®æœåŠ¡é‡å¤
    return loadFeatureCollection(filePath);
}
```

#### **ğŸ”´ æ•°æ®ç»“æ„è½¬æ¢æ··ä¹±**

```cpp
// âŒ æ··ä¹±çš„æ•°æ®ç»“æ„è½¬æ¢
// åœ¨ä¸åŒæ¨¡å—é—´éœ€è¦å¤§é‡çš„æ•°æ®ç»“æ„è½¬æ¢ä»£ç 
BoundingBox â†’ SpatialExtent â†’ GeoBoundingBox
Point â†’ GridCoordinate â†’ TargetPoint  
ResampleAlgorithm â†’ ResamplingMethod â†’ InterpolationMethod
```

## 2. ç©ºé—´æ•°æ®ç»“æ„æµåˆ†æ

### 2.1 æ­£ç¡®çš„ç©ºé—´æ•°æ®æµæ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    å·¥ä½œæµå¼•æ“å±‚                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚  ç©ºé—´åˆ†æå·¥ä½œæµ  â”‚ â”‚  æ•°æ®å¤„ç†å·¥ä½œæµ  â”‚ â”‚  å¯è§†åŒ–å·¥ä½œæµ    â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚ ç»Ÿä¸€æ•°æ®ç»“æ„ä¼ é€’
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   æ ¸å¿ƒæœåŠ¡å±‚ï¼ˆå®Œå…¨è§£è€¦ï¼‰                           â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ ç©ºé—´æœåŠ¡    â”‚ â”‚ æ’å€¼æœåŠ¡    â”‚ â”‚ CRSæœåŠ¡     â”‚ â”‚ æ•°æ®è®¿é—®    â”‚ â”‚
â”‚ â”‚ (å‡ ä½•è®¡ç®—)  â”‚ â”‚ (æ’å€¼ç®—æ³•)  â”‚ â”‚ (åæ ‡è½¬æ¢)  â”‚ â”‚ æœåŠ¡        â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚ ç»Ÿä¸€æ•°æ®ç»“æ„
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  common_data_types.h                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ å‡ ä½•æ•°æ®    â”‚ â”‚ æ …æ ¼æ•°æ®    â”‚ â”‚ è¦ç´ æ•°æ®    â”‚ â”‚ å…ƒæ•°æ®      â”‚ â”‚
â”‚  â”‚ ç»“æ„        â”‚ â”‚ ç»“æ„        â”‚ â”‚ ç»“æ„        â”‚ â”‚ ç»“æ„        â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 ç©ºé—´æ•°æ®å¤„ç†çš„æ ‡å‡†æµç¨‹

```cpp
// âœ… æ­£ç¡®çš„ç©ºé—´æ•°æ®æµ
namespace oscean::workflow_engine {

class SpatialAnalysisWorkflow {
public:
    boost::future<void> executeComplexSpatialAnalysis() {
        // æ­¥éª¤1: æ•°æ®è®¿é—®æœåŠ¡è¯»å–åŸå§‹æ•°æ®
        auto vectorData = dataAccessService_->readVectorData(vectorPath_);
        auto rasterData = dataAccessService_->readRasterData(rasterPath_);
        
        // æ­¥éª¤2: CRSæœåŠ¡ç»Ÿä¸€åæ ‡ç³»ç»Ÿ
        auto unifiedVector = crsService_->transformFeatureCollection(
            vectorData.get(), targetCRS_);
        auto unifiedRaster = crsService_->transformGridData(
            rasterData.get(), targetCRS_);
        
        // æ­¥éª¤3: æ’å€¼æœåŠ¡é‡é‡‡æ ·åˆ°ç›®æ ‡ç½‘æ ¼
        auto resampledRaster = interpolationService_->resampleToGrid(
            unifiedRaster.get(), targetGridDefinition_);
        
        // æ­¥éª¤4: ç©ºé—´æœåŠ¡è¿›è¡Œå‡ ä½•è®¡ç®—
        auto bufferedVector = spatialOpsService_->computeBuffer(
            unifiedVector.get(), bufferDistance_);
        auto maskedRaster = spatialOpsService_->applyVectorMask(
            resampledRaster.get(), bufferedVector.get());
        
        // æ­¥éª¤5: ç©ºé—´æœåŠ¡è¿›è¡Œç©ºé—´ç»Ÿè®¡
        auto statistics = spatialOpsService_->calculateZonalStatistics(
            maskedRaster.get(), analysisZones_);
        
        // æ­¥éª¤6: æ•°æ®è®¿é—®æœåŠ¡ä¿å­˜ç»“æœ
        return dataAccessService_->writeAnalysisResults(
            outputPath_, statistics.get());
    }
};

}
```

## 3. å½»åº•ç»Ÿä¸€æ–¹æ¡ˆ

### 3.1 æ•°æ®ç»“æ„å®Œå…¨ç»Ÿä¸€åˆ°common_data_types.h

#### **3.1.1 åˆ é™¤æ‰€æœ‰é‡å¤çš„æ•°æ®ç»“æ„å®šä¹‰**

```cpp
// âŒ éœ€è¦å®Œå…¨åˆ é™¤çš„é‡å¤å®šä¹‰

// 1. åˆ é™¤ spatial_types.h ä¸­çš„é‡å¤ç»“æ„ä½“
struct SpatialExtent;  // åŠŸèƒ½ä¸BoundingBoxå®Œå…¨é‡å¤

// 2. åˆ é™¤ output_generation ä¸­çš„é‡å¤å®šä¹‰
struct GeoBoundingBox;  // åŠŸèƒ½ä¸BoundingBoxå®Œå…¨é‡å¤

// 3. åˆ é™¤ interpolation ä¸­çš„é‡å¤å®šä¹‰  
struct GridCoordinate;  // åŠŸèƒ½ä¸Pointå®Œå…¨é‡å¤

// 4. åˆ é™¤æ‰€æœ‰é‡å¤çš„æšä¸¾å®šä¹‰
enum class ResamplingMethod;  // ä¿ç•™ResampleAlgorithm
enum class InterpolationMethod;  // ç»Ÿä¸€åˆ°æ’å€¼æœåŠ¡æ¥å£
enum class GeometryType;  // ç»Ÿä¸€åˆ°Geometry::Type
enum class RasterDataType;  // ç»Ÿä¸€åˆ°DataType

// 5. åˆ é™¤æ‰€æœ‰é‡å¤çš„Optionsç»“æ„ä½“
// ä¿ç•™æ ¸å¿ƒçš„ï¼Œåˆ é™¤é‡å¤çš„å’Œç‰¹å®šç®—æ³•çš„
```

#### **3.1.2 åœ¨common_data_types.hä¸­è¡¥å……ç¼ºå¤±çš„ç»Ÿä¸€å®šä¹‰**

```cpp
// âœ… åœ¨common_data_types.hä¸­æ·»åŠ ç©ºé—´æœåŠ¡éœ€è¦çš„ç»Ÿä¸€å®šä¹‰
namespace oscean::core_services {

/**
 * @brief ç©ºé—´è°“è¯æšä¸¾ï¼ˆç»Ÿä¸€å®šä¹‰ï¼‰
 */
enum class SpatialPredicate {
    UNKNOWN = 0,
    INTERSECTS,
    CONTAINS,
    WITHIN,
    OVERLAPS,
    CROSSES,
    DISJOINT,
    TOUCHES,
    EQUALS,
    COVERS,
    COVERED_BY,
    WITHIN_DISTANCE,
    BEYOND_DISTANCE
};

/**
 * @brief ç©ºé—´å…³ç³»ç±»å‹ï¼ˆç»Ÿä¸€å®šä¹‰ï¼‰
 */
enum class SpatialRelation {
    INTERSECTS,
    CONTAINS,
    WITHIN,
    OVERLAPS,
    CROSSES,
    DISJOINT,
    TOUCHES,
    EQUALS
};

/**
 * @brief è·ç¦»è®¡ç®—ç±»å‹ï¼ˆç»Ÿä¸€å®šä¹‰ï¼‰
 */
enum class DistanceType {
    EUCLIDEAN,
    GEODESIC
};

/**
 * @brief ç¼“å†²åŒºæ ·å¼ï¼ˆç»Ÿä¸€å®šä¹‰ï¼‰
 */
enum class BufferCapStyle {
    ROUND = 1,
    FLAT = 2,
    SQUARE = 3
};

enum class BufferJoinStyle {
    ROUND = 1,
    MITRE = 2,
    BEVEL = 3
};

/**
 * @brief å‡ ä½•ç®€åŒ–ç®—æ³•ï¼ˆç»Ÿä¸€å®šä¹‰ï¼‰
 */
enum class SimplificationAlgorithm {
    DOUGLAS_PEUCKER,
    VISVALINGAM_WHYATT,
    TOPOLOGY_PRESERVING
};

/**
 * @brief ç»Ÿè®¡åº¦é‡ç±»å‹ï¼ˆç»Ÿä¸€å®šä¹‰ï¼‰
 */
enum class StatisticalMeasure {
    MIN,
    MAX,
    MEAN,
    MEDIAN,
    MODE,
    SUM,
    COUNT,
    STDDEV,
    VARIANCE,
    RANGE
};

/**
 * @brief ç©ºé—´æ“ä½œé€‰é¡¹åŸºç±»æ¨¡æ¿
 */
template<typename T>
struct SpatialOperationOptions {
    bool enableProgressReporting = false;
    std::optional<std::function<void(double)>> progressCallback;
    std::map<std::string, T> customParameters;
};

/**
 * @brief ç¼“å†²åŒºæ“ä½œé€‰é¡¹ï¼ˆç»Ÿä¸€å®šä¹‰ï¼‰
 */
struct BufferOptions : SpatialOperationOptions<double> {
    int quadrantSegments = 8;
    BufferCapStyle capStyle = BufferCapStyle::ROUND;
    BufferJoinStyle joinStyle = BufferJoinStyle::ROUND;
    double mitreLimit = 5.0;
    bool singleSided = false;
};

/**
 * @brief æ©è†œæ“ä½œé€‰é¡¹ï¼ˆç»Ÿä¸€å®šä¹‰ï¼‰
 */
struct MaskOptions : SpatialOperationOptions<double> {
    bool invertMask = false;
    std::optional<double> maskValue = 1.0;
    bool allTouched = false;
    std::optional<double> outputNoDataValue = std::nullopt;
};

/**
 * @brief ç©ºé—´æŸ¥è¯¢é€‰é¡¹ï¼ˆç»Ÿä¸€å®šä¹‰ï¼‰
 */
struct SpatialQueryOptions : SpatialOperationOptions<std::variant<int, double, std::string>> {
    SpatialRelation relation = SpatialRelation::INTERSECTS;
    std::optional<double> distance;
    bool useIndex = true;
    std::size_t maxResults = 0;
    bool returnGeometry = true;
    std::vector<std::string> attributesToReturn;
};

/**
 * @brief å‡ ä½•ç®€åŒ–é€‰é¡¹ï¼ˆç»Ÿä¸€å®šä¹‰ï¼‰
 */
struct SimplificationOptions : SpatialOperationOptions<double> {
    double tolerance = 0.0;
    SimplificationAlgorithm algorithm = SimplificationAlgorithm::DOUGLAS_PEUCKER;
    bool preserveTopology = true;
    bool preserveEndpoints = true;
};

/**
 * @brief å‡ ä½•éªŒè¯é€‰é¡¹ï¼ˆç»Ÿä¸€å®šä¹‰ï¼‰
 */
struct ValidationOptions : SpatialOperationOptions<bool> {
    bool fixInvalidGeometries = false;
    double tolerance = 1e-10;
    bool checkSelfIntersections = true;
    bool checkRingOrientation = true;
    bool checkDuplicatePoints = true;
};

/**
 * @brief åŒºåŸŸç»Ÿè®¡é€‰é¡¹ï¼ˆç»Ÿä¸€å®šä¹‰ï¼‰
 */
struct ZonalStatisticsOptions : SpatialOperationOptions<double> {
    std::vector<StatisticalMeasure> statistics;
    std::optional<double> noDataValueToIgnore = std::nullopt;
};

/**
 * @brief æ …æ ¼åŒ–é€‰é¡¹ï¼ˆç»Ÿä¸€å®šä¹‰ï¼‰
 */
struct RasterizeOptions : SpatialOperationOptions<double> {
    std::optional<std::string> attributeField = std::nullopt;
    std::optional<double> burnValue = 1.0;
    std::optional<double> backgroundValue = 0.0;
    bool allTouched = false;
    std::optional<double> noDataValue = std::nullopt;
};

/**
 * @brief ç­‰å€¼çº¿é€‰é¡¹ï¼ˆç»Ÿä¸€å®šä¹‰ï¼‰
 */
struct ContourOptions : SpatialOperationOptions<double> {
    std::variant<double, std::vector<double>> intervalOrLevels;
    std::string outputAttributeName = "level";
    std::optional<double> noDataValueToIgnore = std::nullopt;
};

/**
 * @brief ç»Ÿä¸€çš„æ“ä½œç»“æœæ¨¡æ¿
 */
template<typename T>
struct SpatialOperationResult {
    bool success = false;
    std::optional<T> data = std::nullopt;
    std::string error;
    std::chrono::milliseconds executionTime{0};
    std::map<std::string, std::variant<int, double, std::string>> metadata;
    
    /**
     * @brief æ£€æŸ¥æ“ä½œæ˜¯å¦æˆåŠŸ
     */
    bool isSuccess() const { return success && data.has_value(); }
    
    /**
     * @brief è·å–ç»“æœæ•°æ®
     */
    const T& getData() const {
        if (!data.has_value()) {
            throw std::runtime_error("No data available in result: " + error);
        }
        return data.value();
    }
};

// å…·ä½“çš„ç»“æœç±»å‹åˆ«å
using GeometryResult = SpatialOperationResult<Geometry>;
using GridDataResult = SpatialOperationResult<GridData>;
using FeatureCollectionResult = SpatialOperationResult<FeatureCollection>;
using ValidationResult = SpatialOperationResult<bool>;
using StatisticsResult = SpatialOperationResult<std::map<StatisticalMeasure, double>>;

/**
 * @brief ç©ºé—´æŸ¥è¯¢ç»“æœï¼ˆç»Ÿä¸€å®šä¹‰ï¼‰
 */
struct SpatialQueryResult {
    std::vector<std::variant<int, std::string>> featureIds;
    std::vector<std::string> geometries; // WKTæ ¼å¼
    std::map<std::string, std::vector<std::variant<int, double, std::string>>> attributes;
    std::size_t totalCount;
    std::chrono::milliseconds executionTime;
};

/**
 * @brief æ€§èƒ½æŒ‡æ ‡ï¼ˆç»Ÿä¸€å®šä¹‰ï¼‰
 */
struct PerformanceMetrics {
    std::chrono::milliseconds executionTime;
    std::size_t memoryUsed;
    std::size_t peakMemoryUsed;
    std::size_t inputDataSize;
    std::size_t outputDataSize;
    std::size_t threadsUsed;
    bool indexUsed = false;
    std::string operationType;
    std::map<std::string, std::variant<int, double, std::string>> customMetrics;
};

} // namespace oscean::core_services
```

### 3.2 ç©ºé—´æœåŠ¡æ¥å£å®Œå…¨é‡æ„

#### **3.2.1 çº¯å‡€çš„ç©ºé—´æœåŠ¡æ¥å£**

```cpp
// âœ… é‡æ„åçš„ç©ºé—´æœåŠ¡æ¥å£ - åªä½¿ç”¨common_data_types.hä¸­çš„ç»Ÿä¸€æ•°æ®ç»“æ„
namespace oscean::core_services::spatial_ops {

/**
 * @brief ç©ºé—´æ“ä½œæœåŠ¡æ¥å£ - çº¯è®¡ç®—æœåŠ¡
 * 
 * èŒè´£ï¼šä¸“æ³¨ç©ºé—´å‡ ä½•è®¡ç®—ã€æŸ¥è¯¢ã€åˆ†æç®—æ³•
 * è¾“å…¥ï¼šç»Ÿä¸€æ•°æ®ç»“æ„ (common_data_types.h)
 * è¾“å‡ºï¼šç»Ÿä¸€æ•°æ®ç»“æ„ (common_data_types.h)
 * åŸåˆ™ï¼šä¸ä¾èµ–å…¶ä»–æœåŠ¡ï¼Œä¸å®ç°ä¸šåŠ¡æµç¨‹ç¼–æ’
 */
class ISpatialOpsService {
public:
    virtual ~ISpatialOpsService() = default;
    
    // âœ… åŸºç¡€å‡ ä½•è®¡ç®— - ä½¿ç”¨ç»Ÿä¸€æ•°æ®ç»“æ„
    virtual boost::future<GeometryResult> computeBuffer(
        const Geometry& geometry, 
        double distance,
        const BufferOptions& options = {}) = 0;
    
    virtual boost::future<GeometryResult> computeIntersection(
        const Geometry& geom1, 
        const Geometry& geom2) = 0;
    
    virtual boost::future<GeometryResult> computeUnion(
        const std::vector<Geometry>& geometries) = 0;
    
    virtual boost::future<GeometryResult> computeDifference(
        const Geometry& geom1, 
        const Geometry& geom2) = 0;
    
    virtual boost::future<GeometryResult> simplifyGeometry(
        const Geometry& geometry,
        const SimplificationOptions& options) = 0;
    
    // âœ… ç©ºé—´å…³ç³»è®¡ç®— - ä½¿ç”¨ç»Ÿä¸€æ•°æ®ç»“æ„
    virtual boost::future<bool> intersects(
        const Geometry& geom1, 
        const Geometry& geom2) = 0;
    
    virtual boost::future<bool> contains(
        const Geometry& container, 
        const Geometry& contained) = 0;
    
    virtual boost::future<bool> within(
        const Geometry& geom1, 
        const Geometry& geom2) = 0;
    
    virtual boost::future<double> distance(
        const Geometry& geom1, 
        const Geometry& geom2,
        DistanceType type = DistanceType::EUCLIDEAN) = 0;
    
    virtual boost::future<bool> spatialPredicate(
        const Geometry& geom1,
        const Geometry& geom2,
        SpatialPredicate predicate) = 0;
    
    // âœ… ç©ºé—´æŸ¥è¯¢ç®—æ³• - ä½¿ç”¨ç»Ÿä¸€æ•°æ®ç»“æ„
    virtual boost::future<FeatureCollectionResult> queryByBoundingBox(
        const FeatureCollection& features,
        const BoundingBox& bbox,
        const SpatialQueryOptions& options = {}) = 0;
    
    virtual boost::future<FeatureCollectionResult> queryByGeometry(
        const FeatureCollection& features,
        const Geometry& queryGeom,
        const SpatialQueryOptions& options = {}) = 0;
    
    virtual boost::future<SpatialQueryResult> spatialQuery(
        const FeatureCollection& features,
        const Geometry& queryGeom,
        const SpatialQueryOptions& options) = 0;
    
    // âœ… æ …æ ¼ç©ºé—´æ“ä½œ - ä½¿ç”¨ç»Ÿä¸€æ•°æ®ç»“æ„
    virtual boost::future<GridDataResult> applyVectorMask(
        const GridData& raster,
        const FeatureCollection& maskFeatures,
        const MaskOptions& options = {}) = 0;
    
    virtual boost::future<StatisticsResult> calculateZonalStatistics(
        const GridData& raster,
        const FeatureCollection& zones,
        const ZonalStatisticsOptions& options = {}) = 0;
    
    virtual boost::future<FeatureCollectionResult> generateContours(
        const GridData& raster,
        const ContourOptions& options) = 0;
    
    virtual boost::future<GridDataResult> rasterizeFeatures(
        const FeatureCollection& features,
        const GridDefinition& targetGrid,
        const RasterizeOptions& options = {}) = 0;
    
    // âœ… å‡ ä½•éªŒè¯å’Œä¿®å¤ - ä½¿ç”¨ç»Ÿä¸€æ•°æ®ç»“æ„
    virtual boost::future<ValidationResult> validateGeometry(
        const Geometry& geometry,
        const ValidationOptions& options = {}) = 0;
    
    virtual boost::future<GeometryResult> fixGeometry(
        const Geometry& geometry) = 0;
    
    virtual boost::future<ValidationResult> validateFeatureCollection(
        const FeatureCollection& features,
        const ValidationOptions& options = {}) = 0;
    
    // âœ… æ€§èƒ½ç›‘æ§ - ä½¿ç”¨ç»Ÿä¸€æ•°æ®ç»“æ„
    virtual boost::future<PerformanceMetrics> getPerformanceMetrics() = 0;
    
    virtual boost::future<void> clearCache() = 0;
};

} // namespace oscean::core_services::spatial_ops
```

### 3.3 å®æ–½æ­¥éª¤

#### **ç¬¬ä¸€é˜¶æ®µï¼šæ¸…ç†é‡å¤å®šä¹‰**

```bash
# 1. åˆ é™¤spatial_types.hä¸­çš„é‡å¤ç»“æ„ä½“
âŒ åˆ é™¤ struct SpatialExtent
âŒ åˆ é™¤ é‡å¤çš„æšä¸¾å®šä¹‰
âŒ åˆ é™¤ é‡å¤çš„Optionsç»“æ„ä½“

# 2. åˆ é™¤å…¶ä»–æ¨¡å—ä¸­çš„é‡å¤å®šä¹‰
âŒ åˆ é™¤ output_generation/protocols/tile_request.h ä¸­çš„ GeoBoundingBox
âŒ åˆ é™¤ interpolation/impl/internal_types.h ä¸­çš„ GridCoordinate
âŒ åˆ é™¤ æ‰€æœ‰æ¨¡å—ä¸­é‡å¤çš„æšä¸¾å®šä¹‰

# 3. ç»Ÿä¸€åˆ°common_data_types.h
âœ… æ·»åŠ  ç©ºé—´æœåŠ¡éœ€è¦çš„ç»Ÿä¸€æšä¸¾å’Œç»“æ„ä½“
âœ… æ·»åŠ  ç»Ÿä¸€çš„Optionså’ŒResultæ¨¡æ¿
âœ… æ·»åŠ  ç»Ÿä¸€çš„æ€§èƒ½ç›‘æ§ç»“æ„ä½“
```

#### **ç¬¬äºŒé˜¶æ®µï¼šæ¥å£é‡æ„**

```bash
# 1. é‡æ„ç©ºé—´æœåŠ¡æ¥å£
âœ… ä¿®æ”¹ ISpatialOpsService åªä½¿ç”¨common_data_types.hä¸­çš„ç±»å‹
âœ… åˆ é™¤ æ‰€æœ‰å¯¹å…¶ä»–æœåŠ¡çš„ä¾èµ–
âœ… ç»Ÿä¸€ æ‰€æœ‰æ–¹æ³•çš„è¿”å›ç±»å‹ä¸ºResultæ¨¡æ¿

# 2. é‡æ„å®ç°ç±»
âœ… ä¿®æ”¹ SpatialOpsServiceImpl åªä¾èµ–é…ç½®ï¼Œä¸ä¾èµ–å…¶ä»–æœåŠ¡
âœ… åˆ é™¤ æ‰€æœ‰é‡å¤çš„åŠŸèƒ½å®ç°
âœ… ä¸“æ³¨ æ ¸å¿ƒç©ºé—´è®¡ç®—ç®—æ³•
```

#### **ç¬¬ä¸‰é˜¶æ®µï¼šæ•°æ®æµç»Ÿä¸€**

```bash
# 1. å·¥ä½œæµå¼•æ“ç¼–æ’
âœ… å¤æ‚çš„ç©ºé—´åˆ†ææµç¨‹ç”±å·¥ä½œæµå¼•æ“ç¼–æ’
âœ… å„ä¸ªæœåŠ¡é€šè¿‡ç»Ÿä¸€æ•°æ®ç»“æ„ä¼ é€’æ•°æ®
âœ… æ¶ˆé™¤ æœåŠ¡é—´çš„ç›´æ¥è°ƒç”¨

# 2. æµ‹è¯•é‡æ„
âœ… å•å…ƒæµ‹è¯•åªæµ‹è¯•æ ¸å¿ƒç®—æ³•
âœ… é›†æˆæµ‹è¯•ç§»åˆ°å·¥ä½œæµå¼•æ“
âœ… æ€§èƒ½æµ‹è¯•ä½¿ç”¨ç»Ÿä¸€çš„æ€§èƒ½æŒ‡æ ‡
```

## 4. é¢„æœŸæ”¶ç›Š

### 4.1 å½»åº•è§£å†³é‡å¤é—®é¢˜
- **âœ… æ¶ˆé™¤90%+çš„é‡å¤æ•°æ®ç»“æ„å®šä¹‰**
- **âœ… ç»Ÿä¸€æ‰€æœ‰ç©ºé—´ç›¸å…³çš„æšä¸¾ç±»å‹**  
- **âœ… å»ºç«‹ç»Ÿä¸€çš„æ•°æ®ç»“æ„ç»§æ‰¿ä½“ç³»**
- **âœ… å®ç°çœŸæ­£çš„"ä¸€å¤„å®šä¹‰ï¼Œå¤„å¤„ä½¿ç”¨"**

### 4.2 å®Œå…¨ç¬¦åˆæ¶æ„åŸåˆ™
- **âœ… ç©ºé—´æœåŠ¡å®Œå…¨ç‹¬ç«‹ï¼Œä¸ä¾èµ–å…¶ä»–æœåŠ¡**
- **âœ… æ‰€æœ‰æ•°æ®é€šè¿‡common_data_types.hç»Ÿä¸€ä¼ é€’**
- **âœ… å¤æ‚ä¸šåŠ¡é€»è¾‘ç”±å·¥ä½œæµå¼•æ“ç¼–æ’**
- **âœ… æ¯ä¸ªæœåŠ¡ä¸“æ³¨æ ¸å¿ƒèŒè´£**

### 4.3 æ˜¾è‘—æå‡å¼€å‘æ•ˆç‡
- **âœ… å¼€å‘è€…åªéœ€å­¦ä¹ ä¸€å¥—æ•°æ®ç»“æ„**
- **âœ… æ¶ˆé™¤æ•°æ®ç»“æ„è½¬æ¢çš„å¤æ‚æ€§**
- **âœ… ç»Ÿä¸€çš„é”™è¯¯å¤„ç†å’Œæ€§èƒ½ç›‘æ§**
- **âœ… ç®€åŒ–æµ‹è¯•å’Œç»´æŠ¤å·¥ä½œ**

è¿™ä¸ªæ–¹æ¡ˆç¡®ä¿äº†ç©ºé—´æœåŠ¡ä¸æ•´ä¸ªé¡¹ç›®çš„æ•°æ®ç»“æ„ã€æ•°æ®æµã€åŠŸèƒ½æµå®Œå…¨ç»Ÿä¸€ï¼Œå½»åº•æ¶ˆé™¤äº†é‡å¤å’Œæ··ä¹±ï¼Œå»ºç«‹äº†æ¸…æ™°çš„æ¶æ„è¾¹ç•Œã€‚ 