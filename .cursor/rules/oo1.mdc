---
description: 
globs: 
alwaysApply: true
---
保持使用中文回答。

对超过1000行的代码文件提示分为多个文件。

要系统性的读取项目代码，分析代码结构，并根据重构计划和API接口内容，对data数据处理模块进行完整性修复。修复过程中，要深入查找问题的原因，另外，不允许再新建立任何文件，也不要使用批处理命令。项目使用了vcpkg来管理3库，你需要清理cmake环境配置的正确性和完整性，从顶层配置中传递3方勯 的管理，不要单独在子目录下配置库的管理，否则会有很多问题。编译必须在主build目录下。

在建立任何数据结构之前，必须先检查在通用数据结构文件common_data_types.h中是否已经有定义，不得重复定义。

**核心规则摘要 (基于 C++ AI 编程指南):**

**1. 基本原则 (Basic Principles)**

*   **1.1 语言:** 代码标识符和提交信息**必须**使用英文。规则描述和注释使用中文。
*   **1.2 C++ 标准:** 项目**必须**明确指定 C++ 标准（如 C++17/C++20），**禁止**使用低于标准的特性。
*   **1.3 类型安全:** **总是**显式声明类型，**优先**使用 `enum class`。
*   **1.4 抽象:** **必须**创建自定义类型表示业务概念，**避免**基本类型滥用。
*   **1.5 文档注释:** 公共接口**必须**使用 Doxygen 风格注释。
*   **1.6 代码简洁:** 函数体内**避免**不必要的空行，允许用空行分隔逻辑块。
*   **1.7 ODR:** **严格**遵循单一定义规则。
*   **1.8 目标:** 编码决策**应**以可读性、可维护性、正确性和性能为导向。

**2. 命名规范 (Nomenclature)**

*   **2.1 类/结构体:** **必须**使用帕斯卡命名法 (PascalCase)。
*   **2.2 变量/函数/方法:** **必须**使用驼峰命名法 (camelCase)。
*   **2.3 常量/宏:** **必须**使用全大写加下划线 (ALL_CAPS)，**优先**使用 `const`/`constexpr`。
*   **2.4 文件/目录:** **必须**使用蛇形命名法 (snake_case)。
*   **2.5 环境变量:** **必须**使用全大写 (UPPERCASE)。
*   **2.6 魔法数:** **禁止**使用魔法数/魔法字符串，**必须**定义为具名常量。
*   **2.7 函数动词:** 函数名**应**以动词开头。
*   **2.8 布尔命名:** 布尔类型**应**以 `is`, `has`, `can`, `should` 等开头。
*   **2.9 完整性:** **必须**使用完整单词，允许标准缩写和常见局部变量名。
*   **2.10 模板参数:** 类型参数用大写字母或描述性名称，可变参数用 `Args...`。
*   **2.11 成员变量 (可选):** **考虑**使用统一前/后缀 (`m_`/`_`)。

**3. 函数与方法 (Functions & Methods)**

*   **3.1 职责单一:** 函数/方法**应**短小（建议 < 20-30 行），只做一件事。
*   **3.2 嵌套深度:** **避免**过深的嵌套，使用卫语句、辅助函数、标准算法。
*   **3.3 标准库算法:** **优先**使用 `<algorithm>`, `<numeric>`, `<ranges>` 中的算法。
*   **3.4 Lambda:** 仅用于简单、局部、一次性操作，复杂逻辑**应**使用具名函数。
*   **3.5 参数数量:** **不宜过多**（建议 < 4-5 个），使用参数对象。
*   **3.6 返回多值:** **优先**使用 `std::pair`, `std::tuple`, 或结果对象，**避免**输出参数。
*   **3.7 参数传递:**
    *   廉价只读: **按值**。
    *   需修改: **按非 `const` 引用/指针**。
    *   只读且昂贵/不拷贝: **按 `const` 引用**。
    *   转移所有权: **按值 `std::move` 或右值引用**。
    *   只读字符串: **优先** `std::string_view`。
*   **3.8 默认参数:** 合理使用，注意接口僵化和 ABI 问题。
*   **3.9 抽象层级:** 函数内语句**应**处于同一抽象层级。
*   **3.10 `noexcept`:** **必须**标记保证不抛异常的函数。

**4. 数据与类型 (Data & Types)**

*   **4.1 封装:** **必须**将相关数据封装在 `struct`/`class` 中。
*   **4.2 不变性:** **优先**设计不可变数据结构，**必须**对不应改变的数据用 `const`。
*   **4.3 编译时常量:** **必须**使用 `constexpr`。
*   **4.4 内部校验:** 数据校验**应**尽可能在类型内部完成。
*   **4.5 可选值:** **必须**使用 `std::optional` (C++17)。
*   **4.6 预期结果/错误:** **优先**使用 `std::expected` (C++23) 或类似机制。
*   **4.7 视图:** **应**对非拥有式连续数据视图使用 `std::span` (C++20)。

**5. 类设计 (Classes)**

*   **5.1 SOLID:** **遵循** SOLID 原则。
*   **5.2 组合优于继承:** **优先**使用组合和接口。
*   **5.3 接口:** 定义为纯抽象基类或使用 Concepts (C++20)。
*   **5.4 规模控制:** 类**应**保持小巧（建议代码 < 200-300 行，公共方法 < 10-15 个，成员 < 10-15 个）。
*   **5.5 资源管理:** **严格**遵循 RAII，**优先**实现零法则，否则**必须**遵循五法则。
*   **5.6 封装性:** 成员变量**默认** `private`，提供最小化公共接口。
*   **5.7 `const` 正确性:** 不修改状态的成员函数**必须** `const`。
*   **5.8 继承控制:** **必须**使用 `override`，按需使用 `final`。

**6. 错误处理 (Error Handling)**

*   **6.1 异常场景:** **仅**用于不可恢复的严重错误。
*   **6.2 异常处理:** **避免**空 `catch` 或吞掉异常。
*   **6.3 预期失败:** **必须**使用 `std::optional`, `std::expected`, 或错误码。
*   **6.4 策略:** 项目**应**制定清晰、一致的错误处理策略。

**7. 内存与资源管理 (Memory & Resource Management)**

*   **7.1 智能指针:** **优先**使用 `std::unique_ptr` 和 `std::shared_ptr`。
*   **7.2 RAII:** **广泛**应用 RAII 管理所有资源。
*   **7.3 避免手动管理:** **尽可能避免** `new`/`delete`，**禁止** `malloc`/`free`。
*   **7.4 标准容器:** **必须**使用标准容器管理数据集合。

**8. 测试 (Testing)**

*   **8.1 单元测试:** **必须**为重要接口、复杂逻辑编写单元测试 (AAA 模式)。
*   **8.2 命名:** 测试命名**必须**清晰、描述性强。
*   **8.3 测试替身:** 使用 Mock/Stub/Fake 隔离被测单元。
*   **8.4 集成测试:** 为关键模块交互编写集成测试 (GWT 模式)。
*   **8.5 覆盖率与质量:** **更关注**测试质量而非仅覆盖率。

**9. 项目结构与构建 (Project Structure & Build)**

*   **9.1 模块化:** 提倡模块化设计。
*   **9.2 目录结构:** 采用逻辑清晰的结构（如 `include/`, `src/`, `tests/`）。
*   **9.3 构建系统:** **必须**使用现代化构建系统 (如 CMake)。
*   **9.4 接口分离:** **严格**分离接口 (.h/.hpp) 和实现 (.cpp)。
*   **9.5 命名空间:** **广泛**使用命名空间。
*   **9.6 头文件保护:** **必须**使用 `#pragma once` 或包含卫哨。

**10. 标准库使用 (Standard Library Usage)**

*   **10.1 优先使用:** **尽可能**利用标准库。
*   **10.2 字符串:** **必须**使用 `std::string` 和 `std::string_view`。
*   **10.3 容器:** 使用合适的标准容器。
*   **10.4 现代类型:** 使用 `std::optional`, `std::variant`, `std::any`, `std::span`。
*   **10.5 文件系统:** 使用 `<filesystem>` (C++17)。
*   **10.6 时间日期:** 使用 `<chrono>`。
*   **10.7 算法:** **广泛**使用 `<algorithm>` 和 `<numeric>`。

**11. 并发编程 (Concurrency)**

*   **11.1 标准原语:** **必须**使用标准库并发工具。
*   **11.2 任务优于线程:** **优先**考虑基于任务的并行 (`std::async`)。
*   **11.3 原子操作:** 对简单共享数据使用 `std::atomic`。
*   **11.4 数据竞争:** **必须**通过同步机制保护共享数据，**严防**数据竞争。
*   **11.5 死锁:** **警惕并避免**死锁，使用 `std::scoped_lock` 或 `std::lock`。
*   **11.6 线程安全:** 设计或选择线程安全的数据结构，或确保访问受保护。

**12. 代码格式化与静态分析 (Formatting & Static Analysis)**

*   **12.1 代码格式化:** **必须**定义统一规范并使用工具 (如 ClangFormat) 强制执行，配置文件**必须**版本控制。
*   **12.2 静态分析:** **必须**集成静态分析工具 (如 Clang-Tidy) 到流程中，并**修复**高优先级问题，配置文件**应**版本控制。

**13. 依赖管理 (Dependencies)**

*   **13.1 包管理器:** **推荐**使用包管理器 (如 Conan, vcpkg)。
*   **13.2 依赖规范:** **必须**明确记录依赖及其版本，配置文件**必须**版本控制。

**14. AI 特定考量 (AI Specific Considerations)**

*   **14.1 性能敏感性:** **高度关注**内存、复制、缓存局部性，使用 Profiler。
*   **14.2 大规模数据:** 使用高效结构、序列化，考虑内存映射、流式处理。
*   **14.3 AI 库实践:** **遵循**特定 AI 库的最佳实践和 API 约定。
*   **14.4 数值稳定性:** **警惕**浮点数问题，必要时用 `double` 或特定库。

**15. Modern C++ 特性 (Modern C++ Features)**

*   **15.1 `auto` 使用**: 合理使用，但**不应**降低代码清晰度。
*   **15.2 避免 C 风格:**
    *   `NULL` -> **必须** `nullptr`。
    *   C 风格转换 -> **必须** `static_cast` 等。
    *   `printf` -> **优先** iostreams 或 `{fmt}`。
    *   C 数组 -> **必须** `std::array`/`std::vector`。
*   **15.3 拥抱新特性:** 鼓励学习和使用新标准特性。

