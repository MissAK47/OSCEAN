# æ•°æ®å·¥ä½œæµé«˜çº§ä¼˜åŒ–æ–¹æ¡ˆ - ç¬¬4æ­¥ï¼šæ•°æ®è¾“å‡ºé˜¶æ®µ

## æ¦‚è¿°

ç¬¬4æ­¥æ˜¯æ•°æ®å·¥ä½œæµçš„æœ€ç»ˆè¾“å‡ºé˜¶æ®µï¼Œè´Ÿè´£å°†ç¬¬3æ­¥ç”Ÿæˆçš„æ ‡å‡†åŒ–æ•°æ®ç½‘æ ¼è½¬æ¢ä¸ºç”¨æˆ·å¯ç”¨çš„æ ¼å¼ã€‚ä¸»è¦åŒ…æ‹¬ä¸¤ç§è¾“å‡ºæ–¹å¼ï¼š
1. **æ–‡æœ¬æ–‡ä»¶è¾“å‡º**ï¼šç”¨äºéªŒè¯å’Œè°ƒè¯•ï¼Œç”ŸæˆCSVã€JSONç­‰æ ¼å¼
2. **å›¾ç‰‡æ–‡ä»¶è¾“å‡º**ï¼šä½¿ç”¨GDALç”ŸæˆGeoTIFFã€PNGç­‰å¯è§†åŒ–å›¾ç‰‡

## 7. ç¬¬å››æ­¥ï¼šæ•°æ®è¾“å‡ºä¸å¯è§†åŒ–

### 7.1 æ•°æ®è¾“å‡ºç®¡ç†å™¨è®¾è®¡

```cpp
/**
 * @brief æ•°æ®è¾“å‡ºç®¡ç†å™¨ - ç¬¬å››æ­¥çš„æ ¸å¿ƒåŠŸèƒ½æ¨¡å—
 */
class DataOutputManager {
public:
    /**
     * @brief è¾“å‡ºé…ç½®å‚æ•°
     */
    struct OutputConfiguration {
        // è¾“å‡ºæ ¼å¼é…ç½®
        enum class OutputFormat {
            TEXT_CSV,           // CSVæ–‡æœ¬æ–‡ä»¶
            TEXT_JSON,          // JSONæ ¼å¼æ–‡ä»¶
            TEXT_GRID_ASCII,    // ASCIIç½‘æ ¼æ ¼å¼
            IMAGE_GEOTIFF,      // GeoTIFFå›¾åƒ
            IMAGE_PNG,          // PNGå›¾åƒ
            IMAGE_JPEG,         // JPEGå›¾åƒ
            COMBINED            // åŒæ—¶è¾“å‡ºå¤šç§æ ¼å¼
        };
        
        OutputFormat primaryFormat = OutputFormat::TEXT_CSV;
        std::vector<OutputFormat> additionalFormats;
        
        // è¾“å‡ºè·¯å¾„é…ç½®
        std::string outputDirectory;
        std::string baseFileName;
        bool createTimestampedFolder = true;
        bool preserveSourceStructure = false;
        
        // æ–‡æœ¬è¾“å‡ºé…ç½®
        struct TextOutputConfig {
            std::string delimiter = ",";                    // CSVåˆ†éš”ç¬¦
            bool includeHeader = true;                      // æ˜¯å¦åŒ…å«è¡¨å¤´
            bool includeCoordinates = true;                 // æ˜¯å¦åŒ…å«åæ ‡ä¿¡æ¯
            bool includeQualityInfo = true;                 // æ˜¯å¦åŒ…å«è´¨é‡ä¿¡æ¯
            bool includeMetadata = true;                    // æ˜¯å¦åŒ…å«å…ƒæ•°æ®
            int precision = 6;                              // æ•°å€¼ç²¾åº¦
            std::string nullValueRepresentation = "NaN";    // ç©ºå€¼è¡¨ç¤º
            bool compressOutput = false;                    // æ˜¯å¦å‹ç¼©è¾“å‡º
        } textConfig;
        
        // å›¾åƒè¾“å‡ºé…ç½®
        struct ImageOutputConfig {
            // é¢œè‰²æ˜ å°„é…ç½®
            enum class ColorMap {
                VIRIDIS,        // ç§‘å­¦å¯è§†åŒ–å¸¸ç”¨
                PLASMA,         // é«˜å¯¹æ¯”åº¦
                INFERNO,        // æš–è‰²è°ƒ
                MAGMA,          // å†·æš–ç»“åˆ
                JET,            // ä¼ ç»Ÿå½©è™¹è‰²
                GRAYSCALE,      // ç°åº¦
                CUSTOM          // è‡ªå®šä¹‰é¢œè‰²è¡¨
            };
            
            ColorMap colorMap = ColorMap::VIRIDIS;
            std::vector<std::tuple<double, uint8_t, uint8_t, uint8_t>> customColorTable;
            
            // å›¾åƒå°ºå¯¸å’Œè´¨é‡
            std::optional<std::pair<int, int>> outputSize;  // è¾“å‡ºå°ºå¯¸(å®½,é«˜)ï¼Œç©ºåˆ™ä½¿ç”¨åŸå§‹å°ºå¯¸
            int jpegQuality = 85;                           // JPEGè´¨é‡(1-100)
            bool generateWorldFile = true;                  // æ˜¯å¦ç”Ÿæˆä¸–ç•Œæ–‡ä»¶
            bool embedGeoReference = true;                  // æ˜¯å¦åµŒå…¥åœ°ç†å‚è€ƒä¿¡æ¯
            
            // æ•°æ®èŒƒå›´å’Œç¼©æ”¾
            std::optional<std::pair<double, double>> valueRange; // æ•°æ®å€¼èŒƒå›´ï¼Œç©ºåˆ™è‡ªåŠ¨è®¡ç®—
            bool usePercentileClipping = true;              // æ˜¯å¦ä½¿ç”¨ç™¾åˆ†ä½è£å‰ª
            double lowerPercentile = 2.0;                   // ä¸‹ç™¾åˆ†ä½
            double upperPercentile = 98.0;                  // ä¸Šç™¾åˆ†ä½
            
            // å›¾ä¾‹å’Œæ ‡æ³¨
            bool generateLegend = true;                     // æ˜¯å¦ç”Ÿæˆå›¾ä¾‹
            std::string title;                              // å›¾åƒæ ‡é¢˜
            std::string variableLabel;                      // å˜é‡æ ‡ç­¾
            std::string units;                              // å•ä½
            
        } imageConfig;
        
        // æ€§èƒ½é…ç½®
        struct PerformanceConfig {
            bool enableParallelProcessing = true;           // å¹¶è¡Œå¤„ç†
            size_t maxThreads = std::thread::hardware_concurrency();
            bool enableMemoryOptimization = true;          // å†…å­˜ä¼˜åŒ–
            size_t maxMemoryUsageMB = 1024;                // æœ€å¤§å†…å­˜ä½¿ç”¨(MB)
            bool enableProgressReporting = true;           // è¿›åº¦æŠ¥å‘Š
        } performanceConfig;
    };
    
    /**
     * @brief è¾“å‡ºç»“æœ
     */
    struct OutputResult {
        bool success = false;
        std::string errorMessage;
        
        // ç”Ÿæˆçš„æ–‡ä»¶ä¿¡æ¯
        struct GeneratedFile {
            std::string filePath;
            OutputConfiguration::OutputFormat format;
            size_t fileSizeBytes;
            std::chrono::system_clock::time_point creationTime;
            std::map<std::string, std::string> metadata;
        };
        
        std::vector<GeneratedFile> generatedFiles;
        
        // è¾“å‡ºç»Ÿè®¡
        struct OutputStatistics {
            size_t totalDataPoints;                         // æ€»æ•°æ®ç‚¹æ•°
            size_t validDataPoints;                         // æœ‰æ•ˆæ•°æ®ç‚¹æ•°
            size_t interpolatedPoints;                      // æ’å€¼ç‚¹æ•°
            double dataCompleteness;                        // æ•°æ®å®Œæ•´æ€§(%)
            std::pair<double, double> valueRange;          // æ•°å€¼èŒƒå›´
            double processingTimeSeconds;                   // å¤„ç†æ—¶é—´
            size_t totalOutputSizeBytes;                    // æ€»è¾“å‡ºå¤§å°
        } statistics;
    };
    
    /**
     * @brief æ‰§è¡Œæ•°æ®è¾“å‡º - ç¬¬å››æ­¥ä¸»è¦åŠŸèƒ½
     */
    boost::future<OutputResult> generateOutput(
        const DataGridBuilder::GridBuildResult& gridResult,
        const OutputConfiguration& config) {
        
        return boost::async([this, gridResult, config]() -> OutputResult {
            OutputResult result;
            
            try {
                // ğŸ¯ æ­¥éª¤1ï¼šå‡†å¤‡è¾“å‡ºç¯å¢ƒ
                prepareOutputEnvironment(config, result);
                
                // ğŸ¯ æ­¥éª¤2ï¼šç”Ÿæˆæ–‡æœ¬æ ¼å¼è¾“å‡º
                if (needsTextOutput(config)) {
                    generateTextOutput(gridResult, config, result);
                }
                
                // ğŸ¯ æ­¥éª¤3ï¼šç”Ÿæˆå›¾åƒæ ¼å¼è¾“å‡º
                if (needsImageOutput(config)) {
                    generateImageOutput(gridResult, config, result);
                }
                
                // ğŸ¯ æ­¥éª¤4ï¼šç”Ÿæˆè¾“å‡ºç»Ÿè®¡å’Œå…ƒæ•°æ®
                generateOutputStatistics(gridResult, result);
                
                // ğŸ¯ æ­¥éª¤5ï¼šæ¸…ç†å’ŒéªŒè¯
                validateAndCleanupOutput(result);
                
                result.success = true;
                
            } catch (const std::exception& e) {
                result.success = false;
                result.errorMessage = e.what();
            }
            
            return result;
        });
    }

private:
    /**
     * @brief æ­¥éª¤1ï¼šå‡†å¤‡è¾“å‡ºç¯å¢ƒ
     */
    void prepareOutputEnvironment(
        const OutputConfiguration& config, 
        OutputResult& result) {
        
        // ğŸ¯ åˆ›å»ºè¾“å‡ºç›®å½•
        std::string outputDir = config.outputDirectory;
        if (config.createTimestampedFolder) {
            auto now = std::chrono::system_clock::now();
            auto time_t = std::chrono::system_clock::to_time_t(now);
            std::stringstream ss;
            ss << std::put_time(std::localtime(&time_t), "%Y%m%d_%H%M%S");
            outputDir = (std::filesystem::path(outputDir) / ss.str()).string();
        }
        
        std::filesystem::create_directories(outputDir);
        outputBaseDir_ = outputDir;
        
        // ğŸ¯ åˆå§‹åŒ–GDALï¼ˆå¦‚æœéœ€è¦å›¾åƒè¾“å‡ºï¼‰
        if (needsImageOutput(config)) {
            initializeGDAL();
        }
    }
    
    /**
     * @brief æ­¥éª¤2ï¼šç”Ÿæˆæ–‡æœ¬æ ¼å¼è¾“å‡º
     */
    void generateTextOutput(
        const DataGridBuilder::GridBuildResult& gridResult,
        const OutputConfiguration& config,
        OutputResult& result) {
        
        const auto& gridData = gridResult.gridData;
        const auto& textConfig = config.textConfig;
        
        // ğŸ¯ ç”ŸæˆCSVæ ¼å¼
        if (config.primaryFormat == OutputConfiguration::OutputFormat::TEXT_CSV ||
            std::find(config.additionalFormats.begin(), config.additionalFormats.end(),
                     OutputConfiguration::OutputFormat::TEXT_CSV) != config.additionalFormats.end()) {
            
            generateCSVOutput(gridData, gridResult, config, result);
        }
        
        // ğŸ¯ ç”ŸæˆJSONæ ¼å¼
        if (config.primaryFormat == OutputConfiguration::OutputFormat::TEXT_JSON ||
            std::find(config.additionalFormats.begin(), config.additionalFormats.end(),
                     OutputConfiguration::OutputFormat::TEXT_JSON) != config.additionalFormats.end()) {
            
            generateJSONOutput(gridData, gridResult, config, result);
        }
        
        // ğŸ¯ ç”ŸæˆASCIIç½‘æ ¼æ ¼å¼
        if (config.primaryFormat == OutputConfiguration::OutputFormat::TEXT_GRID_ASCII ||
            std::find(config.additionalFormats.begin(), config.additionalFormats.end(),
                     OutputConfiguration::OutputFormat::TEXT_GRID_ASCII) != config.additionalFormats.end()) {
            
            generateASCIIGridOutput(gridData, gridResult, config, result);
        }
    }
    
    /**
     * @brief ç”ŸæˆCSVæ ¼å¼è¾“å‡º
     */
    void generateCSVOutput(
        std::shared_ptr<oscean::core_services::GridData> gridData,
        const DataGridBuilder::GridBuildResult& gridResult,
        const OutputConfiguration& config,
        OutputResult& result) {
        
        std::string fileName = config.baseFileName + "_data.csv";
        std::string filePath = (std::filesystem::path(outputBaseDir_) / fileName).string();
        
        std::ofstream csvFile(filePath);
        if (!csvFile.is_open()) {
            throw std::runtime_error("æ— æ³•åˆ›å»ºCSVæ–‡ä»¶: " + filePath);
        }
        
        const auto& textConfig = config.textConfig;
        
        // ğŸ¯ å†™å…¥è¡¨å¤´
        if (textConfig.includeHeader) {
            std::vector<std::string> headers;
            
            if (textConfig.includeCoordinates) {
                headers.push_back("Longitude");
                headers.push_back("Latitude");
                if (gridData->hasDepthDimension) {
                    headers.push_back("Depth");
                }
            }
            
            headers.push_back("Row");
            headers.push_back("Column");
            headers.push_back("Value");
            
            if (textConfig.includeQualityInfo) {
                headers.push_back("Quality_Score");
                headers.push_back("Is_Interpolated");
                headers.push_back("Is_Original_Data");
            }
            
            // å†™å…¥è¡¨å¤´è¡Œ
            for (size_t i = 0; i < headers.size(); ++i) {
                if (i > 0) csvFile << textConfig.delimiter;
                csvFile << headers[i];
            }
            csvFile << "\n";
        }
        
        // ğŸ¯ å†™å…¥æ•°æ®è¡Œ
        for (size_t row = 0; row < gridData->height; ++row) {
            for (size_t col = 0; col < gridData->width; ++col) {
                size_t index = row * gridData->width + col;
                
                if (index >= gridData->values.size()) continue;
                
                double value = gridData->values[index];
                
                // è·³è¿‡æ— æ•ˆå€¼ï¼ˆå¯é€‰ï¼‰
                if (std::isnan(value) && textConfig.nullValueRepresentation.empty()) {
                    continue;
                }
                
                std::vector<std::string> rowData;
                
                // ğŸ¯ æ·»åŠ åæ ‡ä¿¡æ¯
                if (textConfig.includeCoordinates) {
                    double longitude = gridData->geoTransform[0] + (col + 0.5) * gridData->geoTransform[1];
                    double latitude = gridData->geoTransform[3] + (row + 0.5) * gridData->geoTransform[5];
                    
                    rowData.push_back(formatNumber(longitude, textConfig.precision));
                    rowData.push_back(formatNumber(latitude, textConfig.precision));
                    
                    if (gridData->hasDepthDimension && index < gridData->depthValues.size()) {
                        rowData.push_back(formatNumber(gridData->depthValues[index], textConfig.precision));
                    }
                }
                
                // ğŸ¯ æ·»åŠ ç½‘æ ¼ç´¢å¼•
                rowData.push_back(std::to_string(row));
                rowData.push_back(std::to_string(col));
                
                // ğŸ¯ æ·»åŠ æ•°å€¼
                if (std::isnan(value)) {
                    rowData.push_back(textConfig.nullValueRepresentation);
                } else {
                    rowData.push_back(formatNumber(value, textConfig.precision));
                }
                
                // ğŸ¯ æ·»åŠ è´¨é‡ä¿¡æ¯
                if (textConfig.includeQualityInfo && index < gridResult.dataQuality.pointQualityScores.size()) {
                    rowData.push_back(formatNumber(gridResult.dataQuality.pointQualityScores[index], 3));
                    rowData.push_back(gridResult.dataQuality.isInterpolated[index] ? "true" : "false");
                    rowData.push_back(gridResult.dataQuality.isOriginalData[index] ? "true" : "false");
                }
                
                // å†™å…¥è¡Œæ•°æ®
                for (size_t i = 0; i < rowData.size(); ++i) {
                    if (i > 0) csvFile << textConfig.delimiter;
                    csvFile << rowData[i];
                }
                csvFile << "\n";
            }
        }
        
        csvFile.close();
        
        // ğŸ¯ è®°å½•ç”Ÿæˆçš„æ–‡ä»¶
        OutputResult::GeneratedFile fileInfo;
        fileInfo.filePath = filePath;
        fileInfo.format = OutputConfiguration::OutputFormat::TEXT_CSV;
        fileInfo.fileSizeBytes = std::filesystem::file_size(filePath);
        fileInfo.creationTime = std::chrono::system_clock::now();
        fileInfo.metadata["rows"] = std::to_string(gridData->height);
        fileInfo.metadata["columns"] = std::to_string(gridData->width);
        fileInfo.metadata["delimiter"] = textConfig.delimiter;
        
        result.generatedFiles.push_back(fileInfo);
    }
    
    /**
     * @brief ç”ŸæˆJSONæ ¼å¼è¾“å‡º
     */
    void generateJSONOutput(
        std::shared_ptr<oscean::core_services::GridData> gridData,
        const DataGridBuilder::GridBuildResult& gridResult,
        const OutputConfiguration& config,
        OutputResult& result) {
        
        std::string fileName = config.baseFileName + "_data.json";
        std::string filePath = (std::filesystem::path(outputBaseDir_) / fileName).string();
        
        // ğŸ¯ æ„å»ºJSONç»“æ„
        nlohmann::json jsonOutput;
        
        // å…ƒæ•°æ®éƒ¨åˆ†
        jsonOutput["metadata"] = {
            {"grid_width", gridData->width},
            {"grid_height", gridData->height},
            {"coordinate_system", gridData->coordinateSystem},
            {"variable_name", gridData->variableName},
            {"bounds", {
                {"min_longitude", gridData->bounds.minLongitude},
                {"max_longitude", gridData->bounds.maxLongitude},
                {"min_latitude", gridData->bounds.minLatitude},
                {"max_latitude", gridData->bounds.maxLatitude}
            }},
            {"geo_transform", gridData->geoTransform},
            {"creation_time", std::chrono::duration_cast<std::chrono::seconds>(
                std::chrono::system_clock::now().time_since_epoch()).count()}
        };
        
        // ç½‘æ ¼ç»Ÿè®¡ä¿¡æ¯
        jsonOutput["statistics"] = {
            {"total_points", gridResult.gridMetadata.totalGridPoints},
            {"filled_points", gridResult.gridMetadata.filledPoints},
            {"interpolated_points", gridResult.gridMetadata.interpolatedPoints},
            {"fill_ratio", gridResult.gridMetadata.fillRatio},
            {"overall_quality", gridResult.dataQuality.overallQuality}
        };
        
        // ğŸ¯ æ•°æ®éƒ¨åˆ† - ä½¿ç”¨å‹ç¼©æ ¼å¼
        nlohmann::json dataArray = nlohmann::json::array();
        
        for (size_t row = 0; row < gridData->height; ++row) {
            nlohmann::json rowArray = nlohmann::json::array();
            for (size_t col = 0; col < gridData->width; ++col) {
                size_t index = row * gridData->width + col;
                
                if (index < gridData->values.size()) {
                    double value = gridData->values[index];
                    if (std::isnan(value)) {
                        rowArray.push_back(nullptr);
                    } else {
                        rowArray.push_back(std::round(value * std::pow(10, config.textConfig.precision)) / 
                                         std::pow(10, config.textConfig.precision));
                    }
                } else {
                    rowArray.push_back(nullptr);
                }
            }
            dataArray.push_back(rowArray);
        }
        
        jsonOutput["data"] = dataArray;
        
        // ğŸ¯ å†™å…¥æ–‡ä»¶
        std::ofstream jsonFile(filePath);
        if (!jsonFile.is_open()) {
            throw std::runtime_error("æ— æ³•åˆ›å»ºJSONæ–‡ä»¶: " + filePath);
        }
        
        jsonFile << jsonOutput.dump(2); // æ ¼å¼åŒ–è¾“å‡ºï¼Œç¼©è¿›2ä¸ªç©ºæ ¼
        jsonFile.close();
        
        // ğŸ¯ è®°å½•ç”Ÿæˆçš„æ–‡ä»¶
        OutputResult::GeneratedFile fileInfo;
        fileInfo.filePath = filePath;
        fileInfo.format = OutputConfiguration::OutputFormat::TEXT_JSON;
        fileInfo.fileSizeBytes = std::filesystem::file_size(filePath);
        fileInfo.creationTime = std::chrono::system_clock::now();
        fileInfo.metadata["format"] = "JSON";
        fileInfo.metadata["structure"] = "grid_array";
        
        result.generatedFiles.push_back(fileInfo);
    }
    
    /**
     * @brief æ­¥éª¤3ï¼šç”Ÿæˆå›¾åƒæ ¼å¼è¾“å‡ºï¼ˆä½¿ç”¨GDALï¼‰
     */
    void generateImageOutput(
        const DataGridBuilder::GridBuildResult& gridResult,
        const OutputConfiguration& config,
        OutputResult& result) {
        
        const auto& gridData = gridResult.gridData;
        const auto& imageConfig = config.imageConfig;
        
        // ğŸ¯ ç”ŸæˆGeoTIFFæ ¼å¼
        if (config.primaryFormat == OutputConfiguration::OutputFormat::IMAGE_GEOTIFF ||
            std::find(config.additionalFormats.begin(), config.additionalFormats.end(),
                     OutputConfiguration::OutputFormat::IMAGE_GEOTIFF) != config.additionalFormats.end()) {
            
            generateGeoTIFFOutput(gridData, gridResult, config, result);
        }
        
        // ğŸ¯ ç”ŸæˆPNGæ ¼å¼
        if (config.primaryFormat == OutputConfiguration::OutputFormat::IMAGE_PNG ||
            std::find(config.additionalFormats.begin(), config.additionalFormats.end(),
                     OutputConfiguration::OutputFormat::IMAGE_PNG) != config.additionalFormats.end()) {
            
            generatePNGOutput(gridData, gridResult, config, result);
        }
    }
    
    /**
     * @brief ä½¿ç”¨GDALç”ŸæˆGeoTIFFè¾“å‡º
     */
    void generateGeoTIFFOutput(
        std::shared_ptr<oscean::core_services::GridData> gridData,
        const DataGridBuilder::GridBuildResult& gridResult,
        const OutputConfiguration& config,
        OutputResult& result) {
        
        std::string fileName = config.baseFileName + "_data.tif";
        std::string filePath = (std::filesystem::path(outputBaseDir_) / fileName).string();
        
        // ğŸ¯ åˆ›å»ºGDALæ•°æ®é›†
        GDALDriver* geoTiffDriver = GetGDALDriverManager()->GetDriverByName("GTiff");
        if (!geoTiffDriver) {
            throw std::runtime_error("æ— æ³•è·å–GeoTIFFé©±åŠ¨ç¨‹åº");
        }
        
        // è®¾ç½®åˆ›å»ºé€‰é¡¹
        char** createOptions = nullptr;
        createOptions = CSLSetNameValue(createOptions, "COMPRESS", "LZW");
        createOptions = CSLSetNameValue(createOptions, "TILED", "YES");
        createOptions = CSLSetNameValue(createOptions, "BIGTIFF", "IF_SAFER");
        
        // åˆ›å»ºæ•°æ®é›†
        GDALDataset* dataset = geoTiffDriver->Create(
            filePath.c_str(),
            static_cast<int>(gridData->width),
            static_cast<int>(gridData->height),
            1,  // æ³¢æ®µæ•°
            GDT_Float64,  // æ•°æ®ç±»å‹
            createOptions
        );
        
        CSLDestroy(createOptions);
        
        if (!dataset) {
            throw std::runtime_error("æ— æ³•åˆ›å»ºGeoTIFFæ•°æ®é›†: " + filePath);
        }
        
        try {
            // ğŸ¯ è®¾ç½®åœ°ç†å˜æ¢å‚æ•°
            if (dataset->SetGeoTransform(const_cast<double*>(gridData->geoTransform.data())) != CE_None) {
                throw std::runtime_error("è®¾ç½®åœ°ç†å˜æ¢å‚æ•°å¤±è´¥");
            }
            
            // ğŸ¯ è®¾ç½®åæ ‡å‚è€ƒç³»ç»Ÿ
            OGRSpatialReference srs;
            if (!gridData->coordinateSystem.empty()) {
                if (srs.SetFromUserInput(gridData->coordinateSystem.c_str()) == OGRERR_NONE) {
                    char* wktString = nullptr;
                    srs.exportToWkt(&wktString);
                    dataset->SetProjection(wktString);
                    CPLFree(wktString);
                }
            }
            
            // ğŸ¯ å†™å…¥æ•°æ®
            GDALRasterBand* band = dataset->GetRasterBand(1);
            if (!band) {
                throw std::runtime_error("æ— æ³•è·å–æ …æ ¼æ³¢æ®µ");
            }
            
            // è®¾ç½®æ— æ•°æ®å€¼
            band->SetNoDataValue(std::numeric_limits<double>::quiet_NaN());
            
            // å†™å…¥æ …æ ¼æ•°æ®
            CPLErr writeResult = band->RasterIO(
                GF_Write,
                0, 0,  // èµ·å§‹ä½ç½®
                static_cast<int>(gridData->width),
                static_cast<int>(gridData->height),
                const_cast<double*>(gridData->values.data()),
                static_cast<int>(gridData->width),
                static_cast<int>(gridData->height),
                GDT_Float64,
                0, 0  // åƒç´ å’Œè¡Œé—´è·
            );
            
            if (writeResult != CE_None) {
                throw std::runtime_error("å†™å…¥æ …æ ¼æ•°æ®å¤±è´¥");
            }
            
            // ğŸ¯ è®¾ç½®å…ƒæ•°æ®
            dataset->SetMetadataItem("VARIABLE_NAME", gridData->variableName.c_str());
            dataset->SetMetadataItem("CREATION_TIME", 
                std::to_string(std::chrono::duration_cast<std::chrono::seconds>(
                    std::chrono::system_clock::now().time_since_epoch()).count()).c_str());
            dataset->SetMetadataItem("FILL_RATIO", 
                std::to_string(gridResult.gridMetadata.fillRatio).c_str());
            dataset->SetMetadataItem("OVERALL_QUALITY", 
                std::to_string(gridResult.dataQuality.overallQuality).c_str());
            
            // ğŸ¯ è®¡ç®—ç»Ÿè®¡ä¿¡æ¯
            band->ComputeStatistics(FALSE, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr);
            
        } catch (...) {
            GDALClose(dataset);
            throw;
        }
        
        GDALClose(dataset);
        
        // ğŸ¯ è®°å½•ç”Ÿæˆçš„æ–‡ä»¶
        OutputResult::GeneratedFile fileInfo;
        fileInfo.filePath = filePath;
        fileInfo.format = OutputConfiguration::OutputFormat::IMAGE_GEOTIFF;
        fileInfo.fileSizeBytes = std::filesystem::file_size(filePath);
        fileInfo.creationTime = std::chrono::system_clock::now();
        fileInfo.metadata["driver"] = "GTiff";
        fileInfo.metadata["compression"] = "LZW";
        fileInfo.metadata["coordinate_system"] = gridData->coordinateSystem;
        
        result.generatedFiles.push_back(fileInfo);
    }
    
    /**
     * @brief ä½¿ç”¨GDALç”ŸæˆPNGè¾“å‡ºï¼ˆå¸¦é¢œè‰²æ˜ å°„ï¼‰
     */
    void generatePNGOutput(
        std::shared_ptr<oscean::core_services::GridData> gridData,
        const DataGridBuilder::GridBuildResult& gridResult,
        const OutputConfiguration& config,
        OutputResult& result) {
        
        std::string fileName = config.baseFileName + "_visualization.png";
        std::string filePath = (std::filesystem::path(outputBaseDir_) / fileName).string();
        
        const auto& imageConfig = config.imageConfig;
        
        // ğŸ¯ è®¡ç®—æ•°æ®å€¼èŒƒå›´
        auto [minValue, maxValue] = calculateValueRange(gridData, imageConfig);
        
        // ğŸ¯ åˆ›å»ºRGBæ•°æ®
        std::vector<uint8_t> rgbData(gridData->width * gridData->height * 3);
        
        // åº”ç”¨é¢œè‰²æ˜ å°„
        applyColorMapping(gridData, rgbData, minValue, maxValue, imageConfig);
        
        // ğŸ¯ ä½¿ç”¨GDALåˆ›å»ºPNG
        GDALDriver* pngDriver = GetGDALDriverManager()->GetDriverByName("PNG");
        if (!pngDriver) {
            throw std::runtime_error("æ— æ³•è·å–PNGé©±åŠ¨ç¨‹åº");
        }
        
        GDALDataset* dataset = pngDriver->Create(
            filePath.c_str(),
            static_cast<int>(gridData->width),
            static_cast<int>(gridData->height),
            3,  // RGBä¸‰ä¸ªæ³¢æ®µ
            GDT_Byte,
            nullptr
        );
        
        if (!dataset) {
            throw std::runtime_error("æ— æ³•åˆ›å»ºPNGæ•°æ®é›†: " + filePath);
        }
        
        try {
            // ğŸ¯ å†™å…¥RGBæ•°æ®
            for (int band = 1; band <= 3; ++band) {
                GDALRasterBand* rasterBand = dataset->GetRasterBand(band);
                
                // æå–å¯¹åº”é¢œè‰²é€šé“çš„æ•°æ®
                std::vector<uint8_t> channelData(gridData->width * gridData->height);
                for (size_t i = 0; i < channelData.size(); ++i) {
                    channelData[i] = rgbData[i * 3 + (band - 1)];
                }
                
                CPLErr writeResult = rasterBand->RasterIO(
                    GF_Write,
                    0, 0,
                    static_cast<int>(gridData->width),
                    static_cast<int>(gridData->height),
                    channelData.data(),
                    static_cast<int>(gridData->width),
                    static_cast<int>(gridData->height),
                    GDT_Byte,
                    0, 0
                );
                
                if (writeResult != CE_None) {
                    throw std::runtime_error("å†™å…¥PNGæ•°æ®å¤±è´¥");
                }
            }
            
            // ğŸ¯ ç”Ÿæˆä¸–ç•Œæ–‡ä»¶ï¼ˆå¦‚æœéœ€è¦ï¼‰
            if (imageConfig.generateWorldFile) {
                generateWorldFile(filePath, gridData);
            }
            
        } catch (...) {
            GDALClose(dataset);
            throw;
        }
        
        GDALClose(dataset);
        
        // ğŸ¯ è®°å½•ç”Ÿæˆçš„æ–‡ä»¶
        OutputResult::GeneratedFile fileInfo;
        fileInfo.filePath = filePath;
        fileInfo.format = OutputConfiguration::OutputFormat::IMAGE_PNG;
        fileInfo.fileSizeBytes = std::filesystem::file_size(filePath);
        fileInfo.creationTime = std::chrono::system_clock::now();
        fileInfo.metadata["color_map"] = getColorMapName(imageConfig.colorMap);
        fileInfo.metadata["value_range"] = std::to_string(minValue) + " to " + std::to_string(maxValue);
        
        result.generatedFiles.push_back(fileInfo);
    }
    
    /**
     * @brief åº”ç”¨é¢œè‰²æ˜ å°„
     */
    void applyColorMapping(
        std::shared_ptr<oscean::core_services::GridData> gridData,
        std::vector<uint8_t>& rgbData,
        double minValue, double maxValue,
        const OutputConfiguration::ImageOutputConfig& imageConfig) {
        
        // ğŸ¯ è·å–é¢œè‰²æ˜ å°„è¡¨
        auto colorTable = getColorTable(imageConfig.colorMap);
        
        for (size_t i = 0; i < gridData->values.size(); ++i) {
            double value = gridData->values[i];
            
            uint8_t r = 0, g = 0, b = 0;
            
            if (!std::isnan(value)) {
                // ğŸ¯ å½’ä¸€åŒ–å€¼åˆ°[0,1]èŒƒå›´
                double normalizedValue = (value - minValue) / (maxValue - minValue);
                normalizedValue = std::clamp(normalizedValue, 0.0, 1.0);
                
                // ğŸ¯ ä»é¢œè‰²è¡¨ä¸­æ’å€¼è·å–RGBå€¼
                auto rgb = interpolateColor(colorTable, normalizedValue);
                r = rgb.r;
                g = rgb.g;
                b = rgb.b;
            }
            // NaNå€¼ä¿æŒé»‘è‰²(0,0,0)
            
            rgbData[i * 3] = r;
            rgbData[i * 3 + 1] = g;
            rgbData[i * 3 + 2] = b;
        }
    }
    
    /**
     * @brief åˆå§‹åŒ–GDAL
     */
    void initializeGDAL() {
        static std::once_flag gdalInitFlag;
        std::call_once(gdalInitFlag, []() {
            GDALAllRegister();
            CPLSetConfigOption("GDAL_PAM_ENABLED", "NO");  // ç¦ç”¨è¾…åŠ©æ–‡ä»¶
        });
    }
    
    // è¾…åŠ©å‡½æ•°
    std::string formatNumber(double value, int precision);
    std::pair<double, double> calculateValueRange(
        std::shared_ptr<oscean::core_services::GridData> gridData,
        const OutputConfiguration::ImageOutputConfig& imageConfig);
    std::vector<ColorRGB> getColorTable(OutputConfiguration::ImageOutputConfig::ColorMap colorMap);
    ColorRGB interpolateColor(const std::vector<ColorRGB>& colorTable, double normalizedValue);
    void generateWorldFile(const std::string& imagePath, std::shared_ptr<oscean::core_services::GridData> gridData);
    std::string getColorMapName(OutputConfiguration::ImageOutputConfig::ColorMap colorMap);
    
private:
    std::string outputBaseDir_;
    
    struct ColorRGB {
        uint8_t r, g, b;
    };
};
```

### 7.2 GDALå›¾åƒç”Ÿæˆçš„ä¼˜åŠ¿

ä½¿ç”¨GDALè¿›è¡Œå›¾åƒç”Ÿæˆå…·æœ‰ä»¥ä¸‹ä¼˜åŠ¿ï¼š

#### ğŸ¯ **æ ¼å¼æ”¯æŒå¹¿æ³›**
- **GeoTIFF**ï¼šä¿ç•™å®Œæ•´åœ°ç†å‚è€ƒä¿¡æ¯ï¼Œæ”¯æŒå‹ç¼©
- **PNG**ï¼šé«˜è´¨é‡å¯è§†åŒ–ï¼Œæ”¯æŒé€æ˜åº¦
- **JPEG**ï¼šå‹ç¼©æ¯”é«˜ï¼Œé€‚åˆå¤§å›¾åƒ
- **å…¶ä»–æ ¼å¼**ï¼šBMPã€GIFã€WebPç­‰

#### ğŸ—ºï¸ **åœ°ç†å‚è€ƒå®Œæ•´**
- **åæ ‡ç³»ç»Ÿ**ï¼šå®Œæ•´çš„CRSä¿¡æ¯åµŒå…¥
- **åœ°ç†å˜æ¢**ï¼šç²¾ç¡®çš„åƒç´ -åœ°ç†åæ ‡è½¬æ¢
- **ä¸–ç•Œæ–‡ä»¶**ï¼šç”Ÿæˆ.tfwã€.pgwç­‰ä¸–ç•Œæ–‡ä»¶
- **å…ƒæ•°æ®**ï¼šä¸°å¯Œçš„åœ°ç†å’Œå¤„ç†å…ƒæ•°æ®

#### ğŸ¨ **å¯è§†åŒ–åŠŸèƒ½å¼ºå¤§**
- **é¢œè‰²æ˜ å°„**ï¼šå¤šç§ç§‘å­¦å¯è§†åŒ–é¢œè‰²è¡¨
- **æ•°æ®èŒƒå›´**ï¼šè‡ªåŠ¨æˆ–æ‰‹åŠ¨è®¾ç½®æ˜¾ç¤ºèŒƒå›´
- **ç™¾åˆ†ä½è£å‰ª**ï¼šå»é™¤å¼‚å¸¸å€¼å½±å“
- **å›¾ä¾‹ç”Ÿæˆ**ï¼šè‡ªåŠ¨ç”Ÿæˆé¢œè‰²æ¡å’Œæ ‡æ³¨

#### âš¡ **æ€§èƒ½ä¼˜åŒ–**
- **å‹ç¼©æ”¯æŒ**ï¼šLZWã€DEFLATEç­‰æ— æŸå‹ç¼©
- **åˆ†å—å¤„ç†**ï¼šå¤§æ•°æ®é›†çš„åˆ†å—è¯»å†™
- **å†…å­˜ä¼˜åŒ–**ï¼šæµå¼å¤„ç†å‡å°‘å†…å­˜å ç”¨
- **å¹¶è¡Œå¤„ç†**ï¼šå¤šçº¿ç¨‹åŠ é€Ÿå›¾åƒç”Ÿæˆ

### 7.3 è¾“å‡ºéªŒè¯å’Œè´¨é‡æ§åˆ¶

```cpp
/**
 * @brief è¾“å‡ºéªŒè¯å™¨
 */
class OutputValidator {
public:
    struct ValidationResult {
        bool isValid = false;
        std::vector<std::string> warnings;
        std::vector<std::string> errors;
        
        struct FileValidation {
            std::string filePath;
            bool exists = false;
            bool readable = false;
            bool hasCorrectFormat = false;
            bool hasValidGeoreference = false;
            size_t actualFileSize = 0;
            size_t expectedDataPoints = 0;
            size_t actualDataPoints = 0;
        };
        
        std::vector<FileValidation> fileValidations;
    };
    
    /**
     * @brief éªŒè¯è¾“å‡ºç»“æœ
     */
    ValidationResult validateOutput(const OutputResult& outputResult) {
        ValidationResult validation;
        
        for (const auto& file : outputResult.generatedFiles) {
            FileValidation fileVal;
            fileVal.filePath = file.filePath;
            
            // ğŸ¯ åŸºç¡€æ–‡ä»¶æ£€æŸ¥
            fileVal.exists = std::filesystem::exists(file.filePath);
            if (fileVal.exists) {
                fileVal.actualFileSize = std::filesystem::file_size(file.filePath);
                fileVal.readable = checkFileReadable(file.filePath);
            }
            
            // ğŸ¯ æ ¼å¼ç‰¹å®šéªŒè¯
            switch (file.format) {
                case OutputConfiguration::OutputFormat::TEXT_CSV:
                    validateCSVFile(fileVal);
                    break;
                case OutputConfiguration::OutputFormat::TEXT_JSON:
                    validateJSONFile(fileVal);
                    break;
                case OutputConfiguration::OutputFormat::IMAGE_GEOTIFF:
                    validateGeoTIFFFile(fileVal);
                    break;
                case OutputConfiguration::OutputFormat::IMAGE_PNG:
                    validatePNGFile(fileVal);
                    break;
            }
            
            validation.fileValidations.push_back(fileVal);
        }
        
        // ğŸ¯ æ•´ä½“éªŒè¯ç»“æœ
        validation.isValid = std::all_of(validation.fileValidations.begin(),
                                       validation.fileValidations.end(),
                                       [](const FileValidation& fv) {
                                           return fv.exists && fv.readable && fv.hasCorrectFormat;
                                       });
        
        return validation;
    }
    
private:
    bool checkFileReadable(const std::string& filePath);
    void validateCSVFile(FileValidation& validation);
    void validateJSONFile(FileValidation& validation);
    void validateGeoTIFFFile(FileValidation& validation);
    void validatePNGFile(FileValidation& validation);
};
```

### 7.4 ç¬¬å››æ­¥æ€»ç»“

ç¬¬å››æ­¥æ•°æ®è¾“å‡ºé˜¶æ®µçš„æ ¸å¿ƒç‰¹ç‚¹ï¼š

#### ğŸ¯ **ä¸»è¦åŠŸèƒ½**
1. **æ–‡æœ¬è¾“å‡º**ï¼šCSVã€JSONã€ASCIIç½‘æ ¼æ ¼å¼ï¼Œç”¨äºæ•°æ®éªŒè¯å’Œåˆ†æ
2. **å›¾åƒè¾“å‡º**ï¼šä½¿ç”¨GDALç”ŸæˆGeoTIFFã€PNGç­‰æ ¼å¼ï¼Œæ”¯æŒå®Œæ•´åœ°ç†å‚è€ƒ
3. **è´¨é‡æ§åˆ¶**ï¼šè¾“å‡ºéªŒè¯ã€æ ¼å¼æ£€æŸ¥ã€æ•°æ®å®Œæ•´æ€§éªŒè¯
4. **å…ƒæ•°æ®ç®¡ç†**ï¼šå®Œæ•´çš„å¤„ç†å†å²å’Œç»Ÿè®¡ä¿¡æ¯

#### ğŸ”§ **æŠ€æœ¯ä¼˜åŠ¿**
1. **GDALé›†æˆ**ï¼šåˆ©ç”¨GDALå¼ºå¤§çš„åœ°ç†æ•°æ®å¤„ç†èƒ½åŠ›
2. **æ ¼å¼ä¸°å¯Œ**ï¼šæ”¯æŒå¤šç§æ–‡æœ¬å’Œå›¾åƒæ ¼å¼
3. **åœ°ç†å‚è€ƒ**ï¼šå®Œæ•´ä¿ç•™åæ ‡ç³»ç»Ÿå’Œåœ°ç†å˜æ¢ä¿¡æ¯
4. **å¯è§†åŒ–**ï¼šç§‘å­¦çº§é¢œè‰²æ˜ å°„å’Œå›¾åƒæ¸²æŸ“

#### âš¡ **æ€§èƒ½ç‰¹ç‚¹**
1. **å¹¶è¡Œå¤„ç†**ï¼šå¤šæ ¼å¼å¹¶è¡Œç”Ÿæˆ
2. **å†…å­˜ä¼˜åŒ–**ï¼šå¤§æ•°æ®é›†çš„æµå¼å¤„ç†
3. **å‹ç¼©æ”¯æŒ**ï¼šå‡å°‘è¾“å‡ºæ–‡ä»¶å¤§å°
4. **éªŒè¯æœºåˆ¶**ï¼šç¡®ä¿è¾“å‡ºè´¨é‡å’Œå®Œæ•´æ€§

è¿™æ ·è®¾è®¡ç¡®ä¿äº†ç¬¬å››æ­¥èƒ½å¤Ÿç”Ÿæˆé«˜è´¨é‡ã€å¤šæ ¼å¼çš„æ•°æ®è¾“å‡ºï¼Œæ—¢æ»¡è¶³éªŒè¯éœ€æ±‚ï¼Œåˆæ”¯æŒä¸“ä¸šçš„åœ°ç†æ•°æ®åˆ†æå’Œå¯è§†åŒ–åº”ç”¨ã€‚ 