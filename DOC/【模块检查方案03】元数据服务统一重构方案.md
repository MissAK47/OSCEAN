# ã€æ¨¡å—æ£€æŸ¥æ–¹æ¡ˆ03ã€‘å…ƒæ•°æ®æœåŠ¡ç»Ÿä¸€é‡æ„æ–¹æ¡ˆ - å®Œæ•´é‡æ„æŒ‡å¯¼

## ğŸ“‹ 1. å…³é”®å†²çªä¿®æ­£ä¸æ¶æ„ç»Ÿä¸€

### 1.1 Critical Issues Summary (åŸºäºè·¨æ¨¡å—å†²çªåˆ†æ)
ç»è¿‡ä¸Commoné€šç”¨åº“åŠå…¶ä»–4ä¸ªæ¨¡å—é‡æ„æ–¹æ¡ˆçš„å…¨é¢å†²çªåˆ†æï¼Œå…ƒæ•°æ®æœåŠ¡å­˜åœ¨ä»¥ä¸‹**é‡å¤§æ¶æ„é—®é¢˜**ï¼š

#### ğŸ”´ **Açº§é—®é¢˜ï¼šæ—¶é—´æ¶æ„èŒè´£é”™ä½**
- **é—®é¢˜**: å…ƒæ•°æ®æœåŠ¡åº”è¯¥è´Ÿè´£æ—¶é—´å…ƒæ•°æ®çš„**ç®¡ç†ã€ç´¢å¼•ã€ç¼“å­˜**ï¼Œä½†å½“å‰ç¼ºå°‘å®Œæ•´å®ç°
- **èŒè´£é”™ä½**: æŒ‰ç…§ä¸‰å±‚æ—¶é—´æ¶æ„ï¼Œå…ƒæ•°æ®å±‚æ˜¯ç¬¬ä¸‰å±‚ï¼Œè´Ÿè´£æ—¶é—´æ•°æ®çš„é«˜çº§ç®¡ç†
- **ä¿®æ­£**: å®ç°`TimeMetadataManager`ã€`TimeIndexManager`ã€`TimeCacheManager`

#### ğŸ”´ **Bçº§é—®é¢˜ï¼šåŠŸèƒ½é‡å¤ä¸¥é‡**
- **ç¼“å­˜é‡å¤**: å…ƒæ•°æ®æœåŠ¡å¯èƒ½å®ç°ç‹¬ç«‹ç¼“å­˜ï¼Œè¿åCommonç»Ÿä¸€ç¼“å­˜åŸåˆ™
- **å­˜å‚¨é‡å¤**: å¯èƒ½å­˜åœ¨ç‹¬ç«‹å­˜å‚¨å®ç°ï¼Œåº”ç»Ÿä¸€ä½¿ç”¨Commonå­˜å‚¨æ¡†æ¶
- **æ€§èƒ½ç›‘æ§é‡å¤**: éœ€ç»Ÿä¸€ä½¿ç”¨`UnifiedPerformanceMonitor`
- **ä¿®æ­£**: å¼ºåˆ¶åˆ é™¤é‡å¤å®ç°ï¼ŒåŸºäºCommonæ¡†æ¶æ„å»ºå…ƒæ•°æ®ç®¡ç†

#### ğŸ”´ **Cçº§é—®é¢˜ï¼šå¼‚æ­¥æ¨¡å¼ä¸ç»Ÿä¸€**
- **é—®é¢˜**: å…ƒæ•°æ®æœåŠ¡å¼‚æ­¥æ¥å£éœ€è¦å¼ºåˆ¶ä½¿ç”¨`OSCEAN_FUTURE(T)`
- **å½±å“**: ä¸å…¶ä»–æœåŠ¡çš„å¼‚æ­¥åä½œä¸ä¸€è‡´
- **ä¿®æ­£**: å¼ºåˆ¶ä½¿ç”¨Commonå±‚çš„ç»Ÿä¸€å¼‚æ­¥æ¡†æ¶

#### ğŸŸ¡ **Dçº§é—®é¢˜ï¼šå¤§è§„æ¨¡å…ƒæ•°æ®å¤„ç†èƒ½åŠ›ä¸è¶³**
- **ç¼ºå¤±**: ç¼ºä¹æµå¼å…ƒæ•°æ®å¤„ç†èƒ½åŠ›ï¼Œæ— æ³•é«˜æ•ˆå¤„ç†å¤§é‡æ–‡ä»¶çš„å…ƒæ•°æ®
- **æ€§èƒ½**: å…ƒæ•°æ®ç´¢å¼•å’Œæ£€ç´¢æ€§èƒ½éœ€è¦ä¼˜åŒ–
- **ä¿®æ­£**: åŸºäºCommonæµå¼æ¡†æ¶å®ç°å¤§è§„æ¨¡å…ƒæ•°æ®å¤„ç†

### 1.2 é‡æ„åçš„å…ƒæ•°æ®æœåŠ¡æ¶æ„
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              é‡æ„åçš„å…ƒæ•°æ®æœåŠ¡æ¶æ„ (ä¿®æ­£ç‰ˆ)                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ğŸ“± å…ƒæ•°æ®æœåŠ¡æ¥å£å±‚ (å…¨éƒ¨ä½¿ç”¨OSCEAN_FUTURE)                 â”‚
â”‚  â”œâ”€â”€ IMetadataService         (ç»Ÿä¸€å¼‚æ­¥æ¥å£)                 â”‚
â”‚  â”œâ”€â”€ ITimeMetadataManager     (ğŸ†• æ—¶é—´å…ƒæ•°æ®ç®¡ç†)            â”‚
â”‚  â”œâ”€â”€ ISpatialMetadataManager  (ğŸ†• ç©ºé—´å…ƒæ•°æ®ç®¡ç†)            â”‚
â”‚  â””â”€â”€ IStreamingMetadataProcessor (ğŸ†• æµå¼å…ƒæ•°æ®å¤„ç†)         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ğŸ”§ æ ¸å¿ƒå®ç°å±‚ (ä¸¥æ ¼ä¾èµ–Common)                              â”‚
â”‚  â”œâ”€â”€ MetadataServiceImpl      (ç§»é™¤é‡å¤åŸºç¡€è®¾æ–½)             â”‚
â”‚  â”œâ”€â”€ TimeMetadataManager      (ğŸ†• æ—¶é—´å…ƒæ•°æ®ç®¡ç†ä¸ç´¢å¼•)      â”‚
â”‚  â”œâ”€â”€ SpatialMetadataManager   (ğŸ†• ç©ºé—´å…ƒæ•°æ®ç®¡ç†ä¸ç´¢å¼•)      â”‚
â”‚  â”œâ”€â”€ MetadataIndexManager     (ğŸ†• ç»Ÿä¸€å…ƒæ•°æ®ç´¢å¼•)            â”‚
â”‚  â””â”€â”€ StreamingMetadataProcessor (ğŸ†• å¤§è§„æ¨¡å…ƒæ•°æ®å¤„ç†)        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ğŸ—ƒï¸ å­˜å‚¨ä¸ç¼“å­˜å±‚ (åŸºäºCommon)                                â”‚
â”‚  â”œâ”€â”€ MetadataStorageImpl      (ä½¿ç”¨Commonç»Ÿä¸€å­˜å‚¨)           â”‚
â”‚  â”œâ”€â”€ TimeMetadataCache        (åŸºäºCommonç¼“å­˜æ¡†æ¶)           â”‚
â”‚  â”œâ”€â”€ SpatialMetadataCache     (åŸºäºCommonç¼“å­˜æ¡†æ¶)           â”‚
â”‚  â””â”€â”€ MetadataIndexCache       (åŸºäºCommonç¼“å­˜æ¡†æ¶)           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â¬‡ï¸  ä¸¥æ ¼ä¾èµ– Commoné€šç”¨åº“ (ç»ä¸é‡å¤å®ç°)                     â”‚
â”‚  â”œâ”€â”€ OSCEAN_FUTURE()          (å¼ºåˆ¶å¼‚æ­¥ç±»å‹)                â”‚
â”‚  â”œâ”€â”€ UnifiedPerformanceMonitor (å¼ºåˆ¶æ€§èƒ½ç›‘æ§)               â”‚
â”‚  â”œâ”€â”€ UnifiedThreadPoolManager  (å¼ºåˆ¶çº¿ç¨‹æ± ç®¡ç†)             â”‚
â”‚  â”œâ”€â”€ UnifiedCacheManager       (å¼ºåˆ¶ç¼“å­˜ç®¡ç†)               â”‚
â”‚  â”œâ”€â”€ UnifiedStreamingFramework (å¼ºåˆ¶æµå¼å¤„ç†)               â”‚
â”‚  â””â”€â”€ TimeExtractorFactory      (ä½¿ç”¨æ—¶é—´æå–å™¨)             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ¯ 2. æ ¸å¿ƒä¿®æ­£å®æ–½æ–¹æ¡ˆ

### 2.1 **ä¿®æ­£Aï¼šå®ç°æ—¶é—´å…ƒæ•°æ®ç®¡ç†ä½“ç³»**

#### **æ—¶é—´å…ƒæ•°æ®ç®¡ç†å™¨å®ç°**
```cpp
// æ–‡ä»¶: include/core_services/metadata/time/time_metadata_manager.h
#pragma once
#include "common_utils/time/time_types.h"
#include "common_utils/async/unified_async_framework.h"
#include "common_utils/infrastructure/unified_cache_manager.h"

namespace oscean::core_services::metadata::time {

using namespace oscean::common_utils::time;
using namespace oscean::common_utils::async;
using namespace oscean::common_utils::infrastructure;

/**
 * @brief æ—¶é—´å…ƒæ•°æ®ç®¡ç†å™¨ - ä¸‰å±‚æ—¶é—´æ¶æ„ç¬¬ä¸‰å±‚
 * è´Ÿè´£æ—¶é—´å…ƒæ•°æ®çš„ç®¡ç†ã€ç´¢å¼•ã€ç¼“å­˜å’ŒæŸ¥è¯¢
 */
class TimeMetadataManager {
public:
    TimeMetadataManager();
    
    /**
     * @brief æ—¶é—´å…ƒæ•°æ®æ¡ç›®
     */
    struct TimeMetadataEntry {
        std::string fileId;                    // æ–‡ä»¶æ ‡è¯†
        std::string filePath;                  // æ–‡ä»¶è·¯å¾„
        std::string formatType;                // æ ¼å¼ç±»å‹
        TimeRange timeRange;                   // æ—¶é—´èŒƒå›´
        TimeResolutionInfo resolutionInfo;     // æ—¶é—´åˆ†è¾¨ç‡ä¿¡æ¯
        std::vector<CalendarTime> timePoints;  // å…³é”®æ—¶é—´ç‚¹
        std::map<std::string, std::string> metadata; // é¢å¤–å…ƒæ•°æ®
        std::chrono::system_clock::time_point lastUpdated; // æœ€åæ›´æ–°æ—¶é—´
        
        // è´¨é‡æŒ‡æ ‡
        double timeQualityScore;               // æ—¶é—´è´¨é‡è¯„åˆ† (0-1)
        bool hasRegularTimeSteps;              // æ˜¯å¦æœ‰è§„å¾‹æ—¶é—´æ­¥é•¿
        std::vector<std::string> timeGaps;     // æ—¶é—´é—´éš™æè¿°
    };
    
    // ğŸ†• æ—¶é—´å…ƒæ•°æ®æ³¨å†Œä¸æ›´æ–°
    OSCEAN_FUTURE(void) registerFileTimeMetadataAsync(
        const std::string& fileId,
        const std::string& filePath,
        const std::string& formatType
    );
    
    OSCEAN_FUTURE(void) updateTimeMetadataAsync(
        const std::string& fileId,
        const TimeMetadataEntry& metadata
    );
    
    OSCEAN_FUTURE(void) batchRegisterFilesAsync(
        const std::vector<std::tuple<std::string, std::string, std::string>>& files
    );
    
    // ğŸ†• æ—¶é—´èŒƒå›´æŸ¥è¯¢
    OSCEAN_FUTURE(std::vector<std::string>) findFilesInTimeRangeAsync(
        const TimeRange& queryRange
    );
    
    OSCEAN_FUTURE(std::vector<std::string>) findFilesWithTimeResolutionAsync(
        std::chrono::seconds minResolution,
        std::chrono::seconds maxResolution
    );
    
    OSCEAN_FUTURE(std::vector<std::string>) findFilesWithHighQualityTimeAsync(
        double minQualityScore = 0.8
    );
    
    // ğŸ†• æ—¶é—´å…ƒæ•°æ®æ£€ç´¢
    OSCEAN_FUTURE(std::optional<TimeMetadataEntry>) getTimeMetadataAsync(
        const std::string& fileId
    );
    
    OSCEAN_FUTURE(std::vector<TimeMetadataEntry>) getTimeMetadataBatchAsync(
        const std::vector<std::string>& fileIds
    );
    
    // ğŸ†• æ—¶é—´ç»Ÿè®¡ä¸åˆ†æ
    OSCEAN_FUTURE(TimeRange> calculateOverallTimeRangeAsync();
    
    OSCEAN_FUTURE(std::map<std::string, size_t>> getTimeResolutionDistributionAsync();
    
    OSCEAN_FUTURE(std::vector<std::string>> findTimeDataGapsAsync(
        const TimeRange& queryRange
    );

private:
    // ä½¿ç”¨Commonç»Ÿä¸€åŸºç¡€è®¾æ–½
    UnifiedCacheManager& cacheManager_;
    UnifiedThreadPoolManager& threadPoolManager_;
    UnifiedPerformanceMonitor& perfMonitor_;
    
    // æ—¶é—´å…ƒæ•°æ®å­˜å‚¨
    std::unique_ptr<class TimeMetadataStorage> storage_;
    
    // æ—¶é—´ç´¢å¼•ç®¡ç†
    std::unique_ptr<class TimeIndexManager> indexManager_;
};

/**
 * @brief æ—¶é—´ç´¢å¼•ç®¡ç†å™¨
 */
class TimeIndexManager {
public:
    TimeIndexManager();
    
    // æ—¶é—´èŒƒå›´ç´¢å¼•
    struct TimeRangeIndex {
        std::map<CalendarTime, std::set<std::string>> startTimeIndex;  // æŒ‰å¼€å§‹æ—¶é—´ç´¢å¼•
        std::map<CalendarTime, std::set<std::string>> endTimeIndex;    // æŒ‰ç»“æŸæ—¶é—´ç´¢å¼•
        std::multimap<std::chrono::seconds, std::string> resolutionIndex; // æŒ‰åˆ†è¾¨ç‡ç´¢å¼•
    };
    
    // ğŸ†• ç´¢å¼•æ„å»ºä¸ç»´æŠ¤
    OSCEAN_FUTURE(void) buildTimeIndexAsync(
        const std::vector<TimeMetadataManager::TimeMetadataEntry>& entries
    );
    
    OSCEAN_FUTURE(void) updateTimeIndexAsync(
        const std::string& fileId,
        const TimeMetadataManager::TimeMetadataEntry& entry
    );
    
    OSCEAN_FUTURE(void) removeFromTimeIndexAsync(const std::string& fileId);
    
    // ğŸ†• é«˜æ•ˆæ—¶é—´æŸ¥è¯¢
    OSCEAN_FUTURE(std::vector<std::string>> queryByTimeRangeAsync(
        const TimeRange& queryRange
    );
    
    OSCEAN_FUTURE(std::vector<std::string>> queryByTimeResolutionAsync(
        std::chrono::seconds minResolution,
        std::chrono::seconds maxResolution
    );
    
    // ğŸ†• ç´¢å¼•ç»Ÿè®¡
    size_t getIndexedFileCount() const;
    TimeRange getIndexedTimeRange() const;
    std::vector<std::chrono::seconds> getAvailableResolutions() const;

private:
    TimeRangeIndex timeRangeIndex_;
    mutable std::shared_mutex indexMutex_;
    
    // ä½¿ç”¨Commonæ€§èƒ½ç›‘æ§
    UnifiedPerformanceMonitor& perfMonitor_;
};

} // namespace oscean::core_services::metadata::time
```

### 2.2 **ä¿®æ­£Bï¼šæ¶ˆé™¤åŠŸèƒ½é‡å¤å®ç°**

#### **ç»Ÿä¸€å…ƒæ•°æ®æœåŠ¡å®ç°**
```cpp
// æ–‡ä»¶: include/core_services/metadata/unified_metadata_service.h
#pragma once
#include "common_utils/async/unified_async_framework.h"
#include "common_utils/infrastructure/unified_cache_manager.h"
#include "common_utils/infrastructure/unified_performance_monitor.h"

namespace oscean::core_services::metadata {

using namespace oscean::common_utils::async;
using namespace oscean::common_utils::infrastructure;

/**
 * @brief ç»Ÿä¸€å…ƒæ•°æ®æœåŠ¡å®ç° - ç§»é™¤æ‰€æœ‰é‡å¤åŸºç¡€è®¾æ–½
 */
class UnifiedMetadataServiceImpl : public IMetadataService {
public:
    // ğŸ”„ ä¿®æ­£åçš„æ„é€ å‡½æ•° - ä»…æ¥å—ä¸šåŠ¡ä¾èµ–
    explicit UnifiedMetadataServiceImpl(
        std::shared_ptr<IDataAccessService> dataAccessService
        // âŒ ç§»é™¤: storage å‚æ•° (ä½¿ç”¨Commonç»Ÿä¸€å­˜å‚¨)
        // âŒ ç§»é™¤: cache å‚æ•° (ä½¿ç”¨Commonç»Ÿä¸€ç¼“å­˜)
        // âŒ ç§»é™¤: threadPool å‚æ•° (ä½¿ç”¨Commonç»Ÿä¸€çº¿ç¨‹æ± )
    );
    
    // ğŸ†• æ—¶é—´å…ƒæ•°æ®ç®¡ç†æ¥å£
    OSCEAN_FUTURE(void) registerDatasetAsync(
        const std::string& datasetId,
        const std::string& filePath,
        const DatasetMetadata& metadata
    ) override;
    
    OSCEAN_FUTURE(std::optional<DatasetMetadata>> getDatasetMetadataAsync(
        const std::string& datasetId
    ) override;
    
    OSCEAN_FUTURE(std::vector<std::string>> findDatasetsInRegionAsync(
        const BoundingBox& region
    ) override;
    
    OSCEAN_FUTURE(std::vector<std::string>> findDatasetsInTimeRangeAsync(
        const TimeRange& timeRange
    ) override;
    
    // ğŸ†• æµå¼å…ƒæ•°æ®å¤„ç†
    OSCEAN_FUTURE(void) processLargeDatasetCollectionAsync(
        const std::vector<std::string>& datasetPaths,
        std::function<void(const DatasetMetadata&)> processor
    );

private:
    // ä¸šåŠ¡ä¾èµ–
    std::shared_ptr<IDataAccessService> dataAccessService_;
    
    // âœ… ä½¿ç”¨Commonç»Ÿä¸€åŸºç¡€è®¾æ–½
    UnifiedCacheManager& cacheManager_;
    UnifiedThreadPoolManager& threadPoolManager_;
    UnifiedPerformanceMonitor& perfMonitor_;
    
    // ğŸ†• ä¸“ç”¨ç®¡ç†å™¨
    std::unique_ptr<time::TimeMetadataManager> timeMetadataManager_;
    std::unique_ptr<spatial::SpatialMetadataManager> spatialMetadataManager_;
    std::unique_ptr<streaming::StreamingMetadataProcessor> streamingProcessor_;
    
    // âŒ åˆ é™¤çš„é‡å¤å®ç°
    // std::shared_ptr<metadata::storage::IMetadataStorage> storage_;
    // std::shared_ptr<metadata::cache::MetadataCache> cache_;
    // std::shared_ptr<boost::asio::thread_pool> threadPool_;
};

} // namespace oscean::core_services::metadata
```

### 2.3 **ä¿®æ­£Cï¼šå®ç°æµå¼å…ƒæ•°æ®å¤„ç†**

#### **å¤§è§„æ¨¡å…ƒæ•°æ®å¤„ç†æ¡†æ¶**
```cpp
// æ–‡ä»¶: include/core_services/metadata/streaming/streaming_metadata_processor.h
#pragma once
#include "common_utils/streaming/unified_streaming_framework.h"
#include "common_utils/async/unified_async_framework.h"

namespace oscean::core_services::metadata::streaming {

using namespace oscean::common_utils::streaming;
using namespace oscean::common_utils::async;

/**
 * @brief æµå¼å…ƒæ•°æ®å¤„ç†å™¨ - åŸºäºCommonæµå¼æ¡†æ¶
 */
class StreamingMetadataProcessor {
public:
    explicit StreamingMetadataProcessor(
        std::shared_ptr<IDataAccessService> dataAccessService
    );
    
    /**
     * @brief å¤§è§„æ¨¡æ–‡ä»¶å…ƒæ•°æ®æå–é…ç½®
     */
    struct MetadataExtractionConfig {
        size_t batchSize = 100;              // æ‰¹å¤„ç†å¤§å°
        size_t maxConcurrency = 4;           // æœ€å¤§å¹¶å‘æ•°
        bool enableTimeExtraction = true;     // å¯ç”¨æ—¶é—´æå–
        bool enableSpatialExtraction = true;  // å¯ç”¨ç©ºé—´æå–
        bool enableQualityAnalysis = true;    // å¯ç”¨è´¨é‡åˆ†æ
        std::chrono::seconds timeout = std::chrono::seconds(300); // è¶…æ—¶è®¾ç½®
    };
    
    // ğŸ†• å¤§è§„æ¨¡å…ƒæ•°æ®æå–
    OSCEAN_FUTURE(void) extractMetadataBatchAsync(
        const std::vector<std::string>& filePaths,
        std::function<void(const DatasetMetadata&)> processor,
        const MetadataExtractionConfig& config = MetadataExtractionConfig{}
    );
    
    // ğŸ†• æµå¼ç›®å½•æ‰«æ
    OSCEAN_FUTURE(void) scanDirectoryStreamingAsync(
        const std::string& directoryPath,
        const std::vector<std::string>& filePatterns,
        std::function<void(const DatasetMetadata&)> processor,
        const MetadataExtractionConfig& config = MetadataExtractionConfig{}
    );
    
    // ğŸ†• å¢é‡å…ƒæ•°æ®æ›´æ–°
    OSCEAN_FUTURE(void> updateMetadataIncrementallyAsync(
        const std::vector<std::string>& modifiedFiles,
        std::function<void(const std::string&, const DatasetMetadata&)> updateProcessor
    );
    
    /**
     * @brief å…ƒæ•°æ®æå–ç»Ÿè®¡
     */
    struct ExtractionStatistics {
        size_t totalFilesProcessed;
        size_t successfulExtractions;
        size_t failedExtractions;
        std::chrono::milliseconds totalProcessingTime;
        std::chrono::milliseconds averageFileTime;
        std::vector<std::string> errorFiles;
        std::map<std::string, size_t> formatDistribution;
    };
    
    // è·å–å¤„ç†ç»Ÿè®¡
    ExtractionStatistics getExtractionStatistics() const;
    
    // é‡ç½®ç»Ÿè®¡
    void resetStatistics();

private:
    std::shared_ptr<IDataAccessService> dataAccessService_;
    
    // ä½¿ç”¨Commonç»Ÿä¸€åŸºç¡€è®¾æ–½
    UnifiedThreadPoolManager& threadPoolManager_;
    UnifiedPerformanceMonitor& perfMonitor_;
    std::shared_ptr<MemoryPressureMonitor> pressureMonitor_;
    
    // ç»Ÿè®¡ä¿¡æ¯
    mutable ExtractionStatistics statistics_;
    mutable std::mutex statisticsMutex_;
    
    // è¾…åŠ©æ–¹æ³•
    OSCEAN_FUTURE(DatasetMetadata) extractSingleFileMetadataAsync(
        const std::string& filePath,
        const MetadataExtractionConfig& config
    );
    
    OSCEAN_FUTURE(void) processFileBatchAsync(
        const std::vector<std::string>& fileBatch,
        std::function<void(const DatasetMetadata&)> processor,
        const MetadataExtractionConfig& config
    );
};

} // namespace oscean::core_services::metadata::streaming
```

## ğŸ—ï¸ 3. å®Œæ•´å®æ–½è®¡åˆ’

### 3.1 å®æ–½é˜¶æ®µ
```mermaid
gantt
    title å…ƒæ•°æ®æœåŠ¡ç»Ÿä¸€é‡æ„å®æ–½è®¡åˆ’
    dateFormat  YYYY-MM-DD
    section é˜¶æ®µä¸€ï¼šåŸºç¡€æ¶æ„é‡æ„
    ç§»é™¤é‡å¤å®ç°        :crit, a1, 2024-01-01, 1d
    é›†æˆCommonç»„ä»¶      :crit, a2, after a1, 1d
    section é˜¶æ®µäºŒï¼šæ—¶é—´å…ƒæ•°æ®ç®¡ç†
    TimeMetadataManager :crit, t1, after a2, 1d
    TimeIndexManager    :crit, t2, after t1, 1d
    æ—¶é—´æŸ¥è¯¢ä¼˜åŒ–        :crit, t3, after t2, 1d
    section é˜¶æ®µä¸‰ï¼šç©ºé—´å…ƒæ•°æ®ç®¡ç†
    SpatialMetadataManager :crit, s1, after t3, 1d
    ç©ºé—´ç´¢å¼•ä¼˜åŒ–        :crit, s2, after s1, 1d
    section é˜¶æ®µå››ï¼šæµå¼å¤„ç†
    StreamingMetadataProcessor :crit, p1, after s2, 1d
    å¤§è§„æ¨¡å¤„ç†ä¼˜åŒ–      :crit, p2, after p1, 1d
    section é˜¶æ®µäº”ï¼šéªŒè¯æµ‹è¯•
    å•å…ƒæµ‹è¯•            :test1, after p2, 1d
    é›†æˆæµ‹è¯•            :test2, after test1, 1d
    æ€§èƒ½æµ‹è¯•            :test3, after test2, 1d
```

## ğŸ“‹ 4. å®Œæ•´é‡æ„æ£€æŸ¥æ¸…å•

### 4.1 **ğŸ”´ Critical: å¿…é¡»å®Œæˆçš„ä¿®æ­£**

#### **A. æ—¶é—´å…ƒæ•°æ®ç®¡ç†å®ç° (é˜»å¡æ€§)**
- [ ] **å®ç°**`TimeMetadataManager`ç±»ï¼Œç®¡ç†æ–‡ä»¶æ—¶é—´å…ƒæ•°æ®
- [ ] **å®ç°**`TimeIndexManager`ç±»ï¼Œæä¾›é«˜æ•ˆæ—¶é—´èŒƒå›´æŸ¥è¯¢
- [ ] **å®ç°**æ—¶é—´å…ƒæ•°æ®ç¼“å­˜ï¼ŒåŸºäºCommonç¼“å­˜æ¡†æ¶
- [ ] **å®ç°**æ—¶é—´è´¨é‡åˆ†æå’Œè¯„åˆ†æœºåˆ¶
- [ ] **éªŒè¯**æ—¶é—´å…ƒæ•°æ®ä¸æ•°æ®è®¿é—®æœåŠ¡çš„åä½œ

#### **B. åŸºç¡€è®¾æ–½ç»Ÿä¸€ (é˜»å¡æ€§)**
- [ ] åˆ é™¤æ‰€æœ‰ç‹¬ç«‹ç¼“å­˜å®ç°ï¼Œä½¿ç”¨`UnifiedCacheManager`
- [ ] åˆ é™¤ç‹¬ç«‹å­˜å‚¨å®ç°ï¼Œä½¿ç”¨Commonç»Ÿä¸€å­˜å‚¨æ¡†æ¶
- [ ] ç§»é™¤ç‹¬ç«‹çº¿ç¨‹æ± ï¼Œä½¿ç”¨`UnifiedThreadPoolManager`
- [ ] ç»Ÿä¸€æ€§èƒ½ç›‘æ§ï¼Œä½¿ç”¨`UnifiedPerformanceMonitor`
- [ ] å¼ºåˆ¶å¼‚æ­¥æ¥å£ä½¿ç”¨`OSCEAN_FUTURE(T)`

#### **C. æµå¼å¤„ç†å®ç° (é˜»å¡æ€§)**
- [ ] **å®ç°**`StreamingMetadataProcessor`ï¼Œæ”¯æŒå¤§è§„æ¨¡æ–‡ä»¶å¤„ç†
- [ ] **å®ç°**å¢é‡å…ƒæ•°æ®æ›´æ–°æœºåˆ¶
- [ ] **å®ç°**å†…å­˜å‹å¥½çš„ç›®å½•æ‰«æ
- [ ] **éªŒè¯**1000+æ–‡ä»¶çš„æ‰¹é‡å…ƒæ•°æ®æå–æ€§èƒ½

### 4.2 **ğŸŸ¡ Important: åŠŸèƒ½å¢å¼º**

#### **ç©ºé—´å…ƒæ•°æ®ç®¡ç†**
- [ ] å®ç°`SpatialMetadataManager`ç©ºé—´å…ƒæ•°æ®ç®¡ç†
- [ ] å®ç°ç©ºé—´ç´¢å¼•å’Œé«˜æ•ˆç©ºé—´æŸ¥è¯¢
- [ ] å®ç°ç©ºé—´å…ƒæ•°æ®ç¼“å­˜ä¼˜åŒ–

#### **æŸ¥è¯¢ä¼˜åŒ–**
- [ ] å®ç°å¤åˆæŸ¥è¯¢ï¼ˆæ—¶é—´+ç©ºé—´+æ ¼å¼ï¼‰
- [ ] å®ç°æŸ¥è¯¢ç»“æœç¼“å­˜
- [ ] å®ç°æŸ¥è¯¢æ€§èƒ½ç›‘æ§

### 4.3 **âœ… Validation: éªŒè¯ä¸æµ‹è¯•**

#### **åŠŸèƒ½éªŒè¯**
- [ ] æ—¶é—´å…ƒæ•°æ®ç®¡ç†åŠŸèƒ½å®Œæ•´æ€§éªŒè¯
- [ ] å¤§è§„æ¨¡æ–‡ä»¶å¤„ç†æ€§èƒ½éªŒè¯ï¼ˆ1000+æ–‡ä»¶ï¼‰
- [ ] å…ƒæ•°æ®æŸ¥è¯¢å‡†ç¡®æ€§å’Œæ€§èƒ½éªŒè¯
- [ ] ä¸æ•°æ®è®¿é—®æœåŠ¡åä½œéªŒè¯

#### **æ¶æ„éªŒè¯**
- [ ] åŸºç¡€è®¾æ–½ç»Ÿä¸€æ€§éªŒè¯
- [ ] å¼‚æ­¥æ¨¡å¼ä¸€è‡´æ€§éªŒè¯
- [ ] æ—¶é—´æ¶æ„ä¸‰å±‚åä½œéªŒè¯

---

## ğŸš€ æ€»ç»“ï¼šå…ƒæ•°æ®æœåŠ¡é‡æ„çš„å…³é”®æˆåŠŸå› ç´ 

### **1. æ—¶é—´æ¶æ„ç¬¬ä¸‰å±‚** ğŸ”´
- **ç®¡ç†èŒè´£**: è´Ÿè´£æ—¶é—´å…ƒæ•°æ®çš„ç®¡ç†ã€ç´¢å¼•ã€ç¼“å­˜
- **æŸ¥è¯¢ä¼˜åŒ–**: æä¾›é«˜æ•ˆçš„æ—¶é—´èŒƒå›´å’Œåˆ†è¾¨ç‡æŸ¥è¯¢

### **2. ä¸¥æ ¼ä¾èµ–Common** âš¡
- **æ— é‡å¤å®ç°**: ç»ä¸é‡å¤å®ç°ç¼“å­˜ã€å­˜å‚¨ã€çº¿ç¨‹æ± 
- **ç»Ÿä¸€åŸºç¡€è®¾æ–½**: ä½¿ç”¨Commonæä¾›çš„æ‰€æœ‰ç»Ÿä¸€ç»„ä»¶

### **3. å¤§è§„æ¨¡å¤„ç†** ğŸ—ï¸
- **æµå¼å¤„ç†**: æ”¯æŒ1000+æ–‡ä»¶çš„æµå¼å…ƒæ•°æ®æå–
- **å†…å­˜é«˜æ•ˆ**: å¤§è§„æ¨¡å¤„ç†ä¿æŒä½å†…å­˜å ç”¨

### **4. æŸ¥è¯¢æ€§èƒ½** âœ…
- **ç´¢å¼•ä¼˜åŒ–**: æ—¶é—´å’Œç©ºé—´ç´¢å¼•æ”¯æŒé«˜æ•ˆæŸ¥è¯¢
- **ç¼“å­˜ç­–ç•¥**: æ™ºèƒ½ç¼“å­˜çƒ­ç‚¹å…ƒæ•°æ®

**å…ƒæ•°æ®æœåŠ¡æ˜¯æ•°æ®å‘ç°çš„æ ¸å¿ƒï¼Œå¿…é¡»åšåˆ°ï¼šæ—¶é—´ç®¡ç†ä¸“ä¸šã€æŸ¥è¯¢æ€§èƒ½ä¼˜å¼‚ã€å¤§è§„æ¨¡å¤„ç†é«˜æ•ˆã€æ¶æ„ä¾èµ–æ¸…æ™°ã€‚** 