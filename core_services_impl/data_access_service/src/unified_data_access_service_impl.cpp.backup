/**
 * @file unified_data_access_service_impl.cpp
 * @brief ç»Ÿä¸€æ•°æ®è®¿é—®æœåŠ¡å®ç° - åŸºäºä¾èµ–æ³¨å…¥çš„ç‰ˆæœ¬
 */

#include "unified_data_access_service_impl.h"
#include "concurrent_optimization_components.h"
#include "common_utils/utilities/logging_utils.h"

#include <filesystem>
#include <algorithm>
#include <execution>
#include <fstream>
#include <chrono>
#include <shared_mutex>
#include <unordered_map>
#include <cctype>

// ï¿½ï¿½ ä¿®å¤ï¼šä½¿ç”¨æ­£ç¡®çš„OSCEANæ—¥å¿—å®
#ifndef LOG_DEBUG
#define LOG_DEBUG(tag, msg, ...) OSCEAN_LOG_DEBUG(tag, msg, ##__VA_ARGS__)
#endif
#ifndef LOG_INFO  
#define LOG_INFO(tag, msg, ...) OSCEAN_LOG_INFO(tag, msg, ##__VA_ARGS__)
#endif
#ifndef LOG_WARN
#define LOG_WARN(tag, msg, ...) OSCEAN_LOG_WARN(tag, msg, ##__VA_ARGS__)
#endif
#ifndef LOG_ERROR
#define LOG_ERROR(tag, msg, ...) OSCEAN_LOG_ERROR(tag, msg, ##__VA_ARGS__)
#endif
#ifndef LOG_CRITICAL
#define LOG_CRITICAL(tag, msg, ...) OSCEAN_LOG_CRITICAL(tag, msg, ##__VA_ARGS__)
#endif

namespace oscean::core_services {

// ğŸ”§ ä¿®å¤ï¼šæ­£ç¡®çš„å‘½åç©ºé—´åˆ«å
namespace readers = data_access::readers;

// ===============================================================================
// UnifiedDataAccessServiceImpl ç±»å®ç° - DIç‰ˆæœ¬
// ===============================================================================

UnifiedDataAccessServiceImpl::UnifiedDataAccessServiceImpl(
    std::shared_ptr<common_utils::infrastructure::CommonServicesFactory> servicesFactory,
    const data_access::api::DataAccessConfiguration& config,
    std::shared_ptr<GdalInitializationManager> gdalManager,
    std::shared_ptr<FileAccessLockManager> lockManager,
    std::shared_ptr<ReaderPoolManager> poolManager)
    : servicesFactory_(std::move(servicesFactory))
    , config_(config)
    , gdalManager_(std::move(gdalManager))
    , lockManager_(std::move(lockManager))
    , poolManager_(std::move(poolManager))
    , isInitialized_(false)
    , totalRequests_(0)
    , successfulRequests_(0) {
    
    OSCEAN_LOG_INFO("UnifiedDataAccessServiceImpl", "åˆ›å»ºUnifiedDataAccessServiceImpl - DIç‰ˆæœ¬");
    OSCEAN_LOG_INFO("UnifiedDataAccessServiceImpl", "æœåŠ¡: {}, ç‰ˆæœ¬: {}", 
                    config_.serviceName.c_str(), config_.version.c_str());
    
    // å¦‚æœæ²¡æœ‰æä¾›å¹¶å‘ä¼˜åŒ–ç»„ä»¶ï¼Œåˆ›å»ºé»˜è®¤çš„è½»é‡çº§å®ç°
    if (!gdalManager_) {
        gdalManager_ = std::make_shared<GdalInitializationManagerImpl>(servicesFactory_);
    }
    if (!lockManager_) {
        lockManager_ = std::make_shared<FileAccessLockManagerImpl>();
    }
    if (!poolManager_) {
        poolManager_ = std::make_shared<ReaderPoolManagerImpl>();
    }
    
    initializeServices();
}

UnifiedDataAccessServiceImpl::~UnifiedDataAccessServiceImpl() {
    OSCEAN_LOG_INFO("UnifiedDataAccessServiceImpl", "UnifiedDataAccessServiceImplææ„ - DIç‰ˆæœ¬");
    shutdown();
}

// ===============================================================================
// åˆå§‹åŒ–å’Œæ¸…ç† - DIç‰ˆæœ¬
// ===============================================================================

void UnifiedDataAccessServiceImpl::initializeServices() {
    if (isInitialized_.load()) {
        return;
    }
    
    try {
        OSCEAN_LOG_INFO("UnifiedDataAccessServiceImpl", "ğŸ”§ å¼€å§‹åˆå§‹åŒ–UnifiedDataAccessServiceImpl - DIå¹¶å‘ä¼˜åŒ–ç‰ˆæœ¬");
        
        // ===== æ­¥éª¤1: GDALé¢„çƒ­åˆå§‹åŒ– =====
        OSCEAN_LOG_INFO("UnifiedDataAccessServiceImpl", "ğŸ”¥ [æ­¥éª¤1] å¼€å§‹GDALé¢„çƒ­åˆå§‹åŒ–...");
        auto startGdalTime = std::chrono::high_resolution_clock::now();
        
        if (gdalManager_ && !gdalManager_->isWarmedUp()) {
            if (!gdalManager_->warmupInitialization()) {
                OSCEAN_LOG_WARN("UnifiedDataAccessServiceImpl", "âš ï¸ GDALé¢„çƒ­å¤±è´¥ï¼Œå°†åœ¨è¿è¡Œæ—¶åˆå§‹åŒ–");
            }
        }
        
        auto endGdalTime = std::chrono::high_resolution_clock::now();
        auto gdalDuration = std::chrono::duration_cast<std::chrono::milliseconds>(endGdalTime - startGdalTime);
        OSCEAN_LOG_INFO("UnifiedDataAccessServiceImpl", "âœ… [æ­¥éª¤1] GDALé¢„çƒ­å®Œæˆ ({}ms)", gdalDuration.count());
        
        // ===== æ­¥éª¤2: åˆå§‹åŒ–Common Services =====
        OSCEAN_LOG_INFO("UnifiedDataAccessServiceImpl", "ğŸ”§ [æ­¥éª¤2] åˆå§‹åŒ–Common Services...");
        
        if (!servicesFactory_) {
            throw std::runtime_error("CommonServicesFactoryä¸èƒ½ä¸ºç©º");
        }
        
        // è·å–æ–‡ä»¶æ ¼å¼æ£€æµ‹å™¨
        fileFormatDetector_ = std::make_shared<common_utils::utilities::FileFormatDetector>();
        
        // åˆ›å»ºç¼“å­˜å®ä¾‹ - ä½¿ç”¨é»˜è®¤å¤§å°
        metadataCache_ = servicesFactory_->createCache<std::string, FileMetadata>(
            "metadata_cache", 10000);  // é»˜è®¤å¤§å°
        gridCache_ = servicesFactory_->createCache<std::string, GridData>(
            "grid_cache", 1000);       // é»˜è®¤å¤§å°
        
        OSCEAN_LOG_INFO("UnifiedDataAccessServiceImpl", "âœ… [æ­¥éª¤2] Common Servicesåˆå§‹åŒ–å®Œæˆ");
        
        // ===== æ­¥éª¤3: åˆ›å»ºè¯»å–å™¨æ³¨å†Œè¡¨ =====
        OSCEAN_LOG_INFO("UnifiedDataAccessServiceImpl", "ğŸ“š [æ­¥éª¤3] åˆ›å»ºè¯»å–å™¨æ³¨å†Œè¡¨...");
        
        readerRegistry_ = std::make_shared<data_access::readers::ReaderRegistry>(servicesFactory_);
        if (!readerRegistry_) {
            throw std::runtime_error("è¯»å–å™¨æ³¨å†Œè¡¨åˆ›å»ºå¤±è´¥");
        }
        
        OSCEAN_LOG_INFO("UnifiedDataAccessServiceImpl", "âœ… [æ­¥éª¤3] è¯»å–å™¨æ³¨å†Œè¡¨åˆ›å»ºå®Œæˆ");
        
        // ===== æ­¥éª¤4: åˆå§‹åŒ–è¯»å–å™¨æ±  =====
        if (poolManager_) {
            OSCEAN_LOG_INFO("UnifiedDataAccessServiceImpl", "ğŸŠ [æ­¥éª¤4] åˆå§‹åŒ–è¯»å–å™¨æ± ...");
            
            ReaderPoolManager::PoolConfiguration poolConfig;
            poolConfig.initialPoolSize = 4;      // é»˜è®¤åˆå§‹å¤§å°
            poolConfig.maxPoolSize = 16;         // é»˜è®¤æœ€å¤§å¤§å°
            poolConfig.enablePooling = config_.enableCaching;
            
            if (!poolManager_->initializePool(poolConfig, readerRegistry_, servicesFactory_)) {
                OSCEAN_LOG_WARN("UnifiedDataAccessServiceImpl", "âš ï¸ è¯»å–å™¨æ± åˆå§‹åŒ–å¤±è´¥ï¼Œå°†ç›´æ¥åˆ›å»ºè¯»å–å™¨");
            }
            
            OSCEAN_LOG_INFO("UnifiedDataAccessServiceImpl", "âœ… [æ­¥éª¤4] è¯»å–å™¨æ± åˆå§‹åŒ–å®Œæˆ");
        }
        
        // ===== æ­¥éª¤5: æ–‡ä»¶é”å®šç®¡ç†å™¨å°±ç»ª =====
        if (lockManager_) {
            OSCEAN_LOG_INFO("UnifiedDataAccessServiceImpl", "ğŸ”’ [æ­¥éª¤5] æ–‡ä»¶çº§é”å®šç®¡ç†å™¨å·²å°±ç»ª");
        }
        
        isInitialized_.store(true);
        
        OSCEAN_LOG_INFO("UnifiedDataAccessServiceImpl", "ğŸš€ UnifiedDataAccessServiceImpl DIç‰ˆæœ¬åˆå§‹åŒ–å®Œæˆ");
        
    } catch (const std::exception& e) {
        OSCEAN_LOG_ERROR("UnifiedDataAccessServiceImpl", "âŒ åˆå§‹åŒ–å¤±è´¥: {}", e.what());
        throw;
    }
}

void UnifiedDataAccessServiceImpl::shutdown() {
    if (!isInitialized_.load()) {
        return;
    }
    
    try {
        clearCache();
        isInitialized_.store(false);
        LOG_INFO("UnifiedDataAccessServiceImplæ¸…ç†å®Œæˆ");
    } catch (const std::exception& e) {
        LOG_ERROR("æœåŠ¡æ¸…ç†å¼‚å¸¸: {}", e.what());
    }
}

// ===============================================================================
// IUnifiedDataAccessService æ¥å£å®ç°
// ===============================================================================

boost::future<data_access::api::UnifiedDataResponse> UnifiedDataAccessServiceImpl::processDataRequestAsync(
    const data_access::api::UnifiedDataRequest& request) {
    
    ++totalRequests_;
    
    return createAsyncTask<data_access::api::UnifiedDataResponse>([this, request]() -> data_access::api::UnifiedDataResponse {
        try {
            LOG_DEBUG("å¤„ç†ç»Ÿä¸€æ•°æ®è¯·æ±‚: ç±»å‹={}, æ–‡ä»¶={}", 
                static_cast<int>(request.requestType), request.filePath);
            
            data_access::api::UnifiedDataResponse response;
            response.requestId = request.requestId;
            response.status = data_access::api::UnifiedResponseStatus::SUCCESS;
            
            // éªŒè¯æ–‡ä»¶è·¯å¾„
            if (!validateFilePath(request.filePath)) {
                response.status = data_access::api::UnifiedResponseStatus::INVALID_REQUEST;
                response.errorMessage = "æ— æ•ˆçš„æ–‡ä»¶è·¯å¾„";
                return response;
            }
            
            // æ ¹æ®è¯·æ±‚ç±»å‹å¤„ç†æ•°æ®
            switch (request.requestType) {
                case data_access::api::UnifiedRequestType::FILE_METADATA: {
                    auto metadataFuture = getFileMetadataAsync(request.filePath);
                    auto metadata = metadataFuture.get();
                    if (metadata.has_value()) {
                        response.data = std::make_shared<FileMetadata>(metadata.value());
                        response.status = data_access::api::UnifiedResponseStatus::SUCCESS;
                        ++successfulRequests_;
                    } else {
                        response.status = data_access::api::UnifiedResponseStatus::NOT_FOUND;
                        response.errorMessage = "æ— æ³•è·å–æ–‡ä»¶å…ƒæ•°æ®";
                    }
                    break;
                }
                
                case data_access::api::UnifiedRequestType::FEATURE_COLLECTION: {
                    // âœ… çŸ¢é‡åŠŸèƒ½å·²å¯ç”¨ - ä½¿ç”¨ä¸“é—¨çš„GDALçŸ¢é‡è¯»å–å™¨
                    LOG_DEBUG("å¤„ç†è¦ç´ é›†åˆè¯·æ±‚: æ–‡ä»¶={}, å›¾å±‚={}", 
                             request.filePath, request.variableName);
                    
                    try {
                        // ä½¿ç”¨å›¾å±‚åç§°æˆ–é»˜è®¤ä¸ºç©ºï¼ˆè¯»å–æ‰€æœ‰å›¾å±‚ï¼‰
                        std::string layerName = request.variableName.empty() ? "" : request.variableName;
                        
                        auto gridDataFuture = readGridDataAsync(request.filePath, layerName, request.spatialBounds);
                        auto gridData = gridDataFuture.get();
                        
                        if (gridData) {
                            response.data = gridData;
                            response.status = data_access::api::UnifiedResponseStatus::SUCCESS;
                            ++successfulRequests_;
                            LOG_INFO("è¦ç´ é›†åˆè¯·æ±‚æˆåŠŸ: æ–‡ä»¶={}, æ•°æ®å¤§å°={} å­—èŠ‚", 
                                    request.filePath, gridData->data.size());
                        } else {
                            response.status = data_access::api::UnifiedResponseStatus::NOT_FOUND;
                            response.errorMessage = "æ— æ³•è¯»å–çŸ¢é‡è¦ç´ æ•°æ®";
                            LOG_WARN("è¦ç´ é›†åˆè¯»å–å¤±è´¥: æ–‡ä»¶={}", request.filePath);
                        }
                    } catch (const std::exception& e) {
                        response.status = data_access::api::UnifiedResponseStatus::FAILED;
                        response.errorMessage = std::string("è¦ç´ é›†åˆè¯»å–å¼‚å¸¸: ") + e.what();
                        LOG_ERROR("è¦ç´ é›†åˆè¯·æ±‚å¼‚å¸¸: {}", e.what());
                    }
                    break;
                }
                
                case data_access::api::UnifiedRequestType::GRID_DATA: {
                    if (request.variableName.empty()) {
                        response.status = data_access::api::UnifiedResponseStatus::INVALID_REQUEST;
                        response.errorMessage = "ç½‘æ ¼æ•°æ®è¯·æ±‚éœ€è¦å˜é‡å";
                        return response;
                    }
                    
                    auto gridDataFuture = readGridDataAsync(request.filePath, request.variableName, request.spatialBounds);
                    auto gridData = gridDataFuture.get();
                    if (gridData) {
                        response.data = gridData;
                        response.status = data_access::api::UnifiedResponseStatus::SUCCESS;
                        ++successfulRequests_;
                    } else {
                        response.status = data_access::api::UnifiedResponseStatus::NOT_FOUND;
                        response.errorMessage = "æ— æ³•è¯»å–ç½‘æ ¼æ•°æ®";
                    }
                    break;
                }
                
                case data_access::api::UnifiedRequestType::VARIABLE_EXISTS_CHECK: {
                    if (request.variableName.empty()) {
                        response.status = data_access::api::UnifiedResponseStatus::INVALID_REQUEST;
                        response.errorMessage = "å˜é‡å­˜åœ¨æ€§æ£€æŸ¥éœ€è¦å˜é‡å";
                        return response;
                    }
                    
                    auto existsFuture = checkVariableExistsAsync(request.filePath, request.variableName);
                    bool exists = existsFuture.get();
                    response.data = exists;
                    response.status = data_access::api::UnifiedResponseStatus::SUCCESS;
                    ++successfulRequests_;
                    break;
                }
                
                default:
                    response.status = data_access::api::UnifiedResponseStatus::INVALID_REQUEST;
                    response.errorMessage = "ä¸æ”¯æŒçš„è¯·æ±‚ç±»å‹";
                    LOG_WARN("ä¸æ”¯æŒçš„ç»Ÿä¸€è¯·æ±‚ç±»å‹: {}", static_cast<int>(request.requestType));
                    break;
            }
            
            return response;
            
        } catch (const std::exception& e) {
            LOG_ERROR("processDataRequestAsyncå¤±è´¥: {}", e.what());
            data_access::api::UnifiedDataResponse errorResponse;
            errorResponse.requestId = request.requestId;
            errorResponse.status = data_access::api::UnifiedResponseStatus::FAILED;
            errorResponse.errorMessage = e.what();
            return errorResponse;
        }
    });
}

boost::future<std::vector<data_access::api::UnifiedDataResponse>> UnifiedDataAccessServiceImpl::processBatchRequestsAsync(
    const std::vector<data_access::api::UnifiedDataRequest>& requests) {
    
    return createAsyncTask<std::vector<data_access::api::UnifiedDataResponse>>([this, requests]() -> std::vector<data_access::api::UnifiedDataResponse> {
        try {
            LOG_DEBUG("å¤„ç†æ‰¹é‡ç»Ÿä¸€æ•°æ®è¯·æ±‚: æ•°é‡={}", requests.size());
            
            std::vector<data_access::api::UnifiedDataResponse> responses;
            responses.reserve(requests.size());
            
            // å¹¶è¡Œå¤„ç†æ‰€æœ‰è¯·æ±‚
            std::vector<boost::future<data_access::api::UnifiedDataResponse>> futures;
            futures.reserve(requests.size());
            
            for (const auto& request : requests) {
                futures.push_back(processDataRequestAsync(request));
            }
            
            // æ”¶é›†æ‰€æœ‰ç»“æœ
            for (auto& future : futures) {
                try {
                    responses.push_back(future.get());
                } catch (const std::exception& e) {
                    LOG_ERROR("æ‰¹é‡è¯·æ±‚ä¸­çš„å•ä¸ªè¯·æ±‚å¤±è´¥: {}", e.what());
                    
                    data_access::api::UnifiedDataResponse errorResponse;
                    errorResponse.status = data_access::api::UnifiedResponseStatus::FAILED;
                    errorResponse.errorMessage = e.what();
                    responses.push_back(errorResponse);
                }
            }
            
            return responses;
            
        } catch (const std::exception& e) {
            LOG_ERROR("æ‰¹é‡ç»Ÿä¸€æ•°æ®è¯·æ±‚å¤„ç†å¼‚å¸¸: {}", e.what());
            throw;
        }
    });
}

boost::future<std::optional<FileMetadata>> UnifiedDataAccessServiceImpl::getFileMetadataAsync(const std::string& filePath) {
    return createAsyncTask<std::optional<FileMetadata>>([this, filePath]() -> std::optional<FileMetadata> {
        
        // ===== ç”Ÿäº§ç¯å¢ƒå¹¶å‘ä¼˜åŒ–ï¼šæ–‡ä»¶çº§é”å®š =====
        auto fileGuard = lockManager_->createFileGuard(filePath);
        
        // ğŸ“Š è®°å½•æ–‡ä»¶è®¿é—®ç»Ÿè®¡
        auto accessStats = lockManager_->getFileAccessStats(filePath);
        
        LOG_DEBUG("æ–‡ä»¶è®¿é—®ç»Ÿè®¡: æ´»è·ƒè¯»å–å™¨={}, æ’é˜Ÿè¯·æ±‚={}", 
                 accessStats.activeReaders, accessStats.queuedRequests);
        
        try {
            LOG_DEBUG("ğŸ“„ å¼€å§‹è·å–æ–‡ä»¶å…ƒæ•°æ®: {}", filePath);
            
            // éªŒè¯æ–‡ä»¶è·¯å¾„
            if (!validateFilePath(filePath)) {
                LOG_WARN("âŒ æ— æ•ˆæ–‡ä»¶è·¯å¾„: {}", filePath);
                return std::nullopt;
            }
            
            // æ£€æµ‹æ–‡ä»¶æ ¼å¼
            std::string readerType = detectFileFormat(filePath);
            
            // ğŸŠ ä»æ± ä¸­è·å–æˆ–åˆ›å»ºè¯»å–å™¨
            auto reader = poolManager_->getOrCreateReader(filePath, readerType);
            
            if (!reader) {
                LOG_ERROR("âŒ åˆ›å»ºè¯»å–å™¨å¤±è´¥: {} (ç±»å‹: {})", filePath, readerType);
                return std::nullopt;
            }
            
            LOG_DEBUG("âœ… è·å¾—è¯»å–å™¨: {} (ç±»å‹: {})", filePath, readerType);
            
            // RAIIæ–¹å¼ç¡®ä¿è¯»å–å™¨æœ€ç»ˆå½’è¿˜åˆ°æ± ä¸­
            struct ReaderGuard {
                std::shared_ptr<readers::UnifiedDataReader> reader_;
                std::shared_ptr<ReaderPoolManager> poolManager_;
                
                ReaderGuard(std::shared_ptr<readers::UnifiedDataReader> reader, std::shared_ptr<ReaderPoolManager> pm)
                    : reader_(reader), poolManager_(pm) {}
                    
                ~ReaderGuard() {
                    if (reader_ && poolManager_) {
                        poolManager_->returnReaderToPool(reader_);
                    }
                }
            } readerGuard(reader, poolManager_);
            
            // æ‰“å¼€æ–‡ä»¶
            bool opened = reader->openAsync().get();
            if (!opened) {
                LOG_ERROR("âŒ è¯»å–å™¨æ‰“å¼€æ–‡ä»¶å¤±è´¥: {}", filePath);
                return std::nullopt;
            }
            
            // è·å–å…ƒæ•°æ®
            auto metadataFuture = reader->getFileMetadataAsync();
            auto metadata = metadataFuture.get();
            
            if (metadata.has_value()) {
                LOG_DEBUG("âœ… å…ƒæ•°æ®è·å–æˆåŠŸ: {} (å˜é‡: {}, ç»´åº¦: {})", 
                         filePath, metadata->variables.size(), metadata->geographicDimensions.size());
                return metadata;
            } else {
                LOG_WARN("âš ï¸ è¯»å–å™¨è¿”å›ç©ºå…ƒæ•°æ®: {}", filePath);
                return std::nullopt;
            }
            
        } catch (const std::exception& e) {
            LOG_ERROR("âŒ è·å–æ–‡ä»¶å…ƒæ•°æ®å¼‚å¸¸: {} - {}", filePath, e.what());
            return std::nullopt;
        }
    });
}

boost::future<std::shared_ptr<GridData>> UnifiedDataAccessServiceImpl::readGridDataAsync(
    const std::string& filePath,
    const std::string& variableName,
    const std::optional<BoundingBox>& bounds) {
    
    return createAsyncTask<std::shared_ptr<GridData>>([this, filePath, variableName, bounds]() -> std::shared_ptr<GridData> {
        try {
            // è·å–è¯»å–å™¨
            auto reader = getReaderForFile(filePath);
            if (!reader) {
                LOG_ERROR("æ— æ³•ä¸ºæ–‡ä»¶åˆ›å»ºè¯»å–å™¨: {}", filePath);
                return nullptr;
            }
            
            // ğŸ”§ å…³é”®ä¿®å¤ï¼šå…ˆæ‰“å¼€æ–‡ä»¶
            auto openResult = reader->openAsync().get();
            if (!openResult) {
                LOG_ERROR("æ— æ³•æ‰“å¼€æ–‡ä»¶: {}", filePath);
                return nullptr;
            }
            
            // è¯»å–ç½‘æ ¼æ•°æ®
            auto gridDataFuture = reader->readGridDataAsync(variableName, bounds);
            auto gridData = gridDataFuture.get();
            
            // ğŸ”§ åœ¨å¤„ç†å®Œåå…³é—­æ–‡ä»¶
            try {
                reader->closeAsync().get();
            } catch (const std::exception& e) {
                LOG_WARN("å…³é—­æ–‡ä»¶æ—¶å‡ºç°å¼‚å¸¸: {} - {}", filePath, e.what());
            }
            
            return gridData;
            
        } catch (const std::exception& e) {
            LOG_ERROR("è¯»å–ç½‘æ ¼æ•°æ®å¼‚å¸¸: {} - {}", filePath, e.what());
            return nullptr;
        }
    });
}

boost::future<bool> UnifiedDataAccessServiceImpl::checkVariableExistsAsync(
    const std::string& filePath,
    const std::string& variableName) {
    
    return createAsyncTask<bool>([this, filePath, variableName]() -> bool {
        try {
            auto reader = getReaderForFile(filePath);
            if (!reader) {
                return false;
            }
            
            auto variablesFuture = reader->getVariableNamesAsync();
            auto variables = variablesFuture.get();
            
            return std::find(variables.begin(), variables.end(), variableName) != variables.end();
        } catch (const std::exception& e) {
            LOG_ERROR("æ£€æŸ¥å˜é‡å­˜åœ¨æ€§å¤±è´¥: {}", e.what());
            return false;
        }
    });
}

boost::future<std::vector<std::string>> UnifiedDataAccessServiceImpl::getVariableNamesAsync(
    const std::string& filePath) {
    
    return createAsyncTask<std::vector<std::string>>([this, filePath]() -> std::vector<std::string> {
        try {
            auto reader = getReaderForFile(filePath);
            if (!reader) {
                return {};
            }
            
            auto variablesFuture = reader->getVariableNamesAsync();
            return variablesFuture.get();
        } catch (const std::exception& e) {
            LOG_ERROR("è·å–å˜é‡åå¤±è´¥: {}", e.what());
            return {};
        }
    });
}

boost::future<void> UnifiedDataAccessServiceImpl::startStreamingAsync(
    const std::string& filePath,
    const std::string& variableName,
    std::function<bool(const std::vector<double>&)> chunkProcessor) {
    
    return createAsyncTask<void>([this, filePath, variableName, chunkProcessor]() -> void {
        try {
            auto reader = getReaderForFile(filePath);
            if (!reader) {
                LOG_ERROR("æ— æ³•è·å–æ–‡ä»¶è¯»å–å™¨: {}", filePath);
                return;
            }
            
            // ç®€åŒ–çš„æµå¼å¤„ç†å®ç° - è¯»å–å®Œæ•´æ•°æ®ç„¶åè½¬æ¢
            auto gridDataFuture = reader->readGridDataAsync(variableName);
            auto gridData = gridDataFuture.get();
            
            if (gridData && !gridData->data.empty()) {
                // å°†unsigned charæ•°æ®è½¬æ¢ä¸ºdoubleæ•°æ®ä¼ é€’ç»™å¤„ç†å™¨
                std::vector<double> doubleData;
                doubleData.reserve(gridData->data.size());
                
                for (const auto& byte : gridData->data) {
                    doubleData.push_back(static_cast<double>(byte));
                }
                
                chunkProcessor(doubleData);
            }
        } catch (const std::exception& e) {
            LOG_ERROR("æµå¼å¤„ç†å¤±è´¥: {}", e.what());
        }
    });
}

data_access::api::DataAccessMetrics UnifiedDataAccessServiceImpl::getPerformanceMetrics() const {
    data_access::api::DataAccessMetrics metrics;
    
    metrics.totalRequests = totalRequests_.load();
    metrics.successfulRequests = successfulRequests_.load();
    metrics.failedRequests = metrics.totalRequests - metrics.successfulRequests;
    metrics.averageResponseTimeMs = 0.0; // ç®€åŒ–å®ç°
    
    return metrics;
}

void UnifiedDataAccessServiceImpl::configurePerformanceTargets(
    const data_access::api::DataAccessPerformanceTargets& targets) {
    LOG_INFO("æ€§èƒ½ç›®æ ‡å·²é…ç½®");
}

void UnifiedDataAccessServiceImpl::clearCache() {
    // ğŸ¯ æ•°æ®è®¿é—®æ¨¡å—ä¸è´Ÿè´£ç¼“å­˜ç®¡ç†
    // ç¼“å­˜ç®¡ç†åº”è¯¥ç”±å„ä¸ªä¸“é—¨çš„æ¨¡å—ï¼ˆå¦‚å…ƒæ•°æ®æ¨¡å—ï¼‰è´Ÿè´£
    LOG_INFO("æ•°æ®è®¿é—®æ¨¡å—ä¸è´Ÿè´£ç¼“å­˜ç®¡ç†ï¼Œç¼“å­˜æ¸…ç†åº”ç”±å„ä¸“é—¨æ¨¡å—æ‰§è¡Œ");
}

bool UnifiedDataAccessServiceImpl::isHealthy() const {
    return isInitialized_.load() && servicesFactory_ != nullptr;
}

// ===============================================================================
// å†…éƒ¨è¾…åŠ©æ–¹æ³•
// ===============================================================================

std::shared_ptr<data_access::readers::UnifiedDataReader> 
UnifiedDataAccessServiceImpl::getReaderForFile(const std::string& filePath) {
    
    if (!validateFilePath(filePath)) {
        LOG_ERROR("UnifiedDataAccessServiceImpl", "âŒ æ— æ•ˆçš„æ–‡ä»¶è·¯å¾„: {}", filePath.c_str());
        return nullptr;
    }
    
    try {
        // ğŸ”’ ä½¿ç”¨æ–‡ä»¶çº§é”å®šï¼Œç¡®ä¿å¹¶å‘å®‰å…¨
        auto fileGuard = lockManager_->createFileGuard(filePath);
        
        // ğŸ“Š è®°å½•æ–‡ä»¶è®¿é—®ç»Ÿè®¡
        auto accessStats = lockManager_->getFileAccessStats(filePath);
        
        LOG_DEBUG("æ–‡ä»¶è®¿é—®ç»Ÿè®¡: æ´»è·ƒè¯»å–å™¨={}, æ’é˜Ÿè¯·æ±‚={}", 
                 accessStats.activeReaders, accessStats.queuedRequests);
        
        // æ£€æµ‹æ–‡ä»¶æ ¼å¼
        std::string readerType = detectFileFormat(filePath);
        if (readerType.empty()) {
            LOG_WARN("UnifiedDataAccessServiceImpl", "âŒ æ— æ³•ç¡®å®šè¯»å–å™¨ç±»å‹: {}", filePath.c_str());
            return nullptr;
        }
        
        // ğŸŠ ä»æ± ä¸­è·å–æˆ–åˆ›å»ºè¯»å–å™¨
        auto reader = poolManager_->getOrCreateReader(filePath, readerType);
        
        if (!reader) {
            LOG_ERROR("UnifiedDataAccessServiceImpl", "âŒ æ— æ³•åˆ›å»ºè¯»å–å™¨: {} (ç±»å‹: {})", 
                     filePath.c_str(), readerType.c_str());
            return nullptr;
        }
        
        LOG_DEBUG("âœ… æˆåŠŸè·å–è¯»å–å™¨: {} (ç±»å‹: {})", filePath.c_str(), readerType.c_str());
        return reader;
        
    } catch (const std::exception& e) {
        LOG_ERROR("UnifiedDataAccessServiceImpl", "âŒ è·å–è¯»å–å™¨å¼‚å¸¸: {} - {}", filePath.c_str(), e.what());
        return nullptr;
    }
}

bool UnifiedDataAccessServiceImpl::validateFilePath(const std::string& filePath) const {
    if (filePath.empty()) {
        return false;
    }
    
    try {
        std::filesystem::path path(filePath);
        return std::filesystem::exists(path) && std::filesystem::is_regular_file(path);
    } catch (const std::exception&) {
        return false;
    }
}

std::string UnifiedDataAccessServiceImpl::detectFileFormat(const std::string& filePath) const {
    try {
        if (!fileFormatDetector_) {
            LOG_WARN("UnifiedDataAccessServiceImpl", "âš ï¸ æ–‡ä»¶æ ¼å¼æ£€æµ‹å™¨æœªåˆå§‹åŒ–");
            return "";
        }
        
        auto result = fileFormatDetector_->detectFormat(filePath);
        
        if (!result.isValid()) {
            LOG_WARN("UnifiedDataAccessServiceImpl", "âš ï¸ æ— æ³•æ£€æµ‹æ–‡ä»¶æ ¼å¼: {}", filePath.c_str());
            return "";
        }
        
        // è½¬æ¢ä¸ºå¤§å†™æ ¼å¼åç§°ï¼ˆåŒ¹é…æ³¨å†Œè¡¨æ ¼å¼ï¼‰
        std::string formatName = result.formatName;
        std::transform(formatName.begin(), formatName.end(), formatName.begin(), ::toupper);
        
        // æ ‡å‡†åŒ–æ ¼å¼åç§°æ˜ å°„
        static const std::unordered_map<std::string, std::string> formatMapping = {
            {"NETCDF", "NETCDF"},
            {"NETCDF3", "NETCDF"},
            {"NETCDF4", "NETCDF"},
            {"GEOTIFF", "GEOTIFF"},
            {"TIFF", "GEOTIFF"},
            {"TIF", "GEOTIFF"},
            {"SHAPEFILE", "SHAPEFILE"},
            {"SHP", "SHAPEFILE"},
            {"HDF5", "HDF5"},
            {"GEOPACKAGE", "GEOPACKAGE"},
            {"GPKG", "GEOPACKAGE"}
        };
        
        auto it = formatMapping.find(formatName);
        if (it != formatMapping.end()) {
            return it->second;
        }
        
        return formatName;  // å¦‚æœæ²¡æœ‰æ˜ å°„ï¼Œè¿”å›åŸå§‹åç§°
        
    } catch (const std::exception& e) {
        LOG_ERROR("UnifiedDataAccessServiceImpl", "âŒ æ ¼å¼æ£€æµ‹å¼‚å¸¸: {} - {}", filePath.c_str(), e.what());
        return "";
    }
}

template<typename T>
boost::future<T> UnifiedDataAccessServiceImpl::createAsyncTask(std::function<T()> task) const {
    return boost::async(boost::launch::async, std::move(task));
}

} // namespace oscean::core_services 