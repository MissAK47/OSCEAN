# Metadata服务模块重构检查清单

## 1. 重构前现状检查

### 1.1 编译问题诊断
- [ ] 检查boost::future相关编译错误详情
- [ ] 分析头文件包含顺序问题
- [ ] 确认MSVC编译选项配置
- [ ] 检查宏定义冲突问题

### 1.2 代码结构分析
- [ ] 检查`core_services_impl/metadata_service/`目录结构
- [ ] 分析`MetadataServiceImpl`类的当前实现
- [ ] 识别现有的后台任务管理机制
- [ ] 检查现有的`MetadataCache`实现
- [ ] 评估SQLite集成状态

### 1.3 依赖关系检查
- [ ] 确认boost::thread版本和配置
- [ ] 检查SQLite3库集成状态
- [ ] 验证nlohmann_json依赖
- [ ] 确认与core_service_interfaces的接口契约
- [ ] 检查与common_utilities的当前集成状态

### 1.4 性能基准建立
- [ ] 记录当前元数据提取性能基准
- [ ] 测量内存使用情况
- [ ] 统计缓存命中率
- [ ] 记录后台任务执行效率

## 2. 第一阶段：修复编译问题（1天）

### 2.1 boost::future宏定义统一
- [ ] 在CMakeLists.txt中添加统一的宏定义
```cmake
# 检查点：确保以下宏定义正确添加
if(MSVC)
    target_compile_definitions(${LIB_NAME} PRIVATE 
        BOOST_THREAD_PROVIDES_FUTURE=1
        BOOST_THREAD_PROVIDES_FUTURE_CONTINUATION=1
        BOOST_THREAD_PROVIDES_FUTURE_WHEN_ALL_WHEN_ANY=1
        BOOST_THREAD_USES_MOVE=1
    )
endif()
```

### 2.2 头文件包含顺序修复
- [ ] 检查`metadata_extractor.h`中的头文件包含顺序
- [ ] 确保boost宏定义在包含boost头文件之前
- [ ] 验证所有相关头文件的包含顺序

### 2.3 MSVC编译选项配置
- [ ] 添加异常处理选项`/EHsc`
- [ ] 添加UTF-8编码选项`/utf-8`
- [ ] 配置Windows版本宏`_WIN32_WINNT=0x0A00`

### 2.4 编译验证
- [ ] 使用vcpkg工具链编译验证
- [ ] 确认所有编译错误已解决
- [ ] 验证链接过程正常
- [ ] 测试基本功能可用

## 3. 第二阶段：后台任务管理迁移（2-3天）

### 3.1 准备工作
- [ ] 确认common_utilities中`TaskScheduler`可用
- [ ] 分析现有后台任务的类型和优先级
- [ ] 设计任务迁移策略

### 3.2 实施步骤
#### 3.2.1 TaskScheduler集成
- [ ] 在`MetadataServiceImpl`中集成`TaskScheduler`
```cpp
// 检查点：确保TaskScheduler正确集成
auto taskScheduler = oscean::common_utils::parallel::TaskScheduler::getInstance();
m_taskScheduler = taskScheduler;
```

#### 3.2.2 后台任务迁移
- [ ] 将元数据缓存清理任务迁移到`TaskScheduler`
- [ ] 将定期索引更新任务迁移到`TaskScheduler`
- [ ] 将数据库维护任务迁移到`TaskScheduler`
- [ ] 保持任务的优先级和调度策略

#### 3.2.3 负载均衡集成
- [ ] 使用`LoadBalancer`进行任务负载均衡
- [ ] 配置合理的任务分发策略
- [ ] 确保关键任务的及时执行

### 3.3 测试验证
- [ ] 功能测试：后台任务正常执行
- [ ] 性能测试：任务调度效率
- [ ] 稳定性测试：长期运行稳定性
- [ ] 资源测试：资源使用优化

### 3.4 问题排查清单
- [ ] 如果任务执行延迟，检查调度器配置
- [ ] 如果资源竞争，调整负载均衡策略
- [ ] 如果任务丢失，检查任务队列管理

## 4. 第三阶段：缓存系统优化（2天）

### 4.1 准备工作
- [ ] 确认common_utilities中`MultiLevelCacheManager`可用
- [ ] 分析现有`MetadataCache`的数据结构
- [ ] 设计元数据专用缓存策略

### 4.2 实施步骤
#### 4.2.1 缓存管理器集成
- [ ] 将`MetadataCache`集成到`MultiLevelCacheManager`
```cpp
// 检查点：确保缓存管理器正确集成
auto cacheManager = oscean::common_utils::cache::MultiLevelCacheManager::getInstance();
m_metadataCache = cacheManager->getSpecializedCache<DatasetMetadataEntry>("metadata_entries");
```

#### 4.2.2 元数据缓存策略实现
- [ ] 实现基于文件修改时间的缓存失效策略
- [ ] 实现基于访问频率的缓存优先级
- [ ] 配置合理的缓存大小和TTL

#### 4.2.3 缓存预热机制
- [ ] 实现常用元数据的预加载
- [ ] 实现目录扫描结果的预缓存
- [ ] 配置智能预热策略

### 4.3 测试验证
- [ ] 功能测试：缓存命中和失效机制
- [ ] 性能测试：元数据访问性能提升
- [ ] 内存测试：缓存内存使用合理性
- [ ] 一致性测试：缓存数据一致性

### 4.4 问题排查清单
- [ ] 如果缓存失效过于频繁，调整TTL策略
- [ ] 如果内存使用过高，调整缓存大小
- [ ] 如果数据不一致，检查失效机制

## 5. 集成测试和验证

### 5.1 功能完整性测试
- [ ] 元数据提取功能正常工作
- [ ] 后台任务调度正常
- [ ] 缓存功能正常
- [ ] SQLite存储功能正常

### 5.2 性能验证
- [ ] 编译时间显著减少
- [ ] 元数据访问性能提升10-15%
- [ ] 后台任务执行效率提升
- [ ] 内存使用优化

### 5.3 兼容性验证
- [ ] 与其他服务模块的接口兼容
- [ ] 现有客户端代码无需修改
- [ ] 数据库schema保持兼容

### 5.4 稳定性测试
- [ ] 长时间运行无内存泄漏
- [ ] 高并发场景下系统稳定
- [ ] 异常情况下优雅降级

## 6. 特殊问题处理

### 6.1 boost::future兼容性
- [ ] 确保与其他模块的boost::future使用一致
- [ ] 验证异步接口的行为保持不变
- [ ] 测试future链式调用的正确性

### 6.2 SQLite集成优化
- [ ] 验证SQLite连接池的正确使用
- [ ] 确保事务处理的正确性
- [ ] 优化SQL查询性能

### 6.3 元数据提取优化
- [ ] 优化大文件的元数据提取性能
- [ ] 实现增量元数据更新
- [ ] 添加元数据提取进度监控

## 7. 文档更新

### 7.1 技术文档
- [ ] 更新Metadata服务架构文档
- [ ] 更新编译配置说明
- [ ] 更新性能优化说明

### 7.2 API文档
- [ ] 确认API文档无需更新（接口保持不变）
- [ ] 更新缓存配置说明
- [ ] 添加任务调度配置说明

### 7.3 运维文档
- [ ] 更新部署配置说明
- [ ] 更新监控配置指南
- [ ] 更新故障排查手册

## 8. 回退方案

### 8.1 回退触发条件
- [ ] 编译问题无法解决
- [ ] 功能异常或不稳定
- [ ] 性能显著下降
- [ ] 与其他模块兼容性问题

### 8.2 回退步骤
- [ ] 恢复原有的编译配置
- [ ] 恢复原有的后台任务管理
- [ ] 恢复原有的缓存机制
- [ ] 验证回退后功能正常

### 8.3 问题分析
- [ ] 记录回退原因和问题详情
- [ ] 分析重构方案的不足
- [ ] 制定改进计划

## 9. 成功标准检查

### 9.1 功能标准
- [ ] ✅ 编译错误完全解决
- [ ] ✅ 所有现有功能正常工作
- [ ] ✅ 接口保持向后兼容
- [ ] ✅ 新增任务调度和缓存优化功能正常

### 9.2 性能标准
- [ ] ✅ 编译时间显著减少
- [ ] ✅ 元数据访问性能提升10-15%
- [ ] ✅ 后台任务执行效率提升
- [ ] ✅ 内存使用优化

### 9.3 质量标准
- [ ] ✅ 代码重复率降低
- [ ] ✅ 单元测试覆盖率保持或提升
- [ ] ✅ 集成测试全部通过

### 9.4 维护标准
- [ ] ✅ 统一的任务调度管理
- [ ] ✅ 完整的缓存管理
- [ ] ✅ 简化的依赖管理

## 10. 风险监控

### 10.1 技术风险监控
- [ ] 持续监控编译状态
- [ ] 监控性能指标
- [ ] 监控内存使用趋势
- [ ] 监控错误率和异常

### 10.2 业务风险监控
- [ ] 监控元数据提取服务可用性
- [ ] 监控响应时间
- [ ] 监控数据一致性

### 10.3 运维风险监控
- [ ] 监控系统资源使用
- [ ] 监控SQLite数据库状态
- [ ] 监控配置变更影响

## 11. 后续优化计划

### 11.1 短期优化（1个月内）
- [ ] 基于监控数据调优缓存策略
- [ ] 优化元数据提取算法
- [ ] 修复发现的性能瓶颈

### 11.2 中期优化（3个月内）
- [ ] 实现更智能的缓存预热
- [ ] 添加更多性能监控指标
- [ ] 优化SQLite查询性能

### 11.3 长期规划（6个月内）
- [ ] 评估分布式元数据存储方案
- [ ] 考虑NoSQL数据库支持
- [ ] 探索机器学习辅助的元数据提取 