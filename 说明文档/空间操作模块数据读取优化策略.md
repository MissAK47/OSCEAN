# ç©ºé—´æ“ä½œæ¨¡å—æ•°æ®è¯»å–ä¼˜åŒ–ç­–ç•¥

## ğŸš€ æ¦‚è¿°

æœ¬æ–‡æ¡£åˆ†æç©ºé—´æ“ä½œæ¨¡å—(`spatial_ops_service`)åœ¨NetCDFæ–‡ä»¶æ•°æ®è¯»å–ä¼˜åŒ–ä¸­çš„å…³é”®ä½œç”¨ï¼Œæå‡ºç°æœ‰æ¨¡å—çš„é‡æ„ä¼˜åŒ–å»ºè®®ï¼Œå¹¶æ˜ç¡®ç©ºé—´åŠŸèƒ½ä¸æ•°æ®è¯»å–æµç¨‹çš„é›†æˆç­–ç•¥ã€‚

## ğŸ“Š ç°æœ‰ç©ºé—´æ¨¡å—åŠŸèƒ½åˆ†æ

### 1. ç°æœ‰æ¶æ„è¯„ä¼°

**âœ… å·²å…·å¤‡çš„æ ¸å¿ƒåŠŸèƒ½:**
- å®Œæ•´çš„å‡ ä½•è¿ç®—å¼•æ“ (ç¼“å†²åŒºã€äº¤é›†ã€å¹¶é›†ã€å·®é›†)
- ç©ºé—´å…³ç³»æŸ¥è¯¢å¼•æ“ (ç›¸äº¤ã€åŒ…å«ã€æœ€è¿‘é‚»)
- æ …æ ¼æ“ä½œèƒ½åŠ› (è£å‰ªã€é‡é‡‡æ ·ã€æ …æ ¼åŒ–)
- ç©ºé—´ç´¢å¼•ç®¡ç†å™¨ (R-treeã€Quadtreeã€Gridç´¢å¼•)
- ç½‘æ ¼å•å…ƒæŸ¥æ‰¾åŠŸèƒ½ (`findGridCell`)

**âŒ ç¼ºå¤±çš„ä¼˜åŒ–å…³é”®åŠŸèƒ½:**
- **ç©ºé—´åˆ†å—ç­–ç•¥å™¨** - ç¼ºå°‘æ™ºèƒ½ç©ºé—´åˆ†å—ç®—æ³•
- **ç©ºé—´ç¼“å­˜ä¼˜åŒ–å™¨** - ç¼ºå°‘åŸºäºç©ºé—´å±€éƒ¨æ€§çš„ç¼“å­˜ç­–ç•¥
- **å¹¶è¡Œç©ºé—´è®¡ç®—è°ƒåº¦å™¨** - ç¼ºå°‘NUMAæ„ŸçŸ¥çš„ç©ºé—´å¹¶è¡Œè®¡ç®—
- **ç©ºé—´é¢„å–å¼•æ“** - ç¼ºå°‘åŸºäºç©ºé—´æ¨¡å¼çš„æ•°æ®é¢„å–
- **å¼‚æ­¥ç©ºé—´æµæ°´çº¿** - ç°æœ‰æ¥å£æ˜¯å¼‚æ­¥çš„ï¼Œä½†ç¼ºå°‘æµæ°´çº¿ä¼˜åŒ–

### 2. å½“å‰æ¥å£èƒ½åŠ›è¯„ä¼°

```cpp
// âœ… ç°æœ‰å¼ºå¤§åŠŸèƒ½
class ISpatialOpsService {
    // ç½‘æ ¼å®šä½èƒ½åŠ› - å…³é”®åŠŸèƒ½
    virtual boost::future<std::optional<GridIndex>> findGridCell(
        const Point& point, const GridDefinition& gridDef) = 0;
    
    // ç©ºé—´æŸ¥è¯¢èƒ½åŠ›
    virtual boost::future<FeatureCollection> queryByBoundingBox(
        const FeatureCollection& features, const BoundingBox& bbox) const = 0;
    
    // æ …æ ¼è£å‰ªèƒ½åŠ›
    virtual boost::future<std::shared_ptr<GridData>> clipRaster(
        std::shared_ptr<GridData> source, const Geometry& clipGeom) = 0;
    
    // æ …æ ¼é‡é‡‡æ ·èƒ½åŠ›
    virtual boost::future<std::shared_ptr<GridData>> resampleRaster(
        std::shared_ptr<GridData> source, const ResampleOptions& options) = 0;
};
```

## ğŸ¯ ç©ºé—´æ¨¡å—åœ¨æ•°æ®è¯»å–ä¼˜åŒ–ä¸­çš„å…³é”®ä½œç”¨

### 1. ç©ºé—´åˆ†å—ä¸ç´¢å¼•ä¼˜åŒ–

#### 1.1 æ™ºèƒ½ç©ºé—´åˆ†å—ç­–ç•¥
```cpp
namespace spatial_read_optimization {

/**
 * @brief ç©ºé—´åˆ†å—ç­–ç•¥å™¨ - æ–°å¢åŠŸèƒ½
 */
class SpatialChunkingOptimizer {
public:
    /**
     * @brief åŸºäºæŸ¥è¯¢æ¨¡å¼çš„è‡ªé€‚åº”åˆ†å—
     * @param queryRegion æŸ¥è¯¢åŒºåŸŸ
     * @param dataExtent æ•°æ®èŒƒå›´
     * @param queryType æŸ¥è¯¢ç±»å‹ (ç‚¹/çº¿/é¢/ä½“)
     * @return ä¼˜åŒ–çš„åˆ†å—æ–¹æ¡ˆ
     */
    virtual ChunkingStrategy optimizeChunking(
        const BoundingBox& queryRegion,
        const BoundingBox& dataExtent,
        QueryType queryType) = 0;
    
    /**
     * @brief åŸºäºæ–‡ä»¶ç»“æ„çš„åˆ†å—å¯¹é½
     * @param fileChunkSize NetCDFæ–‡ä»¶å†…éƒ¨åˆ†å—å¤§å°
     * @param queryBounds æŸ¥è¯¢è¾¹ç•Œ
     * @return å¯¹é½çš„åˆ†å—è¾¹ç•Œ
     */
    virtual std::vector<BoundingBox> alignWithFileChunks(
        const GridDefinition& fileChunkSize,
        const BoundingBox& queryBounds) = 0;
};

/**
 * @brief åˆ†å—ç­–ç•¥ç±»å‹
 */
enum class ChunkingStrategy {
    UNIFORM_GRID,      // å‡åŒ€ç½‘æ ¼åˆ†å—
    ADAPTIVE_QUAD,     // è‡ªé€‚åº”å››å‰æ ‘åˆ†å—
    HILBERT_CURVE,     // å¸Œå°”ä¼¯ç‰¹æ›²çº¿åˆ†å—
    QUERY_ALIGNED      // æŸ¥è¯¢å¯¹é½åˆ†å—
};

/**
 * @brief åˆ†å—ä¼˜åŒ–ç»“æœ
 */
struct ChunkingResult {
    std::vector<BoundingBox> chunks;         // åˆ†å—è¾¹ç•Œåˆ—è¡¨
    ChunkingStrategy strategy;               // ä½¿ç”¨çš„ç­–ç•¥
    double estimatedPerformanceGain;         // é¢„ä¼°æ€§èƒ½æå‡
    size_t memoryFootprint;                  // å†…å­˜å ç”¨
    std::vector<int> readPriority;           // è¯»å–ä¼˜å…ˆçº§
};

} // namespace spatial_read_optimization
```

#### 1.2 ç©ºé—´ç´¢å¼•åŠ é€Ÿæ•°æ®å®šä½
```cpp
/**
 * @brief ç©ºé—´æ•°æ®å®šä½ä¼˜åŒ–å™¨ - æ‰©å±•ç°æœ‰åŠŸèƒ½
 */
class SpatialDataLocator {
public:
    /**
     * @brief æ‰¹é‡å¿«é€Ÿç½‘æ ¼å®šä½
     * @param points æŸ¥è¯¢ç‚¹é›†åˆ
     * @param gridDef ç½‘æ ¼å®šä¹‰
     * @return ç½‘æ ¼ç´¢å¼•æ˜ å°„ (ç‚¹ID -> ç½‘æ ¼ç´¢å¼•)
     */
    virtual std::future<std::unordered_map<size_t, GridIndex>> 
    batchFindGridCells(
        const std::vector<Point>& points,
        const GridDefinition& gridDef) = 0;
    
    /**
     * @brief è·¯å¾„ä¼˜åŒ–çš„å¤šç‚¹å®šä½
     * @param points æœ‰åºç‚¹é›†åˆ (çº¿æ•°æ®)
     * @param gridDef ç½‘æ ¼å®šä¹‰
     * @return ç©ºé—´è¿ç»­çš„ç½‘æ ¼åºåˆ—
     */
    virtual std::future<std::vector<GridIndex>> 
    pathOptimizedLocate(
        const std::vector<Point>& pathPoints,
        const GridDefinition& gridDef) = 0;
    
    /**
     * @brief åŒºåŸŸå†…ç½‘æ ¼å•å…ƒæšä¸¾
     * @param region æŸ¥è¯¢åŒºåŸŸ
     * @param gridDef ç½‘æ ¼å®šä¹‰
     * @return åŒºåŸŸå†…æ‰€æœ‰ç½‘æ ¼ç´¢å¼•
     */
    virtual std::future<std::vector<GridIndex>> 
    enumerateGridCellsInRegion(
        const BoundingBox& region,
        const GridDefinition& gridDef) = 0;
};
```

### 2. ç©ºé—´ç¼“å­˜ä¸é¢„å–ä¼˜åŒ–

#### 2.1 åŸºäºç©ºé—´å±€éƒ¨æ€§çš„ç¼“å­˜ç­–ç•¥
```cpp
/**
 * @brief ç©ºé—´æ„ŸçŸ¥ç¼“å­˜ç®¡ç†å™¨ - æ–°å¢åŠŸèƒ½
 */
class SpatialAwareCacheManager {
public:
    /**
     * @brief åŸºäºç©ºé—´é‚»è¿‘æ€§çš„é¢„å–
     * @param accessPoint å½“å‰è®¿é—®ç‚¹
     * @param accessPattern è®¿é—®æ¨¡å¼
     * @return é¢„å–çš„ç©ºé—´åŒºåŸŸ
     */
    virtual std::future<std::vector<BoundingBox>> 
    spatialPrefetch(
        const Point& accessPoint,
        SpatialAccessPattern accessPattern) = 0;
    
    /**
     * @brief ç©ºé—´çƒ­ç‚¹æ£€æµ‹ä¸ç¼“å­˜
     * @param recentAccesses æœ€è¿‘è®¿é—®è®°å½•
     * @return è¯†åˆ«çš„çƒ­ç‚¹åŒºåŸŸ
     */
    virtual std::vector<BoundingBox> 
    detectSpatialHotspots(
        const std::vector<SpatialAccess>& recentAccesses) = 0;
    
    /**
     * @brief ç©ºé—´ç¼“å­˜å¤±æ•ˆç­–ç•¥
     * @param cacheRegions å½“å‰ç¼“å­˜åŒºåŸŸ
     * @param newAccess æ–°çš„è®¿é—®è¯·æ±‚
     * @return éœ€è¦å¤±æ•ˆçš„ç¼“å­˜åŒºåŸŸ
     */
    virtual std::vector<BoundingBox> 
    spatialEvictionPolicy(
        const std::vector<BoundingBox>& cacheRegions,
        const SpatialAccess& newAccess) = 0;
};

/**
 * @brief ç©ºé—´è®¿é—®æ¨¡å¼
 */
enum class SpatialAccessPattern {
    RANDOM_POINTS,     // éšæœºç‚¹è®¿é—®
    LINEAR_SCAN,       // çº¿æ€§æ‰«æ
    RADIAL_EXPAND,     // æ”¾å°„çŠ¶æ‰©å±•
    CLUSTER_ACCESS,    // èšç±»è®¿é—®
    TEMPORAL_SERIES    // æ—¶é—´åºåˆ—è®¿é—®
};

/**
 * @brief ç©ºé—´è®¿é—®è®°å½•
 */
struct SpatialAccess {
    Point location;                          // è®¿é—®ä½ç½®
    std::chrono::time_point<std::chrono::high_resolution_clock> timestamp;  // è®¿é—®æ—¶é—´
    size_t dataSize;                         // æ•°æ®å¤§å°
    std::chrono::milliseconds duration;      // è®¿é—®è€—æ—¶
    std::string variableName;                // å˜é‡å
};
```

### 3. å¹¶è¡Œç©ºé—´è®¡ç®—ä¼˜åŒ–

#### 3.1 NUMAæ„ŸçŸ¥çš„ç©ºé—´å¹¶è¡Œè®¡ç®—
```cpp
/**
 * @brief å¹¶è¡Œç©ºé—´è®¡ç®—è°ƒåº¦å™¨ - æ‰©å±•ç°æœ‰åŠŸèƒ½
 */
class ParallelSpatialScheduler {
public:
    /**
     * @brief NUMAæ„ŸçŸ¥çš„ç©ºé—´ä»»åŠ¡åˆ†é…
     * @param spatialTasks ç©ºé—´è®¡ç®—ä»»åŠ¡
     * @param numaTopology NUMAæ‹“æ‰‘ä¿¡æ¯
     * @return ä¼˜åŒ–çš„ä»»åŠ¡åˆ†é…æ–¹æ¡ˆ
     */
    virtual TaskAllocationPlan allocateTasksNUMAAware(
        const std::vector<SpatialTask>& spatialTasks,
        const NumaTopology& numaTopology) = 0;
    
    /**
     * @brief åŸºäºç©ºé—´å±€éƒ¨æ€§çš„è´Ÿè½½å‡è¡¡
     * @param workload å½“å‰å·¥ä½œè´Ÿè½½
     * @return å‡è¡¡è°ƒæ•´æ–¹æ¡ˆ
     */
    virtual LoadBalancePlan spatialLoadBalance(
        const SpatialWorkload& workload) = 0;
    
    /**
     * @brief ç©ºé—´è®¡ç®—æµæ°´çº¿ä¼˜åŒ–
     * @param pipeline è®¡ç®—æµæ°´çº¿
     * @return ä¼˜åŒ–çš„å¹¶è¡Œæ‰§è¡Œè®¡åˆ’
     */
    virtual ParallelExecutionPlan optimizeSpatialPipeline(
        const SpatialComputePipeline& pipeline) = 0;
};

/**
 * @brief ç©ºé—´è®¡ç®—ä»»åŠ¡
 */
struct SpatialTask {
    TaskType type;                    // ä»»åŠ¡ç±»å‹
    BoundingBox spatialExtent;        // ç©ºé—´èŒƒå›´
    size_t estimatedComplexity;       // é¢„ä¼°å¤æ‚åº¦
    std::vector<DataDependency> deps; // æ•°æ®ä¾èµ–
    Priority priority;                // ä¼˜å…ˆçº§
};

/**
 * @brief ä»»åŠ¡ç±»å‹
 */
enum class TaskType {
    GRID_LOCATE,        // ç½‘æ ¼å®šä½
    SPATIAL_QUERY,      // ç©ºé—´æŸ¥è¯¢
    RASTER_CLIP,        // æ …æ ¼è£å‰ª
    INTERPOLATION,      // æ’å€¼è®¡ç®—
    COORDINATE_TRANSFORM // åæ ‡è½¬æ¢
};
```

## ğŸ”§ é‡æ„ä¼˜åŒ–å»ºè®®

### 1. å·¥å‚æ¨¡å¼é‡æ„

#### 1.1 ç°æœ‰é—®é¢˜
```cpp
// âŒ å½“å‰å·¥å‚è®¾è®¡è¿‡äºç®€å•
class SpatialOpsServiceFactory {
    static std::unique_ptr<ISpatialOpsService> createService();
    static std::unique_ptr<ISpatialOpsService> createService(const SpatialOpsConfig& config);
};
```

#### 1.2 å»ºè®®çš„é‡æ„æ–¹æ¡ˆ
```cpp
/**
 * @brief å¢å¼ºçš„ç©ºé—´æœåŠ¡å·¥å‚ - æ”¯æŒæ•°æ®è¯»å–ä¼˜åŒ–
 */
class EnhancedSpatialOpsServiceFactory {
public:
    /**
     * @brief åˆ›å»ºæ•°æ®è¯»å–ä¼˜åŒ–çš„ç©ºé—´æœåŠ¡
     * @param config ç©ºé—´æœåŠ¡é…ç½®
     * @param commonServices é€šç”¨æœåŠ¡å·¥å‚
     * @param dataOptimizationProfile æ•°æ®ä¼˜åŒ–é…ç½®
     * @return ä¼˜åŒ–çš„ç©ºé—´æœåŠ¡å®ä¾‹
     */
    static std::unique_ptr<ISpatialOpsService> createForDataReadOptimization(
        const SpatialOpsConfig& config,
        std::shared_ptr<CommonServicesFactory> commonServices,
        const DataReadOptimizationProfile& dataOptimizationProfile);
    
    /**
     * @brief åˆ›å»ºæ”¯æŒç‰¹å®šæŸ¥è¯¢æ¨¡å¼çš„ç©ºé—´æœåŠ¡
     * @param queryPattern æŸ¥è¯¢æ¨¡å¼ (ç‚¹/çº¿/é¢/ä½“)
     * @param performanceProfile æ€§èƒ½é…ç½®
     * @return ä¸“é—¨ä¼˜åŒ–çš„ç©ºé—´æœåŠ¡
     */
    static std::unique_ptr<ISpatialOpsService> createForQueryPattern(
        QueryPattern queryPattern,
        const PerformanceProfile& performanceProfile);
    
    /**
     * @brief åˆ›å»ºé›†æˆæ‰€æœ‰ä¼˜åŒ–ç»„ä»¶çš„ç©ºé—´æœåŠ¡
     * @param dependencies ä¾èµ–æœåŠ¡ (CRSã€æ’å€¼ã€ç¼“å­˜ç­‰)
     * @return å®Œæ•´ä¼˜åŒ–çš„ç©ºé—´æœåŠ¡
     */
    static std::unique_ptr<ISpatialOpsService> createFullyOptimized(
        const ServiceDependencies& dependencies);
};

/**
 * @brief æ•°æ®è¯»å–ä¼˜åŒ–é…ç½®
 */
struct DataReadOptimizationProfile {
    bool enableSpatialChunking = true;
    bool enableSpatialCaching = true;
    bool enableSpatialPrefetch = true;
    bool enableNUMAOptimization = true;
    ChunkingStrategy preferredChunkingStrategy = ChunkingStrategy::ADAPTIVE_QUAD;
    size_t maxSpatialCacheSize = 512 * 1024 * 1024; // 512MB
};

/**
 * @brief æŸ¥è¯¢æ¨¡å¼
 */
enum class QueryPattern {
    POINT_QUERIES,          // ç‚¹æŸ¥è¯¢ä¼˜åŒ–
    LINE_QUERIES,           // çº¿æŸ¥è¯¢ä¼˜åŒ–
    REGION_QUERIES,         // åŒºåŸŸæŸ¥è¯¢ä¼˜åŒ–
    VOLUME_QUERIES,         // ä½“æŸ¥è¯¢ä¼˜åŒ–
    MIXED_QUERIES           // æ··åˆæŸ¥è¯¢ä¼˜åŒ–
};
```

### 2. å¼‚æ­¥æ¡†æ¶é‡æ„

#### 2.1 ç°æœ‰å¼‚æ­¥æ¥å£å¢å¼º
```cpp
/**
 * @brief å¢å¼ºçš„å¼‚æ­¥ç©ºé—´æœåŠ¡æ¥å£
 */
class IAsyncSpatialOpsService : public ISpatialOpsService {
public:
    // åŸæœ‰å¼‚æ­¥æ¥å£ä¿æŒä¸å˜ï¼Œæ–°å¢ä¼˜åŒ–ç‰ˆæœ¬
    
    /**
     * @brief å¹¶è¡Œæ‰¹é‡ç½‘æ ¼å®šä½ - æ€§èƒ½ä¼˜åŒ–ç‰ˆæœ¬
     * @param points æŸ¥è¯¢ç‚¹é›†åˆ
     * @param gridDef ç½‘æ ¼å®šä¹‰
     * @param parallelism å¹¶è¡Œåº¦æ§åˆ¶
     * @return æ‰¹é‡ç»“æœçš„future
     */
    virtual boost::future<std::vector<std::optional<GridIndex>>> 
    findGridCellsBatch(
        const std::vector<Point>& points,
        const GridDefinition& gridDef,
        ParallelismControl parallelism = ParallelismControl::AUTO) = 0;
    
    /**
     * @brief æµå¼ç©ºé—´æŸ¥è¯¢ - å†…å­˜ä¼˜åŒ–ç‰ˆæœ¬
     * @param features è¦ç´ æµ
     * @param queryGeom æŸ¥è¯¢å‡ ä½•
     * @param callback ç»“æœå›è°ƒ
     * @return æµå¼å¤„ç†çš„future
     */
    virtual boost::future<void> 
    queryByGeometryStreaming(
        AsyncFeatureStream& features,
        const Geometry& queryGeom,
        std::function<void(const Feature&)> callback) = 0;
    
    /**
     * @brief åˆ†å—æ …æ ¼å¤„ç† - å¤§æ•°æ®ä¼˜åŒ–ç‰ˆæœ¬
     * @param raster å¤§æ …æ ¼æ•°æ®
     * @param operation å¤„ç†æ“ä½œ
     * @param chunkStrategy åˆ†å—ç­–ç•¥
     * @return åˆ†å—å¤„ç†ç»“æœ
     */
    virtual boost::future<std::shared_ptr<GridData>> 
    processRasterChunked(
        std::shared_ptr<GridData> raster,
        RasterOperation operation,
        ChunkingStrategy chunkStrategy = ChunkingStrategy::ADAPTIVE_QUAD) = 0;
};
```

### 3. ä¾èµ–æ³¨å…¥é‡æ„

#### 3.1 å®Œæ•´çš„ä¾èµ–æ³¨å…¥æ¶æ„
```cpp
/**
 * @brief ç©ºé—´æœåŠ¡ä¾èµ–ç®¡ç†å™¨
 */
class SpatialServiceDependencyManager {
public:
    /**
     * @brief æ„é€ å‡½æ•° - å®Œæ•´ä¾èµ–æ³¨å…¥
     */
    SpatialServiceDependencyManager(
        std::shared_ptr<CommonServicesFactory> commonServices,
        std::shared_ptr<ICrsService> crsService,
        std::shared_ptr<IInterpolationService> interpolationService,
        std::shared_ptr<CacheManager> cacheManager,
        std::shared_ptr<AsyncFramework> asyncFramework,
        std::shared_ptr<SIMDManager> simdManager,
        std::shared_ptr<MemoryManager> memoryManager);
    
    /**
     * @brief åˆ›å»ºå®Œå…¨é›†æˆçš„ç©ºé—´æœåŠ¡
     */
    std::unique_ptr<ISpatialOpsService> createIntegratedService(
        const SpatialOpsConfig& config);
    
    /**
     * @brief é…ç½®æœåŠ¡é—´çš„ä¼˜åŒ–é›†æˆ
     */
    void configureServiceIntegration(
        const ServiceIntegrationConfig& integrationConfig);
    
private:
    std::shared_ptr<CommonServicesFactory> commonServices_;
    std::shared_ptr<ICrsService> crsService_;
    std::shared_ptr<IInterpolationService> interpolationService_;
    std::shared_ptr<CacheManager> cacheManager_;
    std::shared_ptr<AsyncFramework> asyncFramework_;
    std::shared_ptr<SIMDManager> simdManager_;
    std::shared_ptr<MemoryManager> memoryManager_;
};

/**
 * @brief æœåŠ¡é›†æˆé…ç½®
 */
struct ServiceIntegrationConfig {
    bool enableCRSServiceIntegration = true;       // CRSæœåŠ¡é›†æˆ
    bool enableInterpolationIntegration = true;   // æ’å€¼æœåŠ¡é›†æˆ
    bool enableCacheServiceIntegration = true;    // ç¼“å­˜æœåŠ¡é›†æˆ
    bool enableSIMDOptimization = true;           // SIMDä¼˜åŒ–
    bool enableAsyncPipelining = true;            // å¼‚æ­¥æµæ°´çº¿
    size_t maxConcurrentTasks = 16;               // æœ€å¤§å¹¶å‘ä»»åŠ¡æ•°
};
```

## ğŸš€ ä¸æ•°æ®è¯»å–æµç¨‹çš„é›†æˆç­–ç•¥

### 1. åœ¨ç‚¹æ•°æ®è¯»å–ä¸­çš„ä½œç”¨

```cpp
/**
 * @brief ç‚¹æ•°æ®è¯»å–ç©ºé—´ä¼˜åŒ–æµç¨‹
 */
class PointDataSpatialOptimizer {
public:
    /**
     * @brief ä¼˜åŒ–ç‚¹æ•°æ®è¯»å–æµç¨‹
     * @param queryPoint æŸ¥è¯¢ç‚¹
     * @param netcdfFile NetCDFæ–‡ä»¶ä¿¡æ¯
     * @param variables å˜é‡åˆ—è¡¨
     * @return ä¼˜åŒ–çš„è¯»å–è®¡åˆ’
     */
    ReadPlan optimizePointDataRead(
        const Point& queryPoint,
        const NetCDFFileInfo& netcdfFile,
        const std::vector<std::string>& variables) {
        
        ReadPlan plan;
        
        // 1. ä½¿ç”¨ç©ºé—´æœåŠ¡å®šä½ç½‘æ ¼å•å…ƒ
        auto gridIndex = spatialService_->findGridCell(queryPoint, netcdfFile.gridDef).get();
        
        // 2. åŸºäºç½‘æ ¼ä½ç½®ä¼˜åŒ–åˆ†å—è¯»å–
        if (gridIndex) {
            plan.chunkBounds = spatialChunker_->calculateOptimalChunk(*gridIndex, variables);
            plan.readStrategy = ReadStrategy::SPATIAL_ALIGNED;
        }
        
        // 3. æ£€æŸ¥ç©ºé—´ç¼“å­˜
        auto cachedData = spatialCache_->checkSpatialCache(queryPoint, CACHE_RADIUS);
        if (cachedData) {
            plan.useCache = true;
            plan.cacheRegion = cachedData->bounds;
        }
        
        return plan;
    }
    
private:
    std::shared_ptr<ISpatialOpsService> spatialService_;
    std::unique_ptr<SpatialChunkingOptimizer> spatialChunker_;
    std::unique_ptr<SpatialAwareCacheManager> spatialCache_;
};
```

### 2. åœ¨çº¿æ•°æ®è¯»å–ä¸­çš„ä½œç”¨

```cpp
/**
 * @brief çº¿æ•°æ®è¯»å–ç©ºé—´ä¼˜åŒ–æµç¨‹
 */
class LineDataSpatialOptimizer {
public:
    /**
     * @brief ä¼˜åŒ–çº¿æ•°æ®è¯»å–æµç¨‹
     * @param pathPoints è·¯å¾„ç‚¹åºåˆ—
     * @param netcdfFile NetCDFæ–‡ä»¶ä¿¡æ¯
     * @return ä¼˜åŒ–çš„è¯»å–è®¡åˆ’
     */
    ReadPlan optimizeLineDataRead(
        const std::vector<Point>& pathPoints,
        const NetCDFFileInfo& netcdfFile) {
        
        ReadPlan plan;
        
        // 1. ä½¿ç”¨ç©ºé—´æœåŠ¡æ‰¹é‡å®šä½ç½‘æ ¼å•å…ƒ
        auto gridIndices = spatialService_->batchFindGridCells(pathPoints, netcdfFile.gridDef).get();
        
        // 2. åŸºäºç©ºé—´è¿ç»­æ€§ä¼˜åŒ–è¯»å–é¡ºåº
        auto optimizedPath = spatialOptimizer_->optimizeReadPath(gridIndices);
        
        // 3. ç”Ÿæˆç©ºé—´è¿ç»­çš„è¯»å–å—
        plan.chunks = spatialChunker_->generateContinuousChunks(optimizedPath);
        plan.readStrategy = ReadStrategy::PATH_OPTIMIZED;
        
        return plan;
    }
    
private:
    std::shared_ptr<ISpatialOpsService> spatialService_;
    std::unique_ptr<SpatialPathOptimizer> spatialOptimizer_;
    std::unique_ptr<SpatialChunkingOptimizer> spatialChunker_;
};
```

### 3. åœ¨é¢æ•°æ®è¯»å–ä¸­çš„ä½œç”¨

```cpp
/**
 * @brief é¢æ•°æ®è¯»å–ç©ºé—´ä¼˜åŒ–æµç¨‹
 */
class RegionDataSpatialOptimizer {
public:
    /**
     * @brief ä¼˜åŒ–åŒºåŸŸæ•°æ®è¯»å–æµç¨‹
     * @param region æŸ¥è¯¢åŒºåŸŸ
     * @param netcdfFile NetCDFæ–‡ä»¶ä¿¡æ¯
     * @return ä¼˜åŒ–çš„è¯»å–è®¡åˆ’
     */
    ReadPlan optimizeRegionDataRead(
        const BoundingBox& region,
        const NetCDFFileInfo& netcdfFile) {
        
        ReadPlan plan;
        
        // 1. ä½¿ç”¨ç©ºé—´æœåŠ¡æšä¸¾åŒºåŸŸå†…ç½‘æ ¼å•å…ƒ
        auto gridCells = spatialService_->enumerateGridCellsInRegion(region, netcdfFile.gridDef).get();
        
        // 2. åŸºäºæ–‡ä»¶ç»“æ„å¯¹é½åˆ†å—
        auto alignedChunks = spatialChunker_->alignWithFileChunks(
            netcdfFile.internalChunking, region);
        
        // 3. ä¼˜åŒ–å†…å­˜ä½¿ç”¨çš„åˆ†å—ç­–ç•¥
        plan.chunks = spatialChunker_->optimizeForMemory(alignedChunks, MAX_MEMORY_BUDGET);
        plan.readStrategy = ReadStrategy::CHUNK_ALIGNED;
        
        return plan;
    }
    
private:
    std::shared_ptr<ISpatialOpsService> spatialService_;
    std::unique_ptr<SpatialChunkingOptimizer> spatialChunker_;
    static constexpr size_t MAX_MEMORY_BUDGET = 256 * 1024 * 1024; // 256MB
};
```

## ğŸ“‹ å®æ–½ä¼˜å…ˆçº§ä¸è®¡åˆ’

### 1. ç¬¬ä¸€é˜¶æ®µï¼šåŸºç¡€é‡æ„ (2-3å‘¨)
1. **å·¥å‚æ¨¡å¼é‡æ„** - æ”¯æŒæ•°æ®è¯»å–ä¼˜åŒ–é…ç½®
2. **ä¾èµ–æ³¨å…¥å®Œå–„** - é›†æˆç°æœ‰CommonServices
3. **å¼‚æ­¥æ¥å£å¢å¼º** - æ‰¹é‡å’Œæµå¼å¤„ç†æ”¯æŒ

### 2. ç¬¬äºŒé˜¶æ®µï¼šæ ¸å¿ƒä¼˜åŒ– (3-4å‘¨)  
1. **ç©ºé—´åˆ†å—ä¼˜åŒ–å™¨** - å®ç°æ™ºèƒ½åˆ†å—ç­–ç•¥
2. **ç©ºé—´ç¼“å­˜ç®¡ç†å™¨** - åŸºäºå±€éƒ¨æ€§çš„ç¼“å­˜
3. **å¹¶è¡Œè®¡ç®—è°ƒåº¦å™¨** - NUMAæ„ŸçŸ¥ä¼˜åŒ–

### 3. ç¬¬ä¸‰é˜¶æ®µï¼šé›†æˆä¼˜åŒ– (2-3å‘¨)
1. **ä¸æ•°æ®è¯»å–æœåŠ¡é›†æˆ** - å®Œæ•´ä¼˜åŒ–æµç¨‹
2. **æ€§èƒ½æµ‹è¯•ä¸è°ƒä¼˜** - è¾¾åˆ°100msç›®æ ‡
3. **æ–‡æ¡£ä¸ç¤ºä¾‹** - ä½¿ç”¨æŒ‡å—

## ğŸ¯ é¢„æœŸæ€§èƒ½æå‡

| ä¼˜åŒ–ç»´åº¦ | å½“å‰æ€§èƒ½ | ç›®æ ‡æ€§èƒ½ | æå‡å€æ•° |
|---------|---------|---------|---------|
| **ç‚¹æ•°æ®å®šä½** | 5-10ms | 1-2ms | **5x** |
| **çº¿æ•°æ®è·¯å¾„ä¼˜åŒ–** | 50-100ms | 10-20ms | **5x** |
| **åŒºåŸŸåˆ†å—è®¡ç®—** | 200-500ms | 50-100ms | **4-5x** |
| **ç©ºé—´ç¼“å­˜å‘½ä¸­ç‡** | 60% | 90%+ | **1.5x** |
| **å¹¶è¡Œè®¡ç®—æ•ˆç‡** | 70% | 95%+ | **1.35x** |

é€šè¿‡è¿™äº›ä¼˜åŒ–ï¼Œç©ºé—´æ“ä½œæ¨¡å—å°†æˆä¸ºNetCDFæ•°æ®è¯»å–ä¼˜åŒ–çš„æ ¸å¿ƒåŠ é€Ÿå™¨ï¼Œç¡®ä¿æ‰€æœ‰ç±»å‹çš„æ•°æ®è¯»å–éƒ½èƒ½åœ¨100mså†…å®Œæˆã€‚ 