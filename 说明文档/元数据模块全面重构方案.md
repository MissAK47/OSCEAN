# 元数据模块全面重构方案

## 📝 **文档更新记录**
- **最新版本**: 2024-01-20 - 基于架构评审反馈的最终修正版本
- **关键修正**: 
  - ✅ 确认统一接口采用**单一文件设计** (`unified_metadata_service.h`)
  - ✅ 确认完全消除服务编排职责，专注元数据核心业务
  - ✅ 确认100%使用common_utilities基础设施，零重复实现
  - ✅ 确认SQLite3多库架构设计最终方案

## 📋 执行摘要

基于历史设计文档和需求分析，元数据模块需要进行**全面架构重构**，实现从单一服务向**专业化元数据管理服务**的转变。本方案遵循**模块职责单一化**原则，专注于元数据的提取、存储、管理和查询功能。

### 🎯 **重构目标对比**

| 维度 | 现状 | 重构后目标 |
|------|------|------------|
| **架构模式** | 直接实例化、同步调用 | 工厂模式 + 异步 + 依赖注入 |
| **数据库架构** | 单库SQLite | 多库分类管理（海洋环境、地形底质、边界线、声纳传播） |
| **变量识别** | 硬编码变量名 | 参数化配置 + 智能识别 + 人工配置 |
| **查询能力** | 基础文件查询 | 时空变量多维度联合查询 + 智能排序 |
| **元数据分类** | 简单文件分类 | 智能分类 + 手动配置 + 自动更新 |
| **接口模式** | std::future混用 | 100% boost::future + 统一错误处理 |
| **模块职责** | 功能边界模糊 | **专注元数据管理，消除服务编排** |

## 🔍 第一部分：架构重构详细方案

### 1.1 **纯粹元数据服务架构设计**

#### **现状架构问题**
```cpp
// ❌ 当前问题架构
class MetadataServiceImpl {
    // 直接实例化，紧耦合
    std::unique_ptr<SQLiteStorage> storage_;
    
    // 同步调用，性能瓶颈
    std::optional<FileMetadata> extractMetadata(const std::string& path);
    
    // 混用std::future和boost::future
    std::future<bool> someMethod();
    boost::future<void> anotherMethod();
};
```

#### **重构后目标架构**
```cpp
// ✅ 重构后纯粹元数据服务架构
namespace oscean::core_services::metadata {

// 元数据服务工厂 - 专注于元数据服务创建
class MetadataServiceFactory {
public:
    static std::unique_ptr<MetadataServiceFactory> create(
        std::shared_ptr<common_utils::infrastructure::CommonServicesFactory> commonServices
    );
    
    boost::future<AsyncResult<std::shared_ptr<IMetadataService>>> createServiceAsync(
        const MetadataServiceConfiguration& config
    );

private:
    std::shared_ptr<common_utils::infrastructure::CommonServicesFactory> commonServices_;
    std::shared_ptr<MultiDatabaseManagerFactory> databaseFactory_;
    std::shared_ptr<IntelligentIndexFactory> indexFactory_;
};

// 纯粹元数据服务接口 - 只管理元数据
class IMetadataService {
public:
    // === 元数据提取接口 ===
    virtual boost::future<AsyncResult<ExtractedMetadata>> extractMetadataAsync(
        const std::string& filePath,
        const std::optional<DataTypeHint>& hint = std::nullopt
    ) = 0;
    
    // === 元数据存储接口 ===
    virtual boost::future<AsyncResult<std::string>> storeMetadataAsync(
        const ExtractedMetadata& metadata
    ) = 0;
    
    // === 元数据查询接口 ===
    virtual boost::future<AsyncResult<std::vector<MetadataEntry>>> queryMetadataAsync(
        const MetadataQueryCriteria& criteria
    ) = 0;
    
    // === 元数据管理接口 ===
    virtual boost::future<AsyncResult<void>> updateMetadataAsync(
        const std::string& metadataId,
        const MetadataUpdate& update
    ) = 0;
    
    virtual boost::future<AsyncResult<void>> deleteMetadataAsync(
        const std::string& metadataId
    ) = 0;
    
    // === 配置管理接口 ===
    virtual boost::future<AsyncResult<void>> updateClassificationConfigAsync(
        const VariableClassificationConfig& config
    ) = 0;
    
    // === 服务状态接口 ===
    virtual boost::future<AsyncResult<MetadataServiceStatus>> getServiceStatusAsync() = 0;
};

} // namespace oscean::core_services::metadata
```

### 1.2 **依赖注入容器设计**

```cpp
// 元数据服务依赖容器 - 仅管理元数据服务相关依赖
class MetadataServiceContainer {
public:
    // 注册核心依赖
    void registerCommonServices(std::shared_ptr<common_utils::infrastructure::CommonServicesFactory> factory);
    
    // 创建纯粹的元数据服务
    boost::future<AsyncResult<std::shared_ptr<IMetadataService>>> createMetadataServiceAsync();
    
    // 获取内部组件
    template<typename T>
    std::shared_ptr<T> resolve();

private:
    std::map<std::type_index, std::shared_ptr<void>> dependencies_;
    std::shared_ptr<MetadataServiceConfiguration> configuration_;
};
```

## 🔍 第二部分：功能重构详细方案

### 2.1 **功能边界重新定义 - 消除服务编排**

#### **修正后的功能边界表**

| 功能 | 现状 | 修正后 | 负责模块 | 备注 |
|------|------|--------|----------|------|
| **文件格式解析** | ❌ 元数据服务重复实现 | ✅ 通过接口调用其他服务 | Data Access | 接口调用，不编排 |
| **坐标系转换** | ❌ 元数据服务重复实现 | ✅ 通过接口调用其他服务 | CRS Service | 接口调用，不编排 |
| **元数据识别提取** | ✅ 保留，核心功能 | ✅ 强化，智能识别 | **Metadata Service** | 核心职责 |
| **多库管理** | ❌ 缺失 | ✅ 新增，核心功能 | **Metadata Service** | 核心职责 |
| **智能分类** | ❌ 缺失 | ✅ 新增，AI驱动分类 | **Metadata Service** | 核心职责 |
| **多维度查询** | ❌ 基础查询 | ✅ 时空变量联合查询 | **Metadata Service** | 核心职责 |
| **配置管理** | ❌ 硬编码 | ✅ 参数化+可配置 | **Metadata Service** | 核心职责 |
| **服务编排** | ❌ 错误设计 | ❌ **移除，不属于此层** | **Application Layer** | 职责转移 |

### 2.2 **纯粹元数据服务核心功能**

#### **智能元数据识别与提取系统**
```cpp
namespace oscean::core_services::metadata {

// 智能元数据识别器 - 纯粹的元数据功能
class IntelligentMetadataRecognizer {
public:
    struct RecognitionResult {
        DataType detectedDataType;          // 检测到的数据类型
        double confidence;                  // 置信度 (0-1)
        std::vector<std::string> detectedVariables; // 检测到的变量
        std::map<std::string, std::string> variableMapping; // 变量映射
        SpatialInfo spatialInfo;            // 空间信息
        TemporalInfo temporalInfo;          // 时间信息
        std::vector<std::string> warnings;  // 识别警告
    };
    
    // 智能识别文件元数据 - 不涉及其他服务编排
    boost::future<AsyncResult<RecognitionResult>> recognizeFileAsync(
        const std::string& filePath,
        const RecognitionConfiguration& config = {}
    );
    
    // 批量识别
    boost::future<AsyncResult<std::vector<RecognitionResult>>> recognizeBatchAsync(
        const std::vector<std::string>& filePaths,
        const RecognitionConfiguration& config = {}
    );

private:
    std::shared_ptr<VariableClassifier> variableClassifier_;
    std::shared_ptr<DataTypeClassifier> dataTypeClassifier_;
    std::shared_ptr<SpatialAnalyzer> spatialAnalyzer_;
    std::shared_ptr<TemporalAnalyzer> temporalAnalyzer_;
    
    // 注意：不再包含其他服务的适配器，避免编排职责
};

} // namespace oscean::core_services::metadata
```

### 2.3 **多维度查询系统 - 专注元数据查询**

```cpp
// 纯粹的元数据查询引擎
class MetadataQueryEngine {
public:
    // 多维度元数据查询
    boost::future<AsyncResult<QueryResultSet>> executeQueryAsync(
        const MetadataQueryCriteria& criteria
    );
    
    // 元数据统计分析
    boost::future<AsyncResult<MetadataStatistics>> getMetadataStatisticsAsync(
        const StatisticsRequest& request
    );
    
    // 查询性能分析
    boost::future<AsyncResult<QueryPerformanceReport>> analyzeQueryPerformanceAsync(
        const MetadataQueryCriteria& criteria
    );

private:
    std::shared_ptr<MultiDatabaseQueryExecutor> queryExecutor_;
    std::shared_ptr<MetadataRanking> rankingEngine_;
    std::shared_ptr<StatisticsCalculator> statisticsCalculator_;
    
    // 注意：只处理元数据查询，不涉及跨服务编排
};
```

## 🔍 第三部分：现有代码重构处理方案

### 3.1 **现有文件处理对照表**

#### **直接保留的文件（✅ 无需修改）**
```
core_services_impl/metadata_service/include/core_services/data_access/
└── boost_future_config.h                   # ✅ 保留：boost::future配置完善
```

#### **❌ 删除重复common功能的文件**
```cpp
// ❌ 删除：metadata_cache.h/cpp - 重复common_utilities缓存功能
// 现有实现：
class MetadataCache : public IMetadataCache {
    // ❌ 重复实现了LRU缓存、过期时间管理等common已有功能
    std::unordered_map<std::string, CacheEntry> _cacheMap;
    std::list<std::string> _lruOrder;
    std::mutex _mutex;
};

// ✅ 使用common_utilities缓存
namespace oscean::core_services::metadata::impl {

class MetadataServiceImpl {
private:
    // 使用common的缓存工厂，不自己实现
    std::shared_ptr<common_utils::infrastructure::ICache<std::string, DatasetMetadataEntry>> metadataCache_;
    std::shared_ptr<common_utils::infrastructure::ICache<std::string, std::vector<DatasetMetadataEntry>>> queryCache_;
    
public:
    MetadataServiceImpl(std::shared_ptr<common_utils::infrastructure::CommonServicesFactory> commonServices) {
        // 使用common的缓存服务，而不是自己实现
        metadataCache_ = commonServices->createCache<std::string, DatasetMetadataEntry>(
            common_utils::infrastructure::CacheConfig{
                .maxSize = 1000,
                .ttl = std::chrono::minutes(30),
                .evictionPolicy = common_utils::infrastructure::EvictionPolicy::LRU
            }
        );
        
        queryCache_ = commonServices->createCache<std::string, std::vector<DatasetMetadataEntry>>(
            common_utils::infrastructure::CacheConfig{
                .maxSize = 500,
                .ttl = std::chrono::minutes(15),
                .evictionPolicy = common_utils::infrastructure::EvictionPolicy::LRU
            }
        );
    }
};

} // namespace oscean::core_services::metadata::impl
```

#### **保留并改进的文件（🔧 专注元数据逻辑）**
```cpp
// 🔧 metadata_extractor.h/cpp - 保留元数据提取逻辑，使用common异步框架
class MetadataExtractor {
public:
    MetadataExtractor(
        std::shared_ptr<IRawDataAccessService> rawDataAccessService,
        std::shared_ptr<common_utils::infrastructure::CommonServicesFactory> commonServices
    ) : rawDataAccessService_(rawDataAccessService),
        asyncExecutor_(commonServices->getAsyncExecutor()),  // ✅ 使用common异步执行器
        logger_(commonServices->getLogger("MetadataExtractor")) {}  // ✅ 使用common日志
    
    // 专注元数据提取逻辑，使用common异步框架
    boost::future<AsyncResult<IntelligentRecognitionResult>> extractWithIntelligentAnalysisAsync(
        const std::string& filePath,
        const IntelligentRecognitionConfig& config = {}
    ) {
        return asyncExecutor_->executeAsync([=]() {
            // 专注元数据识别逻辑，不重复实现异步框架
            return performIntelligentRecognition(filePath, config);
        });
    }

private:
    std::shared_ptr<IRawDataAccessService> rawDataAccessService_;
    std::shared_ptr<common_utils::async::IAsyncExecutor> asyncExecutor_;  // ✅ 使用common异步
    std::shared_ptr<common_utils::logging::ILogger> logger_;  // ✅ 使用common日志
    
    // ❌ 删除：不再自己实现异步、缓存、内存管理等
    // std::shared_ptr<boost::asio::thread_pool> threadPool_;
    // std::unique_ptr<boost::asio::steady_timer> timer_;
};
```

```cpp
// 🔧 dataset_metadata_registry.h/cpp - 专注注册逻辑，使用common基础设施
class DatasetMetadataRegistry {
public:
    DatasetMetadataRegistry(
        std::shared_ptr<IDatasetMetadataRegistryBackend> backend,
        std::shared_ptr<common_utils::infrastructure::CommonServicesFactory> commonServices
    ) : backend_(backend),
        performanceMonitor_(commonServices->getPerformanceMonitor()),  // ✅ 使用common性能监控
        logger_(commonServices->getLogger("DatasetRegistry")) {}  // ✅ 使用common日志
    
    // 专注注册逻辑，性能监控使用common
    boost::future<AsyncResult<bool>> registerDatasetAsync(const DatasetMetadataEntry& entry) {
        auto timer = performanceMonitor_->startTimer("dataset_registration");  // ✅ 使用common监控
        
        return backend_->addOrUpdateDatasetAsync(entry)
            .then([timer](bool result) {
                timer->stop();  // ✅ 使用common性能统计
                return result;
            });
    }

private:
    std::shared_ptr<IDatasetMetadataRegistryBackend> backend_;
    std::shared_ptr<common_utils::performance::IPerformanceMonitor> performanceMonitor_;  // ✅ 使用common
    std::shared_ptr<common_utils::logging::ILogger> logger_;  // ✅ 使用common
    
    // ❌ 删除：不再重复实现性能监控、日志等功能
};
```

#### **需要重大重构的文件（🔥 使用common基础设施）**

```cpp
// 🔥 metadata_service_impl.h/cpp - 使用common基础设施，专注元数据管理

class MetadataServiceImpl : public IMetadataService {
public:
    static std::shared_ptr<MetadataServiceImpl> create(
        std::shared_ptr<MetadataServiceContainer> container
    );
    
    // 并发查询：使用common异步框架
    boost::future<AsyncResult<std::vector<MetadataEntry>>> queryMetadataAsync(
        const MetadataQueryCriteria& criteria
    ) override {
        // ✅ 使用common异步执行器进行并发查询
        std::vector<boost::future<std::vector<MetadataEntry>>> futures;
        
        auto targetDatabases = determineTargetDatabases(criteria);
        
        for (auto dbType : targetDatabases) {
            // 使用common异步执行器并发查询每个数据库
            auto future = asyncExecutor_->executeAsync([=]() {
                auto storage = multiDbManager_->getStorageForType(dbType);
                return storage->findDatasets(criteria);
            });
            futures.push_back(std::move(future));
        }
        
        // ✅ 使用common的future组合
        return common_utils::async::when_all(futures)
            .then([this](auto results) {
                return mergeAndRankResults(results);  // 专注元数据业务逻辑
            });
    }

private:
    // ✅ 使用common服务，不重复实现
    std::shared_ptr<common_utils::async::IAsyncExecutor> asyncExecutor_;
    std::shared_ptr<common_utils::infrastructure::ICache<std::string, DatasetMetadataEntry>> metadataCache_;
    std::shared_ptr<common_utils::logging::ILogger> logger_;
    std::shared_ptr<common_utils::performance::IPerformanceMonitor> performanceMonitor_;
    
    // 专注元数据服务组件
    std::shared_ptr<MultiDatabaseManager> multiDbManager_;
    std::shared_ptr<IntelligentMetadataRecognizer> recognizer_;
    std::shared_ptr<MetadataQueryEngine> queryEngine_;
    std::shared_ptr<VariableClassificationManager> classificationManager_;
    
    // ❌ 删除：不再重复实现common功能
    // std::shared_ptr<boost::asio::thread_pool> _threadPool;
    // std::unique_ptr<boost::asio::steady_timer> _cacheCleanupTimer;
    // std::atomic<bool> _backgroundTaskRunning{false};
    // 缓存相关的自定义实现全部删除
};
```

### 3.2 **多库并发查询架构设计**

#### **使用common异步框架的并发查询**
```cpp
// 多库并发查询管理器 - 使用common异步基础设施
class MultiDatabaseQueryEngine {
public:
    MultiDatabaseQueryEngine(
        std::shared_ptr<MultiDatabaseManager> dbManager,
        std::shared_ptr<common_utils::infrastructure::CommonServicesFactory> commonServices
    ) : dbManager_(dbManager),
        asyncExecutor_(commonServices->getAsyncExecutor()),  // ✅ 使用common异步执行器
        performanceMonitor_(commonServices->getPerformanceMonitor()) {}  // ✅ 使用common性能监控
    
    // 并发查询多个数据库
    boost::future<AsyncResult<std::vector<MetadataEntry>>> executeParallelQueryAsync(
        const MetadataQueryCriteria& criteria
    ) {
        auto timer = performanceMonitor_->startTimer("parallel_query");  // ✅ 使用common性能监控
        
        // 确定需要查询的数据库
        auto targetDatabases = determineTargetDatabases(criteria);
        
        if (targetDatabases.empty()) {
            return boost::make_ready_future(AsyncResult<std::vector<MetadataEntry>>::success({}));
        }
        
        // ✅ 使用common异步执行器并发查询
        std::vector<boost::future<QueryResult>> futures;
        futures.reserve(targetDatabases.size());
        
        for (auto dbType : targetDatabases) {
            auto future = asyncExecutor_->executeAsync([=]() -> QueryResult {
                try {
                    auto storage = dbManager_->getStorageForType(dbType);
                    auto results = storage->findDatasets(criteria);
                    return QueryResult::success(dbType, std::move(results));
                } catch (const std::exception& e) {
                    return QueryResult::error(dbType, e.what());
                }
            });
            futures.push_back(std::move(future));
        }
        
        // ✅ 使用common的future组合
        return common_utils::async::when_all(futures)
            .then([timer, this](auto futureResults) -> AsyncResult<std::vector<MetadataEntry>> {
                timer->stop();  // ✅ 性能监控
                
                std::vector<MetadataEntry> allResults;
                std::vector<std::string> errors;
                
                for (auto& futureResult : futureResults) {
                    auto result = futureResult.get();
                    if (result.isSuccess()) {
                        auto& dbResults = result.getData();
                        allResults.insert(allResults.end(), dbResults.begin(), dbResults.end());
                    } else {
                        errors.push_back(result.getError());
                    }
                }
                
                // 智能排序和去重（专注元数据业务逻辑）
                auto rankedResults = rankAndDeduplicateResults(allResults);
                
                if (!errors.empty() && allResults.empty()) {
                    return AsyncResult<std::vector<MetadataEntry>>::failure(
                        "All database queries failed: " + boost::algorithm::join(errors, "; ")
                    );
                }
                
                return AsyncResult<std::vector<MetadataEntry>>::success(std::move(rankedResults));
            });
    }
    
    // 智能数据库路由 - 根据查询条件确定目标数据库
    std::vector<DatabaseType> determineTargetDatabases(const MetadataQueryCriteria& criteria) {
        std::vector<DatabaseType> targets;
        
        // 基于查询条件智能路由
        if (criteria.dataTypes.empty()) {
            // 如果没有指定数据类型，查询所有数据库
            targets = {
                DatabaseType::OCEAN_ENVIRONMENT,
                DatabaseType::TOPOGRAPHY_BATHYMETRY,
                DatabaseType::BOUNDARY_LINES,
                DatabaseType::SONAR_PROPAGATION
            };
        } else {
            // 根据数据类型过滤
            for (auto dataType : criteria.dataTypes) {
                auto dbType = mapDataTypeToDatabase(dataType);
                if (std::find(targets.begin(), targets.end(), dbType) == targets.end()) {
                    targets.push_back(dbType);
                }
            }
        }
        
        // 基于变量名智能路由
        if (!criteria.variablesInclude.empty()) {
            auto inferredDbs = inferDatabasesFromVariables(criteria.variablesInclude);
            for (auto db : inferredDbs) {
                if (std::find(targets.begin(), targets.end(), db) == targets.end()) {
                    targets.push_back(db);
                }
            }
        }
        
        return targets;
    }

private:
    struct QueryResult {
        DatabaseType database;
        bool success;
        std::vector<MetadataEntry> data;
        std::string error;
        
        static QueryResult success(DatabaseType db, std::vector<MetadataEntry> results) {
            return {db, true, std::move(results), ""};
        }
        
        static QueryResult error(DatabaseType db, const std::string& err) {
            return {db, false, {}, err};
        }
        
        bool isSuccess() const { return success; }
        const std::vector<MetadataEntry>& getData() const { return data; }
        const std::string& getError() const { return error; }
    };
    
    std::shared_ptr<MultiDatabaseManager> dbManager_;
    std::shared_ptr<common_utils::async::IAsyncExecutor> asyncExecutor_;  // ✅ 使用common异步
    std::shared_ptr<common_utils::performance::IPerformanceMonitor> performanceMonitor_;  // ✅ 使用common监控
    
    // 专注元数据业务逻辑的方法
    std::vector<MetadataEntry> rankAndDeduplicateResults(const std::vector<MetadataEntry>& results);
    DatabaseType mapDataTypeToDatabase(const std::string& dataType);
    std::vector<DatabaseType> inferDatabasesFromVariables(const std::vector<std::string>& variables);
};
```

### 3.3 **清理后的架构设计**

#### **元数据服务只专注核心业务逻辑**
```cpp
namespace oscean::core_services::metadata {

// 纯粹的元数据服务工厂 - 使用common依赖注入
class MetadataServiceFactory {
public:
    static std::shared_ptr<IMetadataService> create(
        std::shared_ptr<common_utils::infrastructure::CommonServicesFactory> commonServices,
        const MetadataServiceConfiguration& config
    ) {
        // ✅ 使用common的依赖注入容器
        auto container = commonServices->createDependencyContainer();
        
        // 注册元数据专用组件
        container->registerSingleton<MultiDatabaseManager>(
            [=]() { return std::make_shared<MultiDatabaseManager>(config.databaseConfig, commonServices); }
        );
        
        container->registerSingleton<IntelligentMetadataRecognizer>(
            [=]() { return std::make_shared<IntelligentMetadataRecognizer>(commonServices); }
        );
        
        container->registerSingleton<MultiDatabaseQueryEngine>(
            [=]() { 
                auto dbManager = container->resolve<MultiDatabaseManager>();
                return std::make_shared<MultiDatabaseQueryEngine>(dbManager, commonServices);
            }
        );
        
        // 创建主服务
        return container->resolve<MetadataServiceImpl>();
    }
};

// 纯粹的元数据服务实现 - 专注业务逻辑
class MetadataServiceImpl : public IMetadataService {
public:
    MetadataServiceImpl(
        std::shared_ptr<MultiDatabaseManager> dbManager,
        std::shared_ptr<IntelligentMetadataRecognizer> recognizer,
        std::shared_ptr<MultiDatabaseQueryEngine> queryEngine,
        std::shared_ptr<common_utils::infrastructure::CommonServicesFactory> commonServices
    ) : dbManager_(dbManager),
        recognizer_(recognizer),
        queryEngine_(queryEngine),
        // ✅ 使用common服务
        metadataCache_(commonServices->createCache<std::string, DatasetMetadataEntry>("metadata_cache", 1000)),
        queryCache_(commonServices->createCache<std::string, std::vector<MetadataEntry>>("query_cache", 500)),
        logger_(commonServices->getLogger("MetadataService")) {}
    
    // 元数据提取 - 专注业务逻辑
    boost::future<AsyncResult<ExtractedMetadata>> extractMetadataAsync(
        const std::string& filePath,
        const std::optional<DataTypeHint>& hint = std::nullopt
    ) override {
        // 先检查缓存 ✅ 使用common缓存
        auto cached = metadataCache_->get(filePath);
        if (cached) {
            logger_->debug("Cache hit for metadata extraction: {}", filePath);
            return boost::make_ready_future(AsyncResult<ExtractedMetadata>::success(*cached));
        }
        
        // 执行智能识别
        return recognizer_->recognizeFileAsync(filePath)
            .then([this, filePath](auto result) -> AsyncResult<ExtractedMetadata> {
                if (result.isSuccess()) {
                    auto extracted = result.getData();
                    // ✅ 使用common缓存存储结果
                    metadataCache_->put(filePath, extracted);
                    logger_->debug("Metadata extracted and cached: {}", filePath);
                    return AsyncResult<ExtractedMetadata>::success(std::move(extracted));
                } else {
                    logger_->warn("Metadata extraction failed: {}", result.getError());
                    return AsyncResult<ExtractedMetadata>::failure(result.getError());
                }
            });
    }
    
    // 并发查询 - 使用专用查询引擎
    boost::future<AsyncResult<std::vector<MetadataEntry>>> queryMetadataAsync(
        const MetadataQueryCriteria& criteria
    ) override {
        // 生成查询缓存键
        auto cacheKey = generateQueryCacheKey(criteria);
        
        // 检查查询缓存 ✅ 使用common缓存
        auto cached = queryCache_->get(cacheKey);
        if (cached) {
            logger_->debug("Cache hit for metadata query");
            return boost::make_ready_future(AsyncResult<std::vector<MetadataEntry>>::success(*cached));
        }
        
        // 执行并发查询
        return queryEngine_->executeParallelQueryAsync(criteria)
            .then([this, cacheKey](auto result) -> AsyncResult<std::vector<MetadataEntry>> {
                if (result.isSuccess()) {
                    auto results = result.getData();
                    // ✅ 使用common缓存存储查询结果
                    queryCache_->put(cacheKey, results);
                    logger_->debug("Query results cached, count: {}", results.size());
                    return AsyncResult<std::vector<MetadataEntry>>::success(std::move(results));
                } else {
                    logger_->warn("Metadata query failed: {}", result.getError());
                    return result;
                }
            });
    }

private:
    // 专注元数据业务组件
    std::shared_ptr<MultiDatabaseManager> dbManager_;
    std::shared_ptr<IntelligentMetadataRecognizer> recognizer_;
    std::shared_ptr<MultiDatabaseQueryEngine> queryEngine_;
    
    // ✅ 使用common基础设施
    std::shared_ptr<common_utils::infrastructure::ICache<std::string, DatasetMetadataEntry>> metadataCache_;
    std::shared_ptr<common_utils::infrastructure::ICache<std::string, std::vector<MetadataEntry>>> queryCache_;
    std::shared_ptr<common_utils::logging::ILogger> logger_;
    
    // 专注业务逻辑的辅助方法
    std::string generateQueryCacheKey(const MetadataQueryCriteria& criteria);
};

} // namespace oscean::core_services::metadata
```

### 3.4 **重构实施优先级修正**

#### **阶段1：清理重复功能（1周）**
1. **删除重复common的文件**
   - 删除 `metadata_cache.h/cpp` 
   - 删除所有自定义异步、线程池、定时器实现
   - 删除自定义性能监控、日志实现

2. **集成common服务**
   - 使用 `common_utils::infrastructure::CommonServicesFactory`
   - 使用 `common_utils::async::IAsyncExecutor` 
   - 使用 `common_utils::infrastructure::ICache`

#### **阶段2：并发查询实现（2周）**
1. 实现 `MultiDatabaseQueryEngine` 使用common异步框架
2. 实现智能数据库路由
3. 优化并发查询性能

#### **阶段3：元数据业务逻辑（2周）**
1. 专注智能元数据识别
2. 实现变量分类和数据类型识别
3. 完善多库管理

#### **阶段4：集成测试（1周）**
1. 并发查询性能测试
2. 多库数据一致性测试
3. 与common服务集成测试

## 🔍 第四部分：数据库配置管理详细方案

### 4.1 **数据库配置管理模块设计**

#### **数据库配置管理接口**
```cpp
namespace oscean::core_services::metadata {

// 数据库配置管理接口
class IDatabaseConfigurationManager {
public:
    virtual boost::future<AsyncResult<void>> updateConfigurationAsync(
        const DatabaseConfiguration& config
    ) = 0;
    
    virtual boost::future<AsyncResult<DatabaseConfiguration>> getConfigurationAsync() = 0;
};

} // namespace oscean::core_services::metadata
```

#### **数据库配置管理实现**
```cpp
namespace oscean::core_services::metadata::impl {

// 数据库配置管理实现
class DatabaseConfigurationManager : public IDatabaseConfigurationManager {
public:
    boost::future<AsyncResult<void>> updateConfigurationAsync(
        const DatabaseConfiguration& config
    ) override;
    
    boost::future<AsyncResult<DatabaseConfiguration>> getConfigurationAsync() override;

private:
    DatabaseConfiguration currentConfiguration_;
};

} // namespace oscean::core_services::metadata::impl
```

### 4.2 **数据库自动更新模块设计**

#### **数据库自动更新接口**
```cpp
namespace oscean::core_services::metadata {

// 数据库自动更新接口
class IAutoUpdateManager {
public:
    virtual boost::future<AsyncResult<void>> updateDatabaseAsync(
        const std::string& databasePath
    ) = 0;
};

} // namespace oscean::core_services::metadata
```

#### **数据库自动更新实现**
```cpp
namespace oscean::core_services::metadata::impl {

// 数据库自动更新实现
class AutoUpdateManager : public IAutoUpdateManager {
public:
    boost::future<AsyncResult<void>> updateDatabaseAsync(
        const std::string& databasePath
    ) override;
};

} // namespace oscean::core_services::metadata::impl
```

## 🎯 **修正后的实施计划**

### Phase 1: 纯粹元数据服务实现 (3周)
1. **核心元数据服务架构**
   - `MetadataServiceFactory`
   - `MetadataServiceContainer`
   - 纯粹异步接口定义

2. **多库架构实现**
   - `MultiDatabaseManager`
   - 四种数据库Schema设计
   - 数据库连接池管理

### Phase 2: 智能元数据功能 (4周)  
3. **智能识别系统**
   - `IntelligentMetadataRecognizer`
   - `VariableClassifier`
   - `SpatialAnalyzer`

4. **配置管理系统**
   - `VariableClassificationManager`
   - YAML配置文件处理
   - 运行时配置更新

### Phase 3: 查询系统实现 (2周)
5. **元数据查询引擎**
   - `MetadataQueryEngine`
   - 多维度查询条件处理
   - 智能排序和推荐

### Phase 4: 应用层集成 (2周)
6. **工作流层实现**
   - `MetadataProcessingWorkflow`（应用层）
   - 服务间协调逻辑
   - 错误处理统一

### Phase 5: 测试和优化 (1周)
7. **全面测试**
   - 单元测试
   - 集成测试
   - 性能测试

## 📊 **修正后的验收标准**

### 架构纯净度验收
- [ ] 100% 元数据服务职责单一
- [ ] 0% 服务编排逻辑在元数据服务中
- [ ] 100% boost::future异步接口  
- [ ] 100% 工厂模式创建服务

### 模块独立性验收
- [ ] 元数据服务可独立测试
- [ ] 元数据服务可独立部署
- [ ] 与其他服务仅通过接口交互
- [ ] 0% 直接依赖其他服务实现

### 功能完整性验收
- [ ] 支持四种数据类型多库管理
- [ ] 智能变量识别准确率 > 95%
- [ ] 元数据查询响应时间 < 200ms
- [ ] 配置热更新支持

---

## 📝 **修正总结**

感谢您指出的架构问题！修正后的方案：

1. **职责明确**：元数据服务专注于元数据管理，不涉及服务编排
2. **层次清晰**：服务编排职责转移到应用层或工作流引擎
3. **接口纯净**：与其他服务仅通过接口交互，不直接依赖
4. **模块独立**：元数据服务可独立开发、测试、部署

这样设计才符合**单一职责原则**和**模块化架构**的最佳实践。 

## 🔍 第五部分：重构后完整目录结构

### 5.1 **重构后目录结构总览**

```
core_services_impl/metadata_service/
├── CMakeLists.txt                                    # CMake构建配置
├── include/                                          # 公共接口头文件
│   └── core_services/
│       ├── data_access/
│       │   └── boost_future_config.h                # ✅ 保留：boost::future配置
│       └── metadata/
│           ├── metadata_service_interface.h         # 元数据服务接口定义
│           ├── metadata_types.h                     # 元数据类型定义
│           ├── query_criteria.h                     # 查询条件定义
│           └── impl/
│               ├── metadata_service_factory.h       # 元数据服务工厂
│               ├── multi_database_manager.h         # 多库管理器
│               ├── intelligent_recognizer.h         # 智能识别器
│               ├── query_engine.h                   # 并发查询引擎
│               ├── variable_classifier.h            # 变量分类器
│               ├── database_types.h                 # 数据库类型定义
│               └── configuration_manager.h          # 配置管理器
├── src/                                             # 实现文件
│   ├── factory/                                     # 工厂实现
│   │   └── metadata_service_factory.cpp            # 服务工厂实现（简化版）
│   ├── core/                                        # 核心服务实现  
│   │   ├── metadata_service_impl.cpp               # 🔥 重构：主服务实现
│   │   ├── metadata_extractor.cpp                  # 🔧 改进：元数据提取器
│   │   └── dataset_metadata_registry.cpp           # 🔧 改进：数据集注册表
│   ├── database/                                    # 数据库管理
│   │   ├── multi_database_manager.cpp              # 多库管理器实现
│   │   ├── database_router.cpp                     # 智能数据库路由
│   │   ├── sqlite_storage_extended.cpp             # 扩展SQLite存储
│   │   └── schema/                                  # 数据库模式
│   │       ├── ocean_environment_schema.sql        # 海洋环境数据库模式
│   │       ├── topography_bathymetry_schema.sql    # 地形底质数据库模式
│   │       ├── boundary_lines_schema.sql           # 边界线数据库模式
│   │       └── sonar_propagation_schema.sql        # 声纳传播数据库模式
│   ├── intelligent/                                 # 智能识别模块
│   │   ├── metadata_recognizer.cpp                 # 智能元数据识别
│   │   ├── variable_classifier.cpp                 # 变量分类器
│   │   ├── data_type_classifier.cpp                # 数据类型分类器
│   │   ├── spatial_analyzer.cpp                    # 空间分析器
│   │   └── temporal_analyzer.cpp                   # 时间分析器
│   ├── query/                                       # 查询引擎
│   │   ├── multi_database_query_engine.cpp         # 并发查询引擎
│   │   ├── query_optimizer.cpp                     # 查询优化器
│   │   ├── result_merger.cpp                       # 结果合并器
│   │   └── ranking_engine.cpp                      # 排序引擎
│   └── configuration/                               # 配置管理
│       ├── configuration_manager.cpp               # 配置管理器
│       ├── variable_classification_config.cpp      # 变量分类配置
│       └── database_configuration.cpp              # 数据库配置
├── config/                                          # 配置文件
│   ├── variable_classification.yaml                # 变量分类配置
│   ├── database_config.yaml                        # 数据库配置
│   └── metadata_service_config.yaml                # 服务配置
├── databases/                                       # 数据库文件目录
│   ├── ocean_environment.db                        # 海洋环境数据库
│   ├── topography_bathymetry.db                    # 地形底质数据库
│   ├── boundary_lines.db                           # 边界线数据库
│   └── sonar_propagation.db                        # 声纳传播数据库
├── tests/                                           # 测试文件
│   ├── unit/                                        # 单元测试
│   │   ├── test_metadata_service.cpp               # 服务测试
│   │   ├── test_multi_database_manager.cpp         # 多库管理测试
│   │   ├── test_intelligent_recognizer.cpp         # 智能识别测试
│   │   ├── test_query_engine.cpp                   # 查询引擎测试
│   │   └── test_variable_classifier.cpp            # 变量分类测试
│   ├── integration/                                 # 集成测试
│   │   ├── test_end_to_end_workflow.cpp            # 端到端测试
│   │   ├── test_concurrent_queries.cpp             # 并发查询测试
│   │   └── test_database_integration.cpp           # 数据库集成测试
│   ├── performance/                                 # 性能测试
│   │   ├── benchmark_concurrent_queries.cpp        # 并发查询基准测试
│   │   └── benchmark_intelligent_recognition.cpp   # 智能识别性能测试
│   ├── mocks/                                       # 测试模拟
│   │   ├── mock_common_services.h                  # Common服务模拟
│   │   └── mock_database_storage.h                 # 数据库存储模拟
│   └── test_data/                                   # 测试数据
│       ├── sample_ocean_data.nc                    # 海洋数据样本
│       ├── sample_topography.tif                   # 地形数据样本
│       └── sample_config.yaml                      # 配置样本
└── docs/                                            # 文档
    ├── api_reference.md                             # API参考文档
    ├── configuration_guide.md                      # 配置指南
    ├── database_schema.md                          # 数据库模式文档
    └── performance_tuning.md                       # 性能调优指南
```

### 5.2 **❌ 已删除的不必要文件**

```
# 以下文件已删除，不属于元数据服务职责：

❌ src/adapters/data_access_adapter.cpp              # 删除：不应适配其他服务
❌ src/adapters/crs_service_adapter.cpp              # 删除：不应适配其他服务
❌ src/adapters/ 目录                                 # 删除：元数据服务不应包含适配器

# 删除过度设计的复杂组件：
❌ src/factory/dependency_container.cpp              # 删除：CommonServicesFactory已提供依赖管理
❌ 复杂的依赖注入容器实现                              # 删除：避免重复实现，保持简单

# 重复的common功能文件：
❌ src/impl/cache/metadata_cache.h                   # 删除：重复LRU缓存实现
❌ src/impl/cache/metadata_cache.cpp                 # 删除：使用common缓存
❌ src/impl/metadata_service_tasks.cpp               # 删除：编译错误，重复异步实现
❌ src/impl/storage/sqlite_storage.h                 # 删除：单库设计过时
❌ src/impl/storage/sqlite_storage.cpp               # 删除：重构为多库管理

# 重复的基础设施实现：
❌ 自定义线程池实现                                    # 使用common异步执行器
❌ 自定义定时器和调度器                                # 使用common调度器
❌ 自定义性能监控                                      # 使用common性能监控
❌ 自定义日志实现                                      # 使用common日志系统
❌ 自定义内存管理                                      # 使用common内存管理
```

### 5.3 **核心文件详细说明**

#### **5.3.1 元数据服务工厂 - 只依赖CommonServicesFactory**

```cpp
// include/core_services/metadata/impl/metadata_service_factory.h
#pragma once
#include "common_utils/infrastructure/common_services_factory.h"  // ✅ 只依赖统一接口
#include "metadata_service_interface.h"

namespace oscean::core_services::metadata {

class MetadataServiceFactory {
public:
    /**
     * @brief 创建元数据服务 - 简化工厂模式，直接使用CommonServicesFactory
     * 
     * 不需要复杂的依赖容器，直接通过CommonServicesFactory获取服务：
     * - 内存管理：memory manager
     * - 异步执行：async executor  
     * - 缓存服务：cache factory
     * - 日志服务：logger
     * - 性能监控：performance monitor
     * 
     * 保持简单直接，避免过度设计
     */
    static std::shared_ptr<IMetadataService> create(
        std::shared_ptr<common_utils::infrastructure::CommonServicesFactory> commonServices,
        const MetadataServiceConfiguration& config
    );

private:
    // 简化的组件创建方法
    static std::shared_ptr<MultiDatabaseManager> createDatabaseManager(
        const MetadataServiceConfiguration& config,
        std::shared_ptr<common_utils::infrastructure::CommonServicesFactory> commonServices
    );
    
    static std::shared_ptr<IntelligentMetadataRecognizer> createRecognizer(
        std::shared_ptr<common_utils::infrastructure::CommonServicesFactory> commonServices
    );
    
    static std::shared_ptr<MultiDatabaseQueryEngine> createQueryEngine(
        std::shared_ptr<MultiDatabaseManager> dbManager,
        std::shared_ptr<common_utils::infrastructure::CommonServicesFactory> commonServices
    );
};

} // namespace oscean::core_services::metadata
```

```cpp
// src/factory/metadata_service_factory.cpp
#include "core_services/metadata/impl/metadata_service_factory.h"
#include "core_services/metadata/impl/metadata_service_impl.h"
#include "core_services/metadata/impl/multi_database_manager.h"
#include "core_services/metadata/impl/intelligent_recognizer.h"
#include "core_services/metadata/impl/query_engine.h"

namespace oscean::core_services::metadata {

std::shared_ptr<IMetadataService> MetadataServiceFactory::create(
    std::shared_ptr<common_utils::infrastructure::CommonServicesFactory> commonServices,
    const MetadataServiceConfiguration& config
) {
    // ✅ 直接使用CommonServicesFactory，无需复杂的依赖容器
    auto logger = commonServices->getLogger("MetadataServiceFactory");
    logger->info("Creating metadata service with configuration: {}", config.toString());
    
    try {
        // 简单直接的组件创建
        auto dbManager = createDatabaseManager(config, commonServices);
        auto recognizer = createRecognizer(commonServices);
        auto queryEngine = createQueryEngine(dbManager, commonServices);
        
        // 直接构造主服务，无需复杂的容器
        auto metadataService = std::make_shared<impl::MetadataServiceImpl>(
            dbManager,
            recognizer, 
            queryEngine,
            commonServices
        );
        
        logger->info("Metadata service created successfully");
        return metadataService;
        
    } catch (const std::exception& e) {
        logger->error("Failed to create metadata service: {}", e.what());
        throw;
    }
}

// 简化的组件创建方法
std::shared_ptr<MultiDatabaseManager> MetadataServiceFactory::createDatabaseManager(
    const MetadataServiceConfiguration& config,
    std::shared_ptr<common_utils::infrastructure::CommonServicesFactory> commonServices
) {
    return std::make_shared<impl::MultiDatabaseManager>(config.databaseConfig, commonServices);
}

std::shared_ptr<IntelligentMetadataRecognizer> MetadataServiceFactory::createRecognizer(
    std::shared_ptr<common_utils::infrastructure::CommonServicesFactory> commonServices
) {
    return std::make_shared<impl::IntelligentMetadataRecognizer>(commonServices);
}

std::shared_ptr<MultiDatabaseQueryEngine> MetadataServiceFactory::createQueryEngine(
    std::shared_ptr<MultiDatabaseManager> dbManager,
    std::shared_ptr<common_utils::infrastructure::CommonServicesFactory> commonServices
) {
    return std::make_shared<impl::MultiDatabaseQueryEngine>(dbManager, commonServices);
}

} // namespace oscean::core_services::metadata
```

#### **5.3.2 主服务实现 - 专注元数据核心业务**

```cpp
// src/core/metadata_service_impl.cpp
#include "metadata_service_impl.h"
#include "common_utils/infrastructure/common_services_factory.h"  // ✅ 只依赖统一接口

namespace oscean::core_services::metadata::impl {

class MetadataServiceImpl : public IMetadataService {
public:
    MetadataServiceImpl(
        std::shared_ptr<MultiDatabaseManager> dbManager,
        std::shared_ptr<IntelligentMetadataRecognizer> recognizer,
        std::shared_ptr<MultiDatabaseQueryEngine> queryEngine,
        std::shared_ptr<common_utils::infrastructure::CommonServicesFactory> commonServices
    ) : dbManager_(dbManager),
        recognizer_(recognizer),
        queryEngine_(queryEngine),
        // ✅ 通过CommonServicesFactory获取所有基础服务
        metadataCache_(commonServices->createCache<std::string, DatasetMetadataEntry>("metadata_cache", 1000)),
        queryCache_(commonServices->createCache<std::string, std::vector<MetadataEntry>>("query_cache", 500)),
        logger_(commonServices->getLogger("MetadataService")),
        asyncExecutor_(commonServices->getAsyncExecutor()),
        performanceMonitor_(commonServices->getPerformanceMonitor()) {}
    
    // 元数据提取 - 纯元数据业务逻辑
    boost::future<AsyncResult<ExtractedMetadata>> extractMetadataAsync(
        const std::string& filePath,
        const std::optional<DataTypeHint>& hint = std::nullopt
    ) override {
        auto timer = performanceMonitor_->startTimer("metadata_extraction");
        
        // 检查缓存
        auto cached = metadataCache_->get(filePath);
        if (cached) {
            logger_->debug("Cache hit for metadata extraction: {}", filePath);
            timer->stop();
            return boost::make_ready_future(AsyncResult<ExtractedMetadata>::success(*cached));
        }
        
        // ✅ 专注元数据识别逻辑，不调用其他业务服务
        return recognizer_->recognizeFileAsync(filePath, hint)
            .then([this, filePath, timer](auto result) -> AsyncResult<ExtractedMetadata> {
                timer->stop();
                
                if (result.isSuccess()) {
                    auto extracted = result.getData();
                    metadataCache_->put(filePath, extracted);
                    logger_->debug("Metadata extracted and cached: {}", filePath);
                    return AsyncResult<ExtractedMetadata>::success(std::move(extracted));
                } else {
                    logger_->warn("Metadata extraction failed: {}", result.getError());
                    return AsyncResult<ExtractedMetadata>::failure(result.getError());
                }
            });
    }
    
    // 并发查询 - 专注元数据查询逻辑
    boost::future<AsyncResult<std::vector<MetadataEntry>>> queryMetadataAsync(
        const MetadataQueryCriteria& criteria
    ) override {
        auto timer = performanceMonitor_->startTimer("metadata_query");
        auto cacheKey = generateQueryCacheKey(criteria);
        
        // 检查查询缓存
        auto cached = queryCache_->get(cacheKey);
        if (cached) {
            logger_->debug("Cache hit for metadata query");
            timer->stop();
            return boost::make_ready_future(AsyncResult<std::vector<MetadataEntry>>::success(*cached));
        }
        
        // 执行并发查询
        return queryEngine_->executeParallelQueryAsync(criteria)
            .then([this, cacheKey, timer](auto result) -> AsyncResult<std::vector<MetadataEntry>> {
                timer->stop();
                
                if (result.isSuccess()) {
                    auto results = result.getData();
                    queryCache_->put(cacheKey, results);
                    logger_->debug("Query results cached, count: {}", results.size());
                    return AsyncResult<std::vector<MetadataEntry>>::success(std::move(results));
                } else {
                    logger_->warn("Metadata query failed: {}", result.getError());
                    return result;
                }
            });
    }

private:
    // 专注元数据业务组件
    std::shared_ptr<MultiDatabaseManager> dbManager_;
    std::shared_ptr<IntelligentMetadataRecognizer> recognizer_;
    std::shared_ptr<MultiDatabaseQueryEngine> queryEngine_;
    
    // ✅ 使用CommonServices统一基础设施
    std::shared_ptr<common_utils::infrastructure::ICache<std::string, DatasetMetadataEntry>> metadataCache_;
    std::shared_ptr<common_utils::infrastructure::ICache<std::string, std::vector<MetadataEntry>>> queryCache_;
    std::shared_ptr<common_utils::infrastructure::logging::ILogger> logger_;
    std::shared_ptr<common_utils::infrastructure::async::IAsyncExecutor> asyncExecutor_;
    std::shared_ptr<common_utils::infrastructure::performance::IPerformanceMonitor> performanceMonitor_;
    
    // 专注业务逻辑的辅助方法
    std::string generateQueryCacheKey(const MetadataQueryCriteria& criteria) {
        // 生成查询缓存键的逻辑
        return "query_" + std::to_string(std::hash<std::string>{}(criteria.toString()));
    }
};

} // namespace oscean::core_services::metadata::impl
```

### 5.4 **CMakeLists.txt 配置修正**

```cmake
# core_services_impl/metadata_service/CMakeLists.txt
cmake_minimum_required(VERSION 3.20)
project(metadata_service)

# 设置C++标准
set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# 查找依赖
find_package(Boost REQUIRED COMPONENTS system filesystem)
find_package(SQLite3 REQUIRED)

# 包含目录
include_directories(
    include
    ${CMAKE_SOURCE_DIR}/common_utilities/include        # ✅ 只依赖common_utilities
    ${CMAKE_SOURCE_DIR}/core_service_interfaces/include # ✅ 只依赖接口定义
)

# 源文件 - 删除了适配器相关文件
set(METADATA_SERVICE_SOURCES
    # 工厂实现
    src/factory/metadata_service_factory.cpp
    
    # 核心服务 - 专注元数据业务
    src/core/metadata_service_impl.cpp
    src/core/metadata_extractor.cpp
    src/core/dataset_metadata_registry.cpp
    
    # 数据库管理 - 元数据专用
    src/database/multi_database_manager.cpp
    src/database/database_router.cpp
    src/database/sqlite_storage_extended.cpp
    
    # 智能识别 - 元数据专用
    src/intelligent/metadata_recognizer.cpp
    src/intelligent/variable_classifier.cpp
    src/intelligent/data_type_classifier.cpp
    src/intelligent/spatial_analyzer.cpp
    src/intelligent/temporal_analyzer.cpp
    
    # 查询引擎 - 元数据专用
    src/query/multi_database_query_engine.cpp
    src/query/query_optimizer.cpp
    src/query/result_merger.cpp
    src/query/ranking_engine.cpp
    
    # 配置管理 - 元数据专用
    src/configuration/configuration_manager.cpp
    src/configuration/variable_classification_config.cpp
    src/configuration/database_configuration.cpp
)

# 创建库
add_library(metadata_service STATIC ${METADATA_SERVICE_SOURCES})

# 链接依赖 - 简化依赖关系
target_link_libraries(metadata_service
    common_utilities                    # ✅ 使用common统一基础设施
    core_service_interfaces            # ✅ 使用接口定义
    ${Boost_LIBRARIES}
    SQLite::SQLite3
)

# 测试
enable_testing()
add_subdirectory(tests)
```

### 5.5 **配置文件结构**

#### **5.5.1 数据库配置**
```yaml
# config/database_config.yaml
database:
  base_path: "./databases"
  connections:
    ocean_environment:
      file: "ocean_environment.db"
      max_connections: 10
      timeout_seconds: 30
    topography_bathymetry:
      file: "topography_bathymetry.db"
      max_connections: 5
      timeout_seconds: 30
    boundary_lines:
      file: "boundary_lines.db"
      max_connections: 5
      timeout_seconds: 30
    sonar_propagation:
      file: "sonar_propagation.db"
      max_connections: 8
      timeout_seconds: 30
```

#### **5.5.2 变量分类配置**
```yaml
# config/variable_classification.yaml
variable_classification:
  ocean_variables:
    current: ["u", "v", "current_speed", "current_direction"]
    temperature: ["temperature", "temp", "sst", "water_temp"]
    salinity: ["salinity", "sal", "psu"]
  topography_variables:
    elevation: ["elevation", "height", "altitude"]
    bathymetry: ["depth", "bathymetry", "seafloor_depth"]
  boundary_variables:
    coastline: ["coastline", "shoreline"]
    administrative: ["boundary", "border", "limit"]
```

这个重构后的目录结构彻底：
- ✅ **消除了重复common功能的文件**
- ✅ **专注元数据核心业务逻辑**  
- ✅ **支持多库并发查询**
- ✅ **提供完整的配置管理**
- ✅ **包含全面的测试覆盖**

每个模块都有明确的职责分工，既保持了架构的纯净性，又提供了强大的元数据管理能力！ 

## 🔍 第六部分：统一接口重构方案

### 📌 **重要确认：单一统一接口文件设计**
> **最终确认**: 基于架构评审，元数据服务采用**单一统一接口文件**设计：
> - ✅ **唯一接口文件**: `core_service_interfaces/include/core_services/metadata/unified_metadata_service.h`
> - ✅ **包含所有定义**: 接口定义 + 类型定义 + 工厂接口 全部在一个文件中
> - ✅ **避免接口分散**: 不再有多个小的接口文件，遵循单一入口原则
> - ✅ **简化依赖关系**: 外部模块只需包含一个头文件即可使用完整服务

### 6.1 **❌ 当前接口问题分析**

#### **接口分散问题**
```
当前状态：接口定义分散在多个位置
├── core_service_interfaces/include/core_services/metadata/
│   ├── i_metadata_service.h              # ❌ 旧接口：同步设计，功能有限
│   ├── idataset_metadata_registry_backend.h  # ❌ 内部实现接口暴露
│   └── i_metadata_cache.h                # ❌ 重复common功能
├── core_services_impl/metadata_service/include/
│   └── metadata_service_interface.h      # ❌ 重复定义接口
└── 各种分散的类型定义                      # ❌ 类型定义不统一
```

#### **现有接口的局限性**
```cpp
// 当前 i_metadata_service.h 的问题：
class IMetadataService {
    // ❌ 同步设计，缺少现代异步支持
    virtual OSCEAN_FUTURE(std::vector<FileInfo>) findFilesAsync(...);
    
    // ❌ 功能有限，缺少智能识别
    virtual OSCEAN_FUTURE(FileMetadata) getFileMetadataAsync(...);
    
    // ❌ 没有多库支持
    // ❌ 没有智能分类
    // ❌ 没有并发查询
    // ❌ 没有变量分类配置
};
```

### 6.2 **✅ 统一接口重构方案**

#### **6.2.1 在core_service_interfaces中定义统一现代化接口**

```cpp
// core_service_interfaces/include/core_services/metadata/unified_metadata_service.h
#pragma once

#include "../common_data_types.h"
#include "common_utils/infrastructure/common_services_factory.h"
#include <boost/future.hpp>

namespace oscean::core_services::metadata {

/**
 * @brief 现代化统一元数据服务接口
 * 
 * 🎯 设计原则：
 * ✅ 统一对外接口 - 所有元数据功能的唯一入口
 * ✅ 100% 异步设计 - 全面使用boost::future
 * ✅ 智能化支持 - 内置AI驱动的识别和分类
 * ✅ 多库架构 - 支持多种数据类型专用数据库
 * ✅ 现代化查询 - 支持复杂的多维度查询
 * ✅ 配置驱动 - 支持运行时配置更新
 */
class IUnifiedMetadataService {
public:
    virtual ~IUnifiedMetadataService() = default;

    // === 🤖 智能元数据识别接口 ===
    
    /**
     * @brief 智能识别文件元数据
     * 
     * 自动识别文件类型、变量、时空范围等，支持：
     * - 海洋环境数据 (u,v,温度,盐度等)
     * - 地形底质数据 (高程,深度等)  
     * - 边界线数据 (海岸线,边界等)
     * - 声纳传播数据 (传感器,模式等)
     */
    virtual boost::future<AsyncResult<IntelligentRecognitionResult>> recognizeFileAsync(
        const std::string& filePath,
        const RecognitionConfiguration& config = {}
    ) = 0;
    
    /**
     * @brief 批量智能识别
     */
    virtual boost::future<AsyncResult<std::vector<IntelligentRecognitionResult>>> recognizeBatchAsync(
        const std::vector<std::string>& filePaths,
        const RecognitionConfiguration& config = {}
    ) = 0;

    // === 💾 元数据存储管理接口 ===
    
    /**
     * @brief 存储元数据到适当的数据库
     * 
     * 自动路由到专用数据库：
     * - ocean_environment.db - 海洋环境数据
     * - topography_bathymetry.db - 地形底质数据
     * - boundary_lines.db - 边界线数据
     * - sonar_propagation.db - 声纳传播数据
     */
    virtual boost::future<AsyncResult<std::string>> storeMetadataAsync(
        const ExtractedMetadata& metadata,
        const StorageOptions& options = {}
    ) = 0;
    
    /**
     * @brief 更新已存储的元数据
     */
    virtual boost::future<AsyncResult<void>> updateMetadataAsync(
        const std::string& metadataId,
        const MetadataUpdate& update
    ) = 0;
    
    /**
     * @brief 删除元数据
     */
    virtual boost::future<AsyncResult<void>> deleteMetadataAsync(
        const std::string& metadataId
    ) = 0;

    // === 🔍 多维度并发查询接口 ===
    
    /**
     * @brief 多维度并发查询
     * 
     * 支持复杂查询条件：
     * - 时间范围查询
     * - 空间范围查询  
     * - 变量名称查询
     * - 数据类型过滤
     * - 传感器联合查询 (platform_id + sensor_id + working_mode_id)
     * - 智能排序和推荐
     */
    virtual boost::future<AsyncResult<std::vector<MetadataEntry>>> queryMetadataAsync(
        const MultiDimensionalQueryCriteria& criteria
    ) = 0;
    
    /**
     * @brief 跨库聚合查询
     */
    virtual boost::future<AsyncResult<AggregatedQueryResult>> aggregateQueryAsync(
        const AggregationQueryCriteria& criteria
    ) = 0;
    
    /**
     * @brief 智能推荐查询
     */
    virtual boost::future<AsyncResult<std::vector<MetadataEntry>>> recommendSimilarAsync(
        const std::string& referenceMetadataId,
        const RecommendationOptions& options = {}
    ) = 0;

    // === 📊 统计分析接口 ===
    
    /**
     * @brief 获取元数据统计信息
     */
    virtual boost::future<AsyncResult<MetadataStatistics>> getStatisticsAsync(
        const StatisticsRequest& request = {}
    ) = 0;
    
    /**
     * @brief 获取时空范围
     */
    virtual boost::future<AsyncResult<SpatioTemporalExtent>> getExtentAsync(
        const std::optional<QueryCriteria>& criteria = std::nullopt
    ) = 0;
    
    /**
     * @brief 获取可用变量列表
     */
    virtual boost::future<AsyncResult<std::vector<VariableInfo>>> getAvailableVariablesAsync(
        const std::optional<QueryCriteria>& criteria = std::nullopt
    ) = 0;

    // === ⚙️ 配置管理接口 ===
    
    /**
     * @brief 更新变量分类配置
     */
    virtual boost::future<AsyncResult<void>> updateVariableClassificationAsync(
        const VariableClassificationConfig& config
    ) = 0;
    
    /**
     * @brief 更新数据库配置
     */
    virtual boost::future<AsyncResult<void>> updateDatabaseConfigurationAsync(
        const DatabaseConfiguration& config
    ) = 0;
    
    /**
     * @brief 获取当前配置
     */
    virtual boost::future<AsyncResult<MetadataServiceConfiguration>> getConfigurationAsync() = 0;

    // === 🔧 服务状态和健康检查接口 ===
    
    /**
     * @brief 获取服务状态
     */
    virtual boost::future<AsyncResult<MetadataServiceStatus>> getServiceStatusAsync() = 0;
    
    /**
     * @brief 执行健康检查
     */
    virtual boost::future<AsyncResult<HealthCheckResult>> performHealthCheckAsync() = 0;
    
    /**
     * @brief 获取性能指标
     */
    virtual boost::future<AsyncResult<PerformanceMetrics>> getPerformanceMetricsAsync() = 0;
};

/**
 * @brief 元数据服务工厂接口
 * 
 * 统一的创建入口，外部只需要这一个工厂
 */
class IMetadataServiceFactory {
public:
    virtual ~IMetadataServiceFactory() = default;
    
    /**
     * @brief 创建统一元数据服务实例
     */
    virtual std::shared_ptr<IUnifiedMetadataService> createService(
        std::shared_ptr<common_utils::infrastructure::CommonServicesFactory> commonServices,
        const MetadataServiceConfiguration& config
    ) = 0;
    
    /**
     * @brief 获取默认配置
     */
    virtual MetadataServiceConfiguration getDefaultConfiguration() const = 0;
};

} // namespace oscean::core_services::metadata
```

#### **6.2.2 现代化数据类型定义**

```cpp
// core_service_interfaces/include/core_services/metadata/metadata_types_v2.h
#pragma once

#include <string>
#include <vector>
#include <map>
#include <optional>
#include <chrono>
#include <boost/future.hpp>

namespace oscean::core_services::metadata {

// === 🤖 智能识别结果类型 ===

/**
 * @brief 智能识别结果
 */
struct IntelligentRecognitionResult {
    std::string filePath;
    DataType detectedDataType;              // OCEAN_ENVIRONMENT, TOPOGRAPHY, etc.
    double confidence;                      // 置信度 0-1
    
    // 识别到的变量信息
    std::vector<VariableInfo> detectedVariables;
    std::map<std::string, std::string> variableMapping;  // 原变量名 -> 标准名
    
    // 时空信息
    SpatialInfo spatialInfo;
    TemporalInfo temporalInfo;
    
    // 质量指标
    double dataQuality;
    double completeness;
    std::vector<std::string> warnings;
    std::vector<std::string> recommendations;
    
    // 分类信息
    std::string suggestedDatabase;          // 建议的目标数据库
    std::map<std::string, std::string> classificationTags;
};

/**
 * @brief 识别配置
 */
struct RecognitionConfiguration {
    bool enableDeepAnalysis = true;         // 启用深度分析
    bool enableVariableMapping = true;     // 启用变量映射
    bool enableQualityAssessment = true;   // 启用质量评估
    std::vector<std::string> preferredVariableNames;  // 优先变量名
    std::optional<DataType> hintDataType;   // 数据类型提示
};

// === 🔍 多维度查询类型 ===

/**
 * @brief 多维度查询条件
 */
struct MultiDimensionalQueryCriteria {
    // 时间维度
    std::optional<TimeRange> timeRange;
    
    // 空间维度  
    std::optional<SpatialBounds> spatialBounds;
    
    // 变量维度
    std::vector<std::string> variablesInclude;
    std::vector<std::string> variablesExclude;
    
    // 数据类型维度
    std::vector<DataType> dataTypes;
    
    // 传感器维度 (声纳数据专用)
    std::optional<SensorCriteria> sensorCriteria;
    
    // 质量维度
    std::optional<QualityCriteria> qualityCriteria;
    
    // 排序和限制
    SortOptions sortOptions;
    std::optional<size_t> limit;
    std::optional<size_t> offset;
};

/**
 * @brief 传感器查询条件
 */
struct SensorCriteria {
    std::optional<std::string> platformId;
    std::optional<std::string> sensorId;
    std::optional<std::string> workingModeId;
    std::optional<TimeRange> deploymentPeriod;
    std::optional<FrequencyRange> frequencyRange;
};

/**
 * @brief 聚合查询结果
 */
struct AggregatedQueryResult {
    std::vector<MetadataEntry> entries;
    StatisticalSummary statisticalSummary;
    std::map<std::string, size_t> distributionByType;
    std::map<std::string, size_t> distributionByVariable;
    TimeSeriesInfo timeSeriesInfo;
    SpatialDistributionInfo spatialDistribution;
};

// === 📊 统计和监控类型 ===

/**
 * @brief 元数据服务状态
 */
struct MetadataServiceStatus {
    bool isHealthy;
    std::string version;
    std::chrono::system_clock::time_point startTime;
    std::chrono::seconds uptime;
    
    // 数据库状态
    std::map<std::string, DatabaseStatus> databaseStatus;
    
    // 性能指标
    PerformanceMetrics currentMetrics;
    
    // 活跃任务
    std::vector<ActiveTask> activeTasks;
};

/**
 * @brief 性能指标
 */
struct PerformanceMetrics {
    // 查询性能
    double averageQueryTimeMs;
    double averageRecognitionTimeMs;
    size_t totalQueries;
    size_t totalRecognitions;
    
    // 缓存性能
    double cacheHitRate;
    size_t cacheSize;
    
    // 并发性能
    size_t activeConcurrentTasks;
    double averageTaskDurationMs;
    
    // 数据库性能
    std::map<std::string, DatabaseMetrics> databaseMetrics;
};

// === 🛡️ 异步结果包装 ===

/**
 * @brief 统一异步结果类型
 */
template<typename T>
class AsyncResult {
public:
    AsyncResult(T data) : data_(std::move(data)), success_(true) {}
    AsyncResult(std::string error) : error_(std::move(error)), success_(false) {}
    
    bool isSuccess() const { return success_; }
    const T& getData() const { 
        if (!success_) throw std::runtime_error("Result is not successful");
        return data_; 
    }
    const std::string& getError() const { return error_; }
    
    static AsyncResult<T> success(T data) { return AsyncResult<T>(std::move(data)); }
    static AsyncResult<T> failure(const std::string& error) { return AsyncResult<T>(error); }

private:
    T data_;
    std::string error_;
    bool success_;
};

} // namespace oscean::core_services::metadata
```

### 6.3 **接口统一实施计划**

#### **Phase 1: 统一接口定义 (1周)**
1. **重构core_service_interfaces**
   - 新建 `unified_metadata_service.h` - 现代化统一接口
   - 新建 `metadata_types_v2.h` - 完整类型定义
   - 标记旧接口为@deprecated

2. **清理分散接口**
   - 删除实现模块中的接口定义重复
   - 统一所有类型定义到interfaces模块

#### **Phase 2: 实现接口适配 (1周)**  
3. **实现统一接口**
   - `UnifiedMetadataServiceImpl` 实现新接口
   - 适配现有功能到新接口
   - 保持向后兼容

#### **Phase 3: 外部模块迁移 (1周)**
4. **更新外部依赖**
   - 所有调用方迁移到新接口
   - 更新文档和示例代码
   - 移除旧接口

### 6.4 **统一接口的优势**

#### **✅ 架构优势**
- **单一入口** - 外部只需依赖一个接口
- **版本控制** - 接口变更统一管理
- **向后兼容** - 渐进式升级支持

#### **✅ 开发优势**  
- **类型安全** - 统一的类型定义
- **文档集中** - 所有接口文档在一处
- **测试简化** - 统一的Mock和测试框架

#### **✅ 维护优势**
- **接口稳定** - 减少接口变更影响面
- **依赖清晰** - 明确的依赖关系
- **升级简单** - 统一的升级路径

---

## 🎉 **重构方案最终确认**

本重构方案已基于架构评审反馈进行最终修正，确保：

1. **架构纯净性** - 元数据服务专注核心业务，不涉及跨服务编排
2. **技术统一性** - 100%使用boost::future，100%依赖common_utilities
3. **接口统一性** - 单一unified_metadata_service.h文件包含完整接口定义
4. **功能完整性** - 支持多库管理、智能识别、并发查询、配置管理

**方案状态**: ✅ **最终确认，可开始实施**