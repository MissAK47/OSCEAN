#include "impl/spatial_config_manager.h"
#include "core_services/spatial_ops/spatial_config.h"
#include <algorithm>
#include <cctype>
#include <fstream>
#include <sstream>
#include <cstdlib>
#include <thread>
#include <iostream>

namespace oscean::core_services::spatial_ops {

// ËæÖÂä©ÂáΩÊï∞ÔºöÊ£ÄÊü•Â≠óÁ¨¶‰∏≤ÊòØÂê¶‰ª•ÊåáÂÆöÂêéÁºÄÁªìÂ∞æ
bool endsWith(const std::string& str, const std::string& suffix) {
    if (suffix.length() > str.length()) return false;
    return str.compare(str.length() - suffix.length(), suffix.length(), suffix) == 0;
}

SpatialConfigManager::SpatialConfigManager() {
    initializeDefaultTemplates();
}

SpatialConfigManager::~SpatialConfigManager() = default;

SpatialOpsConfig SpatialConfigManager::loadFromFile(const std::string& configPath) {
    std::ifstream file(configPath);
    if (!file.is_open()) {
        throw ConfigurationException("Cannot open configuration file: " + configPath);
    }

    std::stringstream buffer;
    buffer << file.rdbuf();
    std::string content = buffer.str();

    SpatialOpsConfig config;
    
    // Â∞ùËØïËß£Êûê‰∏çÂêåÊ†ºÂºè
    if (endsWith(configPath, ".yaml") || endsWith(configPath, ".yml")) {
        if (!parseYamlConfig(content, config)) {
            throw ConfigurationException("Failed to parse YAML configuration file: " + configPath);
        }
    } else if (endsWith(configPath, ".json")) {
        if (!parseJsonConfig(content, config)) {
            throw ConfigurationException("Failed to parse JSON configuration file: " + configPath);
        }
    } else {
        // ÈªòËÆ§Â∞ùËØïYAMLÊ†ºÂºè
        if (!parseYamlConfig(content, config)) {
            throw ConfigurationException("Failed to parse configuration file (unknown format): " + configPath);
        }
    }

    // Â∫îÁî®ÁéØÂ¢ÉÂèòÈáèË¶ÜÁõñ
    loadFromEnvironment(config);
    
    // È™åËØÅÈÖçÁΩÆ
    if (!validateAndFix(config)) {
        throw ConfigurationException("Configuration validation failed for file: " + configPath);
    }

    return config;
}

void SpatialConfigManager::loadFromEnvironment(SpatialOpsConfig& config) {
    applyEnvironmentOverrides(config);
}

bool SpatialConfigManager::saveToFile(const SpatialOpsConfig& config, const std::string& configPath) {
    try {
        std::string content;
        
        if (endsWith(configPath, ".yaml") || endsWith(configPath, ".yml")) {
            content = configToYaml(config);
        } else if (endsWith(configPath, ".json")) {
            content = configToJson(config);
        } else {
            // ÈªòËÆ§‰ΩøÁî®YAMLÊ†ºÂºè
            content = configToYaml(config);
        }

        std::ofstream file(configPath);
        if (!file.is_open()) {
            return false;
        }

        file << content;
        return file.good();
    } catch (const std::exception&) {
        return false;
    }
}

SpatialOpsConfig SpatialConfigManager::getDefaultConfig() {
    SpatialOpsConfig config;
    
    // üîß Ê£ÄÊü•ÁéØÂ¢ÉÂèòÈáèÊòØÂê¶‰∏∫ÂçïÁ∫øÁ®ãÊ®°Âºè
    const char* runMode = std::getenv("OSCEAN_RUN_MODE");
    bool isSingleThreadMode = (runMode && std::string(runMode) == "SINGLE_THREAD");
    
    // Âπ∂Ë°åÈÖçÁΩÆ
    config.parallelSettings.strategy = ParallelStrategy::AUTO;
    if (isSingleThreadMode) {
        // üîß ÂçïÁ∫øÁ®ãÊ®°ÂºèÔºöÂº∫Âà∂‰ΩøÁî®1Á∫øÁ®ã
        config.parallelSettings.maxThreads = 1;
        config.parallelSettings.enableLoadBalancing = false;
        std::cout << "üîß SpatialOpsConfigÈÖçÁΩÆ‰∏∫ÂçïÁ∫øÁ®ãÊ®°Âºè" << std::endl;
    } else {
        // Áîü‰∫ßÊ®°ÂºèÔºöÈôêÂà∂ÊúÄÂ§ßÁ∫øÁ®ãÊï∞
        config.parallelSettings.maxThreads = std::min(std::thread::hardware_concurrency(), 32u);
        config.parallelSettings.enableLoadBalancing = true;
    }
    config.parallelSettings.minDataSizeForParallelism = 1000000;
    config.parallelSettings.chunkSize = 1024 * 1024;
    config.parallelSettings.loadBalanceThreshold = 0.8;
    
    // GDALÈÖçÁΩÆ
    config.gdalSettings.gdalCacheMaxBytes = 512LL * 1024 * 1024; // 512MB
    config.gdalSettings.numThreads = isSingleThreadMode ? "1" : "ALL_CPUS";
    config.gdalSettings.enableGDALOptimizations = true;
    config.gdalSettings.blockCacheSize = 40000000;
    
    // Á¥¢ÂºïÈÖçÁΩÆ
    config.indexSettings.strategy = IndexStrategy::AUTO;
    config.indexSettings.indexThreshold = 1000;
    config.indexSettings.maxIndexDepth = 10;
    config.indexSettings.maxLeafCapacity = 16;
    config.indexSettings.indexBuildRatio = 0.7;
    config.indexSettings.enableIndexCaching = true;
    config.indexSettings.maxCachedIndices = 10;
    
    // ÂÜÖÂ≠òÈÖçÁΩÆ
    config.memorySettings.strategy = MemoryStrategy::AUTO;
    config.memorySettings.maxMemoryUsage = 0; // Êó†ÈôêÂà∂
    config.memorySettings.geometryPoolSize = 1000;
    config.memorySettings.rasterPoolSize = 100;
    config.memorySettings.enableMemoryPooling = false;
    config.memorySettings.enableMemoryMapping = true;
    config.memorySettings.memoryPressureThreshold = 0.85;
    
    // ÁÆóÊ≥ïÈÖçÁΩÆ
    config.algorithmSettings.geometricTolerance = 1e-9;
    config.algorithmSettings.simplificationTolerance = 1e-6;
    config.algorithmSettings.maxIterations = 1000;
    config.algorithmSettings.enableProgressiveRefinement = true;
    config.algorithmSettings.enableApproximateAlgorithms = false;
    config.algorithmSettings.defaultResamplingMethod = "bilinear";
    
    // ÊÄßËÉΩÈÖçÁΩÆ
    config.performanceSettings.enableSpatialIndex = true;
    config.performanceSettings.spatialIndexThreshold = 1000;
    config.performanceSettings.enableMemoryPooling = false;
    config.performanceSettings.enablePerformanceMonitoring = false;
    config.performanceSettings.enableMetricsCollection = false;
    config.performanceSettings.metricsBufferSize = 10000;
    config.performanceSettings.enableProfilingMode = false;
    
    // Êó•ÂøóÈÖçÁΩÆ
    config.loggingSettings.logLevel = "INFO";
    config.loggingSettings.logFormat = "default";
    config.loggingSettings.enableFileLogging = false;
    config.loggingSettings.maxLogFileSize = 100 * 1024 * 1024; // 100MB
    config.loggingSettings.maxLogFiles = 5;
    config.loggingSettings.enableAsyncLogging = true;
    
    // È™åËØÅÈÖçÁΩÆ
    config.validationSettings.enableInputValidation = true;
    config.validationSettings.enableGeometryValidation = true;
    config.validationSettings.enableCRSValidation = true;
    config.validationSettings.enableBoundsChecking = true;
    config.validationSettings.strictMode = false;
    config.validationSettings.validationTolerance = 1e-10;
    
    // ÊúçÂä°Á∫ßÂà´ËÆæÁΩÆ
    config.defaultCRS = "EPSG:4326";
    config.serviceName = "SpatialOpsService";
    config.version = "1.0.0";
    config.enableDebugMode = false;
    config.enableExperimentalFeatures = false;
    
    return config;
}

SpatialOpsConfig SpatialConfigManager::mergeConfigs(const SpatialOpsConfig& base, const SpatialOpsConfig& override) {
    SpatialOpsConfig merged = base;
    
    // ÂêàÂπ∂Âπ∂Ë°åËÆæÁΩÆ
    if (override.parallelSettings.strategy != ParallelStrategy::AUTO) {
        merged.parallelSettings.strategy = override.parallelSettings.strategy;
    }
    if (override.parallelSettings.maxThreads != 0) {
        merged.parallelSettings.maxThreads = override.parallelSettings.maxThreads;
    }
    
    // ÂêàÂπ∂GDALËÆæÁΩÆ
    if (override.gdalSettings.gdalCacheMaxBytes != 256LL * 1024 * 1024) {
        merged.gdalSettings.gdalCacheMaxBytes = override.gdalSettings.gdalCacheMaxBytes;
    }
    if (!override.gdalSettings.numThreads.empty() && override.gdalSettings.numThreads != "ALL_CPUS") {
        merged.gdalSettings.numThreads = override.gdalSettings.numThreads;
    }
    
    // ÂêàÂπ∂Ëá™ÂÆö‰πâÈÄâÈ°π
    for (const auto& [key, value] : override.gdalSettings.gdalOptions) {
        merged.gdalSettings.gdalOptions[key] = value;
    }
    
    // ÂêàÂπ∂ÂÖ∂‰ªñËÆæÁΩÆ...
    if (!override.defaultCRS.empty() && override.defaultCRS != "EPSG:4326") {
        merged.defaultCRS = override.defaultCRS;
    }
    
    return merged;
}

bool SpatialConfigManager::validateAndFix(SpatialOpsConfig& config) {
    bool isValid = true;
    
    // È™åËØÅÂπ∂‰øÆÂ§çÂπ∂Ë°åËÆæÁΩÆ
    if (config.parallelSettings.maxThreads == 0) {
        config.parallelSettings.maxThreads = std::thread::hardware_concurrency();
    }
    if (config.parallelSettings.maxThreads > 1000) {
        config.parallelSettings.maxThreads = 1000;
        isValid = false;
    }
    
    // È™åËØÅÂπ∂‰øÆÂ§çGDALËÆæÁΩÆ
    if (config.gdalSettings.gdalCacheMaxBytes < 0) {
        config.gdalSettings.gdalCacheMaxBytes = 256LL * 1024 * 1024;
        isValid = false;
    }
    
    // È™åËØÅÂπ∂‰øÆÂ§çÂá†‰ΩïÂÆπÂ∑Æ
    if (config.algorithmSettings.geometricTolerance <= 0) {
        config.algorithmSettings.geometricTolerance = 1e-9;
        isValid = false;
    }
    
    return config.validate() && isValid;
}

std::string SpatialConfigManager::configToString(const SpatialOpsConfig& config) const {
    return configToYaml(config);
}

SpatialOpsConfig SpatialConfigManager::configFromString(const std::string& configString) {
    SpatialOpsConfig config;
    if (!parseYamlConfig(configString, config)) {
        throw ConfigurationException("Failed to parse configuration string");
    }
    return config;
}

void SpatialConfigManager::setConfigTemplate(const std::string& templateName, const SpatialOpsConfig& config) {
    m_configTemplates[templateName] = config;
}

SpatialOpsConfig SpatialConfigManager::getConfigTemplate(const std::string& templateName) {
    auto it = m_configTemplates.find(templateName);
    if (it != m_configTemplates.end()) {
        return it->second;
    }
    return getDefaultConfig();
}

std::vector<std::string> SpatialConfigManager::listConfigTemplates() const {
    std::vector<std::string> templates;
    for (const auto& [name, config] : m_configTemplates) {
        templates.push_back(name);
    }
    return templates;
}

void SpatialConfigManager::initializeDefaultTemplates() {
    // È´òÊÄßËÉΩÊ®°Êùø
    auto highPerformanceConfig = getDefaultConfig();
    highPerformanceConfig.parallelSettings.strategy = ParallelStrategy::AUTO;
    highPerformanceConfig.gdalSettings.gdalCacheMaxBytes = 1024LL * 1024 * 1024; // 1GB
    highPerformanceConfig.performanceSettings.enablePerformanceMonitoring = true;
    highPerformanceConfig.algorithmSettings.enableApproximateAlgorithms = true;
    m_configTemplates["high_performance"] = highPerformanceConfig;
    
    // ‰ΩéÂÜÖÂ≠òÊ®°Êùø
    auto lowMemoryConfig = getDefaultConfig();
    lowMemoryConfig.memorySettings.strategy = MemoryStrategy::STANDARD;
    lowMemoryConfig.gdalSettings.gdalCacheMaxBytes = 64LL * 1024 * 1024; // 64MB
    lowMemoryConfig.memorySettings.enableMemoryPooling = true;
    lowMemoryConfig.parallelSettings.maxThreads = 2;
    m_configTemplates["low_memory"] = lowMemoryConfig;
    
    // ÊµãËØïÊ®°Êùø
    auto testConfig = getDefaultConfig();
    testConfig.parallelSettings.strategy = ParallelStrategy::NONE;
    testConfig.parallelSettings.maxThreads = 1;
    testConfig.performanceSettings.enableSpatialIndex = false;
    testConfig.loggingSettings.logLevel = "DEBUG";
    testConfig.validationSettings.strictMode = true;
    m_configTemplates["testing"] = testConfig;
}

bool SpatialConfigManager::parseYamlConfig(const std::string& yamlContent, SpatialOpsConfig& config) {
    // ÁÆÄÂåñÁöÑYAMLËß£ÊûêÂÆûÁé∞
    // Âú®ÂÆûÈôÖÈ°πÁõÆ‰∏≠ÔºåÂ∫îËØ•‰ΩøÁî®‰∏ì‰∏öÁöÑYAMLÂ∫ìÂ¶Çyaml-cpp
    
    std::istringstream stream(yamlContent);
    std::string line;
    
    while (std::getline(stream, line)) {
        // ÁßªÈô§Ê≥®Èáä
        size_t commentPos = line.find('#');
        if (commentPos != std::string::npos) {
            line = line.substr(0, commentPos);
        }
        
        // ÁßªÈô§ÂâçÂêéÁ©∫ÁôΩ
        line.erase(0, line.find_first_not_of(" \t"));
        line.erase(line.find_last_not_of(" \t") + 1);
        
        if (line.empty()) continue;
        
        // ÁÆÄÂçïÁöÑÈîÆÂÄºÂØπËß£Êûê
        size_t colonPos = line.find(':');
        if (colonPos != std::string::npos) {
            std::string key = line.substr(0, colonPos);
            std::string value = line.substr(colonPos + 1);
            
            // ÁßªÈô§Á©∫ÁôΩ
            key.erase(0, key.find_first_not_of(" \t"));
            key.erase(key.find_last_not_of(" \t") + 1);
            value.erase(0, value.find_first_not_of(" \t"));
            value.erase(value.find_last_not_of(" \t") + 1);
            
            // Â∫îÁî®ÈÖçÁΩÆÂÄº
            applyConfigValue(config, key, value);
        }
    }
    
    return true;
}

bool SpatialConfigManager::parseJsonConfig(const std::string& jsonContent, SpatialOpsConfig& config) {
    // ÁÆÄÂåñÁöÑJSONËß£ÊûêÂÆûÁé∞
    // Âú®ÂÆûÈôÖÈ°πÁõÆ‰∏≠ÔºåÂ∫îËØ•‰ΩøÁî®‰∏ì‰∏öÁöÑJSONÂ∫ìÂ¶Çnlohmann/json
    
    // ËøôÈáåÊèê‰æõ‰∏Ä‰∏™Âü∫Êú¨ÁöÑÂÆûÁé∞Ê°ÜÊû∂
    // ÂÆûÈôÖÂÆûÁé∞ÈúÄË¶ÅÂÆåÊï¥ÁöÑJSONËß£ÊûêÂô®
    
    return parseYamlConfig(jsonContent, config); // ‰∏¥Êó∂‰ΩøÁî®YAMLËß£ÊûêÂô®
}

std::string SpatialConfigManager::configToYaml(const SpatialOpsConfig& config) const {
    std::ostringstream yaml;
    
    yaml << "# Spatial Operations Service Configuration\n";
    yaml << "service_name: " << config.serviceName << "\n";
    yaml << "version: " << config.version << "\n";
    yaml << "default_crs: " << config.defaultCRS << "\n\n";
    
    yaml << "# Parallel Processing Configuration\n";
    yaml << "parallel:\n";
    yaml << "  strategy: " << static_cast<int>(config.parallelSettings.strategy) << "\n";
    yaml << "  max_threads: " << config.parallelSettings.maxThreads << "\n";
    yaml << "  min_data_size_for_parallelism: " << config.parallelSettings.minDataSizeForParallelism << "\n";
    yaml << "  chunk_size: " << config.parallelSettings.chunkSize << "\n";
    yaml << "  enable_load_balancing: " << (config.parallelSettings.enableLoadBalancing ? "true" : "false") << "\n\n";
    
    yaml << "# GDAL Configuration\n";
    yaml << "gdal:\n";
    yaml << "  cache_max_bytes: " << config.gdalSettings.gdalCacheMaxBytes << "\n";
    yaml << "  num_threads: " << config.gdalSettings.numThreads << "\n";
    yaml << "  enable_optimizations: " << (config.gdalSettings.enableGDALOptimizations ? "true" : "false") << "\n";
    yaml << "  block_cache_size: " << config.gdalSettings.blockCacheSize << "\n\n";
    
    yaml << "# Logging Configuration\n";
    yaml << "logging:\n";
    yaml << "  log_level: " << config.loggingSettings.logLevel << "\n";
    yaml << "  enable_file_logging: " << (config.loggingSettings.enableFileLogging ? "true" : "false") << "\n";
    yaml << "  max_log_file_size: " << config.loggingSettings.maxLogFileSize << "\n\n";
    
    return yaml.str();
}

std::string SpatialConfigManager::configToJson(const SpatialOpsConfig& config) const {
    std::ostringstream json;
    
    json << "{\n";
    json << "  \"service_name\": \"" << config.serviceName << "\",\n";
    json << "  \"version\": \"" << config.version << "\",\n";
    json << "  \"default_crs\": \"" << config.defaultCRS << "\",\n";
    json << "  \"parallel\": {\n";
    json << "    \"strategy\": " << static_cast<int>(config.parallelSettings.strategy) << ",\n";
    json << "    \"max_threads\": " << config.parallelSettings.maxThreads << ",\n";
    json << "    \"min_data_size_for_parallelism\": " << config.parallelSettings.minDataSizeForParallelism << "\n";
    json << "  },\n";
    json << "  \"gdal\": {\n";
    json << "    \"cache_max_bytes\": " << config.gdalSettings.gdalCacheMaxBytes << ",\n";
    json << "    \"num_threads\": \"" << config.gdalSettings.numThreads << "\",\n";
    json << "    \"enable_optimizations\": " << (config.gdalSettings.enableGDALOptimizations ? "true" : "false") << "\n";
    json << "  },\n";
    json << "  \"logging\": {\n";
    json << "    \"log_level\": \"" << config.loggingSettings.logLevel << "\",\n";
    json << "    \"enable_file_logging\": " << (config.loggingSettings.enableFileLogging ? "true" : "false") << "\n";
    json << "  }\n";
    json << "}\n";
    
    return json.str();
}

void SpatialConfigManager::applyEnvironmentOverrides(SpatialOpsConfig& config) {
    // Ê£ÄÊü•ÁéØÂ¢ÉÂèòÈáèÂπ∂Â∫îÁî®Ë¶ÜÁõñ
    
    if (const char* logLevel = std::getenv("SPATIAL_OPS_LOG_LEVEL")) {
        config.loggingSettings.logLevel = logLevel;
    }
    
    if (const char* maxThreads = std::getenv("SPATIAL_OPS_MAX_THREADS")) {
        try {
            config.parallelSettings.maxThreads = std::stoul(maxThreads);
        } catch (const std::exception&) {
            // ÂøΩÁï•Êó†ÊïàÂÄº
        }
    }
    
    if (const char* gdalCache = std::getenv("SPATIAL_OPS_GDAL_CACHE_MB")) {
        try {
            config.gdalSettings.gdalCacheMaxBytes = std::stoll(gdalCache) * 1024 * 1024;
        } catch (const std::exception&) {
            // ÂøΩÁï•Êó†ÊïàÂÄº
        }
    }
    
    if (const char* defaultCrs = std::getenv("SPATIAL_OPS_DEFAULT_CRS")) {
        config.defaultCRS = defaultCrs;
    }
    
    if (const char* enableDebug = std::getenv("SPATIAL_OPS_DEBUG")) {
        config.enableDebugMode = (std::string(enableDebug) == "true" || std::string(enableDebug) == "1");
    }
}

bool SpatialConfigManager::validateConfigSection(const SpatialOpsConfig& config, const std::string& section) {
    if (section == "parallel") {
        return config.parallelSettings.maxThreads > 0 && 
               config.parallelSettings.minDataSizeForParallelism > 0;
    } else if (section == "gdal") {
        return config.gdalSettings.gdalCacheMaxBytes >= 0 && 
               config.gdalSettings.blockCacheSize > 0;
    } else if (section == "algorithm") {
        return config.algorithmSettings.geometricTolerance > 0 && 
               config.algorithmSettings.maxIterations > 0;
    }
    
    return true;
}

void SpatialConfigManager::applyConfigValue(SpatialOpsConfig& config, const std::string& key, const std::string& value) {
    // ÁÆÄÂåñÁöÑÈÖçÁΩÆÂÄºÂ∫îÁî®
    if (key == "log_level") {
        config.loggingSettings.logLevel = value;
    } else if (key == "max_threads") {
        try {
            config.parallelSettings.maxThreads = std::stoul(value);
        } catch (const std::exception&) {
            // ÂøΩÁï•Êó†ÊïàÂÄº
        }
    } else if (key == "default_crs") {
        config.defaultCRS = value;
    } else if (key == "gdal_cache_mb") {
        try {
            config.gdalSettings.gdalCacheMaxBytes = std::stoll(value) * 1024 * 1024;
        } catch (const std::exception&) {
            // ÂøΩÁï•Êó†ÊïàÂÄº
        }
    }
    // ÂèØ‰ª•Ê∑ªÂä†Êõ¥Â§öÈÖçÁΩÆÈ°πÁöÑÂ§ÑÁêÜ
}

} // namespace oscean::core_services::spatial_ops 
