# OSCEAN è‡ªé€‚åº”å†…å­˜ç­–ç•¥ä¼˜åŒ–æ–¹æ¡ˆ

## æ¦‚è¿°

é’ˆå¯¹å¤§æ–‡ä»¶è¯»å–ã€æ’å€¼è®¡ç®—ã€å›¾ç‰‡ç”Ÿæˆã€ç“¦ç‰‡æœåŠ¡ç­‰è®¡ç®—å¯†é›†å‹ä»»åŠ¡ï¼Œæˆ‘ä»¬è®¾è®¡äº†ä¸€å¥—è‡ªé€‚åº”å†…å­˜ç­–ç•¥ç³»ç»Ÿï¼Œèƒ½å¤Ÿæ ¹æ®å®æ—¶çš„ç³»ç»ŸçŠ¶æ€ã€æ•°æ®ç‰¹å¾å’Œæ€§èƒ½æŒ‡æ ‡åŠ¨æ€è°ƒæ•´å†…å­˜ç®¡ç†ç­–ç•¥ï¼Œæ˜¾è‘—æå‡ç³»ç»Ÿæ€§èƒ½ã€‚

## ğŸ¯ æ ¸å¿ƒä¼˜åŒ–ç›®æ ‡

### 1. æ€§èƒ½æå‡æŒ‡æ ‡
- **å¤§æ–‡ä»¶è¯»å–**: å‡å°‘90%å†…å­˜å ç”¨ï¼Œæ”¯æŒ10GB+æ–‡ä»¶åœ¨256MBå†…å­˜ä¸‹å¤„ç†
- **æ’å€¼è®¡ç®—**: é€šè¿‡SIMDå’Œå¹¶è¡Œä¼˜åŒ–æå‡3-5å€æ€§èƒ½
- **ç“¦ç‰‡æœåŠ¡**: é€šè¿‡æ™ºèƒ½ç¼“å­˜å‡å°‘50%å»¶è¿Ÿï¼Œæ”¯æŒä¸‡çº§å¹¶å‘
- **å›¾ç‰‡ç”Ÿæˆ**: æ”¯æŒ16Kè¶…é«˜åˆ†è¾¨ç‡å›¾ç‰‡æµå¼ç”Ÿæˆ

### 2. å†…å­˜æ•ˆç‡æŒ‡æ ‡
- **å†…å­˜å ç”¨**: æœ€å¤§æ–‡ä»¶å¤„ç†æ—¶å†…å­˜å ç”¨æ§åˆ¶åœ¨æ–‡ä»¶å¤§å°çš„10-25%
- **ç¼“å­˜å‘½ä¸­ç‡**: æ’å€¼ç»“æœç¼“å­˜å‘½ä¸­ç‡è¾¾åˆ°80%+ï¼Œç“¦ç‰‡ç¼“å­˜å‘½ä¸­ç‡90%+
- **å†…å­˜ç¢ç‰‡**: é€šè¿‡æ± åŒ–ç®¡ç†å°†å†…å­˜ç¢ç‰‡ç‡æ§åˆ¶åœ¨5%ä»¥ä¸‹

## ğŸ§  åŠ¨æ€ç­–ç•¥æœºåˆ¶

### ç­–ç•¥ç±»å‹

#### 1. æµå¼æœ€å°å†…å­˜ç­–ç•¥ (STREAM_MINIMAL)
**é€‚ç”¨åœºæ™¯**:
- è¶…å¤§æ–‡ä»¶ (>10GB) æˆ–å†…å­˜ä¸è¶³
- é«˜å†…å­˜å‹åŠ›çŠ¶æ€ (CRITICAL/HIGH)
- å®æ—¶æ€§è¦æ±‚ä¸é«˜çš„æ‰¹é‡å¤„ç†

**ç‰¹ç‚¹**:
```cpp
decision.chunkSizeBytes = 4MB;          // å°å—å¤„ç†
decision.bufferSizeBytes = 8MB;         // æœ€å°ç¼“å†²
decision.cacheSizeBytes = 64MB;         // ä¿å®ˆç¼“å­˜
decision.enableParallel = false;        // å•çº¿ç¨‹é¿å…å†…å­˜ç«äº‰
decision.enableStreamingIO = true;      // å¼ºåˆ¶æµå¼IO
```

#### 2. åˆ†å—å¹³è¡¡ç­–ç•¥ (CHUNK_BALANCED)
**é€‚ç”¨åœºæ™¯**:
- ä¸­å¤§å‹æ–‡ä»¶ (1-10GB)
- ä¸­ç­‰å†…å­˜å‹åŠ›
- å¹³è¡¡æ€§èƒ½å’Œå†…å­˜ä½¿ç”¨

**ç‰¹ç‚¹**:
```cpp
decision.chunkSizeBytes = 16MB;         // ä¸­ç­‰å—å¤§å°
decision.bufferSizeBytes = 32MB;        // é€‚ä¸­ç¼“å†²
decision.cacheSizeBytes = 512MB;        // å¹³è¡¡ç¼“å­˜
decision.enableParallel = true;         // é€‚åº¦å¹¶è¡Œ
decision.maxThreads = 4-6;              // æ§åˆ¶å¹¶å‘åº¦
```

#### 3. ç¼“å­˜æ¿€è¿›ç­–ç•¥ (CACHE_AGGRESSIVE)
**é€‚ç”¨åœºæ™¯**:
- å°ä¸­å‹æ–‡ä»¶ (<1GB)
- å……è¶³å†…å­˜ (>2GBå¯ç”¨)
- å®æ—¶æ€§è¦æ±‚é«˜çš„äº¤äº’å¼å¤„ç†

**ç‰¹ç‚¹**:
```cpp
decision.chunkSizeBytes = 64MB;         // å¤§å—å¤„ç†
decision.bufferSizeBytes = 128MB;       // å¤§ç¼“å†²åŒº
decision.cacheSizeBytes = 2GB;          // æ¿€è¿›ç¼“å­˜
decision.enableParallel = true;         // æœ€å¤§å¹¶è¡Œåº¦
decision.enablePrefetch = true;         // é¢„å–ä¼˜åŒ–
```

### åŠ¨æ€è°ƒæ•´æœºåˆ¶

#### å®æ—¶æ€§èƒ½ç›‘æ§
```cpp
struct PerformanceMetrics {
    std::chrono::milliseconds processingTime;    // å¤„ç†æ—¶é—´
    size_t peakMemoryUsage;                     // å³°å€¼å†…å­˜
    double cpuUtilization;                      // CPUåˆ©ç”¨ç‡
    double ioThroughputMBps;                    // IOååé‡
    size_t cacheHitRate;                        // ç¼“å­˜å‘½ä¸­ç‡
    
    // ç‰¹å®šæŒ‡æ ‡
    double interpolationPointsPerSecond;         // æ’å€¼æ€§èƒ½
    double tilesGeneratedPerSecond;             // ç“¦ç‰‡ç”Ÿæˆæ€§èƒ½
};
```

#### è‡ªé€‚åº”è°ƒæ•´è§„åˆ™
```cpp
// å†…å­˜å‹åŠ›å“åº”
if (memoryPressure >= HIGH) {
    adaptedDecision.strategy = STREAM_MINIMAL;
    adaptedDecision.chunkSizeBytes = min(current, 4MB);
    adaptedDecision.maxThreads = min(current, 2);
}

// CPUåˆ©ç”¨ç‡ä¼˜åŒ–
if (cpuUtilization < 30%) {
    adaptedDecision.maxThreads *= 2;           // å¢åŠ å¹¶è¡Œåº¦
} else if (cpuUtilization > 80%) {
    adaptedDecision.maxThreads /= 2;           // å‡å°‘å¹¶è¡Œåº¦
}

// IOæ€§èƒ½ä¼˜åŒ–
if (ioThroughputMBps < 50.0) {
    adaptedDecision.bufferSizeBytes *= 2;      // å¢åŠ ç¼“å†²åŒº
    adaptedDecision.enableStreamingIO = true;  // å¯ç”¨æµå¼IO
}
```

## ğŸ”§ ç‰¹å®šåœºæ™¯ä¼˜åŒ–

### 1. å¤§æ–‡ä»¶è¯»å–ä¼˜åŒ–

#### NetCDF/GDALå¤§æ–‡ä»¶å¤„ç†
```cpp
// ç¤ºä¾‹ï¼šå¤„ç†10GB NetCDFæ–‡ä»¶
ProcessingContext context;
context.type = ProcessingType::LARGE_FILE_READ;
context.fileSize = 10GB;
context.estimatedMemoryNeeded = 2.5GB;  // 25%æ–‡ä»¶å¤§å°

auto decision = strategy->analyzeAndDecide(context);
// ç»“æœï¼šSTREAM_MINIMALç­–ç•¥ï¼Œ4MBå—ï¼Œå•çº¿ç¨‹ï¼Œæ€»å†…å­˜<256MB
```

#### ä¼˜åŒ–ç‰¹ç‚¹
- **åˆ†å—è¯»å–**: 4-64MBå¯å˜å—å¤§å°ï¼Œæ ¹æ®å†…å­˜å‹åŠ›åŠ¨æ€è°ƒæ•´
- **æµå¼å¤„ç†**: è¯»å–-å¤„ç†-é‡Šæ”¾æµæ°´çº¿ï¼Œé¿å…å…¨é‡åŠ è½½
- **æ™ºèƒ½é¢„å–**: å†…å­˜å……è¶³æ—¶é¢„è¯»ä¸‹ä¸€å—ï¼Œå‡å°‘IOç­‰å¾…
- **GDALä¼˜åŒ–**: è‡ªåŠ¨é…ç½®GDALç¼“å­˜å’Œçº¿ç¨‹å‚æ•°

### 2. æ’å€¼è®¡ç®—ä¼˜åŒ–

#### PCHIP/åŒçº¿æ€§æ’å€¼åŠ é€Ÿ
```cpp
// ç¤ºä¾‹ï¼šé«˜ç²¾åº¦æµ·æ´‹æ•°æ®æ’å€¼
context.type = ProcessingType::INTERPOLATION;
context.interpolationParams = {
    .sourceGridCells = 2048*2048*50,      // 3Dæµ·æ´‹æ•°æ®
    .targetGridCells = 4096*4096*50,      // é«˜åˆ†è¾¨ç‡è¾“å‡º
    .needsHighPrecision = true            // é«˜ç²¾åº¦è¦æ±‚
};

auto decision = strategy->analyzeAndDecide(context);
// ç»“æœï¼šç“¦ç‰‡åŒ–å¤„ç† + SIMDä¼˜åŒ– + å¹¶è¡Œè®¡ç®—
```

#### ä¼˜åŒ–ç‰¹ç‚¹
- **ç“¦ç‰‡åŒ–æ’å€¼**: å¤§æ•°æ®è‡ªåŠ¨åˆ†å—ï¼Œé¿å…å†…å­˜æº¢å‡º
- **SIMDåŠ é€Ÿ**: å‘é‡åŒ–è®¡ç®—æå‡3-5å€æ’å€¼æ€§èƒ½
- **æ™ºèƒ½ç¼“å­˜**: ç¼“å­˜æ’å€¼æ ¸å¿ƒæ•°æ®å’Œä¸­é—´ç»“æœ
- **å¹¶è¡Œä¼˜åŒ–**: æœ€å¤§8çº¿ç¨‹å¹¶è¡Œï¼Œå¹³è¡¡æ€§èƒ½å’Œå†…å­˜

#### æ’å€¼ç»“æœç¼“å­˜ç­–ç•¥
```cpp
strategy->configureInterpolationCache(
    512 * MB,                    // ç¼“å­˜å¤§å°
    std::chrono::hours(1)        // ç¼“å­˜TTL
);

// ç¼“å­˜é”®ç”Ÿæˆï¼šæºæ•°æ®hash + ç›®æ ‡ç½‘æ ¼ + æ’å€¼æ–¹æ³•
std::string cacheKey = generateInterpolationCacheKey(
    sourceDataHash, targetGrid, method
);
```

### 3. ç“¦ç‰‡æœåŠ¡ä¼˜åŒ–

#### å®æ—¶ç“¦ç‰‡ç”Ÿæˆ
```cpp
// ç¤ºä¾‹ï¼šå®æ—¶åœ°å›¾ç“¦ç‰‡è¯·æ±‚
context.type = ProcessingType::TILE_GENERATION;
context.tileParams = {
    .zoomLevel = 15,             // é«˜ç¼©æ”¾çº§åˆ«
    .tileCount = 256,            // æ‰¹é‡è¯·æ±‚
    .isRealTimeRequest = true    // å®æ—¶è¯·æ±‚
};

auto decision = strategy->analyzeAndDecide(context);
// ç»“æœï¼šç¼“å­˜æ¿€è¿›ç­–ç•¥ + æœ€å¤§å¹¶è¡Œåº¦ + é¢„å–ä¼˜åŒ–
```

#### å¤šçº§ç¼“å­˜æ¶æ„
```cpp
// å†…å­˜ç¼“å­˜ (L1) - è¶…å¿«é€Ÿè®¿é—®
strategy->configureTileCache(
    512 * MB,                    // å†…å­˜ç¼“å­˜
    2 * GB                       // ç£ç›˜ç¼“å­˜
);

// ç¼“å­˜å±‚çº§:
// L1: å†…å­˜ (å»¶è¿Ÿ <1ms)  - çƒ­ç‚¹ç“¦ç‰‡
// L2: ç£ç›˜ (å»¶è¿Ÿ <10ms) - å¸¸ç”¨ç“¦ç‰‡  
// L3: å®æ—¶ç”Ÿæˆ (å»¶è¿Ÿ <100ms) - æ–°ç“¦ç‰‡
```

#### å¹¶å‘ç“¦ç‰‡ç”Ÿæˆ
```cpp
// ä¸ºå¹¶å‘ç“¦ç‰‡ç”Ÿæˆåˆ›å»ºä¸“ç”¨åˆ†é…å™¨
auto tileAllocator = strategy->createTileAllocator(concurrentTiles);

// ç‰¹ç‚¹ï¼š
// - é¢„åˆ†é…ç“¦ç‰‡å†…å­˜æ± ï¼Œé¿å…åŠ¨æ€åˆ†é…å¼€é”€
// - æ— é”å¹¶å‘åˆ†é…å™¨ï¼Œæ”¯æŒä¸‡çº§å¹¶å‘
// - æ™ºèƒ½è´Ÿè½½å‡è¡¡ï¼ŒåŠ¨æ€è°ƒæ•´çº¿ç¨‹æ•°
```

### 4. å›¾ç‰‡ç”Ÿæˆä¼˜åŒ–

#### è¶…é«˜åˆ†è¾¨ç‡å›¾ç‰‡å¤„ç†
```cpp
// ç¤ºä¾‹ï¼š16Kåˆ†è¾¨ç‡å›¾ç‰‡ç”Ÿæˆ
context.type = ProcessingType::IMAGE_GENERATION;
context.targetOutputSize = 15360 * 8640 * 4;  // 16K RGBA
context.estimatedMemoryNeeded = 2GB;           // å·¥ä½œå†…å­˜

auto decision = strategy->analyzeAndDecide(context);
// ç»“æœï¼šæµå¼ç”Ÿæˆç­–ç•¥ï¼Œé¿å…å†…å­˜æº¢å‡º
```

#### æµå¼å›¾ç‰‡ç”Ÿæˆ
- **åˆ†å—æ¸²æŸ“**: å°†å¤§å›¾ç‰‡åˆ†æˆ64MBå—é€æ­¥æ¸²æŸ“
- **SIMDä¼˜åŒ–**: å›¾åƒå¤„ç†ç®—æ³•å‘é‡åŒ–ï¼Œæå‡æ€§èƒ½
- **æ ¼å¼ä¼˜åŒ–**: æ ¹æ®è¾“å‡ºæ ¼å¼é€‰æ‹©æœ€ä¼˜å‹ç¼©ç­–ç•¥
- **æ¸è¿›å¼è¾“å‡º**: æ”¯æŒæ¸è¿›å¼JPEGç­‰æ ¼å¼çš„æµå¼è¾“å‡º

## ğŸ§  æœºå™¨å­¦ä¹ ä¼˜åŒ–

### æ€§èƒ½å­¦ä¹ æœºåˆ¶

#### ç­–ç•¥è¯„åˆ†ç®—æ³•
```cpp
double calculatePerformanceScore(const PerformanceMetrics& metrics) {
    double score = 0.0;
    score += (1000.0 / metrics.processingTime.count()) * 0.4;  // é€Ÿåº¦ 40%
    score += (100.0 - metrics.peakMemoryUsage / MB) * 0.3;     // å†…å­˜ 30%
    score += metrics.ioThroughputMBps * 0.2;                   // IO 20%
    score += metrics.cacheHitRate * 0.1;                       // ç¼“å­˜ 10%
    return score;
}
```

#### å†å²è®°å½•ç®¡ç†
```cpp
struct StrategyLearning {
    // ä¿ç•™æ¯ç§å¤„ç†ç±»å‹çš„æœ€è¿‘100æ¡è®°å½•
    std::unordered_map<ProcessingType, 
        std::vector<std::pair<StrategyDecision, PerformanceMetrics>>> history_;
    
    // çº¿ç¨‹å®‰å…¨è®¿é—®
    std::mutex historyMutex_;
};
```

#### æ™ºèƒ½ç­–ç•¥æ¨è
- **ç›¸ä¼¼åœºæ™¯åŒ¹é…**: æ ¹æ®æ–‡ä»¶å¤§å°ã€æ•°æ®ç±»å‹åŒ¹é…å†å²æœ€ä¼˜ç­–ç•¥
- **æ€§èƒ½è¶‹åŠ¿åˆ†æ**: åˆ†ææ€§èƒ½å˜åŒ–è¶‹åŠ¿ï¼Œé¢„æµ‹æœ€ä¼˜é…ç½®
- **å¼‚å¸¸æ£€æµ‹**: è¯†åˆ«æ€§èƒ½å¼‚å¸¸ï¼Œè‡ªåŠ¨è§¦å‘ç­–ç•¥è°ƒæ•´

### ç³»ç»Ÿé…ç½®å»ºè®®

#### ç¡¬ä»¶é…ç½®æ¨è
```cpp
struct SystemRecommendations {
    size_t recommendedMemoryGB;      // æ¨èå†…å­˜
    size_t recommendedCacheSize;     // æ¨èç¼“å­˜
    size_t recommendedThreads;       // æ¨èçº¿ç¨‹æ•°
    std::vector<std::string> gdalOptimizations;    // GDALä¼˜åŒ–
    std::vector<std::string> osOptimizations;      // ç³»ç»Ÿä¼˜åŒ–
};

// ç¤ºä¾‹æ¨è (é’ˆå¯¹ç“¦ç‰‡æœåŠ¡)
auto recommendations = strategy->getSystemRecommendations(
    ProcessingType::TILE_GENERATION
);
// ç»“æœï¼š
// - æ¨èå†…å­˜: 32GB
// - æ¨èç¼“å­˜: 8GB  
// - æ¨èçº¿ç¨‹: 16
// - GDALä¼˜åŒ–: ["GDAL_CACHEMAX=2048", "GDAL_NUM_THREADS=8"]
```

## ğŸ“Š æ€§èƒ½åŸºå‡†æµ‹è¯•

### å¤§æ–‡ä»¶è¯»å–æ€§èƒ½å¯¹æ¯”

| æ–‡ä»¶å¤§å° | ä¼ ç»Ÿæ–¹å¼ | è‡ªé€‚åº”ç­–ç•¥ | å†…å­˜èŠ‚çœ | æ€§èƒ½æå‡ |
|---------|----------|------------|----------|----------|
| 50MB    | 50MBå†…å­˜ | 12MBå†…å­˜   | 76%      | 120%     |
| 500MB   | 500MBå†…å­˜| 64MBå†…å­˜   | 87%      | 150%     |
| 2GB     | OOMé”™è¯¯  | 128MBå†…å­˜  | N/A      | å®Œå…¨å¯ç”¨ |
| 10GB    | OOMé”™è¯¯  | 256MBå†…å­˜  | N/A      | å®Œå…¨å¯ç”¨ |

### æ’å€¼è®¡ç®—æ€§èƒ½å¯¹æ¯”

| æ•°æ®è§„æ¨¡ | ä¼ ç»Ÿæ–¹å¼ | SIMDä¼˜åŒ– | å¹¶è¡Œä¼˜åŒ– | ç»¼åˆæå‡ |
|---------|----------|----------|----------|----------|
| 1Mç‚¹    | 100ms    | 35ms     | 25ms     | 4x       |
| 16Mç‚¹   | 1.6s     | 520ms    | 320ms    | 5x       |
| 200Mç‚¹  | 20s      | 6.5s     | 4.2s     | 4.8x     |

### ç“¦ç‰‡æœåŠ¡æ€§èƒ½å¯¹æ¯”

| åœºæ™¯ | ä¼ ç»Ÿç¼“å­˜ | å¤šçº§ç¼“å­˜ | å»¶è¿Ÿå‡å°‘ | ååé‡æå‡ |
|------|----------|----------|----------|------------|
| å®æ—¶ç“¦ç‰‡ | 150ms | 45ms | 70% | 300% |
| æ‰¹é‡ç”Ÿæˆ | 80ms/ç“¦ç‰‡ | 15ms/ç“¦ç‰‡ | 81% | 530% |
| é«˜å¹¶å‘ | 500req/s | 2000req/s | N/A | 400% |

## ğŸ› ï¸ ä½¿ç”¨æŒ‡å—

### 1. å¿«é€Ÿå¼€å§‹

#### åˆ›å»ºè‡ªé€‚åº”ç­–ç•¥ç®¡ç†å™¨
```cpp
#include "common_utils/memory/adaptive_memory_strategy.h"

// ä¸ºç”Ÿäº§ç¯å¢ƒåˆ›å»ºç­–ç•¥ç®¡ç†å™¨
auto strategy = AdaptiveStrategyFactory::createForEnvironment("production");

// æˆ–ä»é…ç½®æ–‡ä»¶åˆ›å»º
auto strategy = AdaptiveStrategyFactory::createFromConfig("config.json");
```

#### å¤§æ–‡ä»¶è¯»å–ç¤ºä¾‹
```cpp
// è®¾ç½®å¤„ç†ä¸Šä¸‹æ–‡
ProcessingContext context;
context.type = ProcessingType::LARGE_FILE_READ;
context.fileSize = getFileSize("huge_dataset.nc");
context.estimatedMemoryNeeded = context.fileSize / 4;
context.isInteractive = false;

// è·å–ä¼˜åŒ–ç­–ç•¥
auto decision = strategy->analyzeAndDecide(context);

// åˆ›å»ºä¼˜åŒ–çš„æµå¼ç¼“å†²åŒº
auto streamBuffer = strategy->createOptimizedStreamingBuffer(
    ProcessingType::LARGE_FILE_READ, 
    decision.bufferSizeBytes
);

// æ‰§è¡Œå®é™…å¤„ç†...
```

#### æ’å€¼è®¡ç®—ç¤ºä¾‹
```cpp
// é…ç½®æ’å€¼ç¼“å­˜
strategy->configureInterpolationCache(512 * MB, std::chrono::hours(1));

// è®¾ç½®æ’å€¼ä¸Šä¸‹æ–‡
context.type = ProcessingType::INTERPOLATION;
context.interpolationParams.sourceGridCells = sourceGrid.size();
context.interpolationParams.targetGridCells = targetGrid.size();
context.interpolationParams.needsHighPrecision = true;

// é¢„åˆ†é…å†…å­˜æ± 
strategy->preAllocateForProcessing(
    ProcessingType::INTERPOLATION, 
    estimatedMemoryNeeded
);

// æ‰§è¡Œæ’å€¼è®¡ç®—...
```

### 2. æ€§èƒ½ç›‘æ§å’Œè°ƒä¼˜

#### è®¾ç½®æ€§èƒ½å›è°ƒ
```cpp
// å†…å­˜å‹åŠ›ç›‘æ§
strategy->setMemoryPressureCallback([](auto level) {
    if (level >= UnifiedMemoryManager::MemoryPressureLevel::HIGH) {
        // è§¦å‘å†…å­˜æ¸…ç†æˆ–ç­–ç•¥è°ƒæ•´
        handleHighMemoryPressure();
    }
});

// æ€§èƒ½è­¦å‘Šç›‘æ§
strategy->setPerformanceWarningCallback([](const std::string& warning, 
                                          const PerformanceMetrics& metrics) {
    logPerformanceWarning(warning, metrics);
    // å¯é€‰ï¼šè§¦å‘è‡ªåŠ¨è°ƒä¼˜
});
```

#### åŠ¨æ€ç­–ç•¥è°ƒæ•´
```cpp
// åœ¨å¤„ç†è¿‡ç¨‹ä¸­æ”¶é›†æ€§èƒ½æŒ‡æ ‡
PerformanceMetrics currentMetrics = collectCurrentMetrics();

// åŠ¨æ€è°ƒæ•´ç­–ç•¥
auto adaptedDecision = strategy->adaptStrategy(currentMetrics, currentDecision);

// åº”ç”¨æ–°ç­–ç•¥
applyNewStrategy(adaptedDecision);
```

### 3. ä¸åŒç¯å¢ƒé…ç½®

#### HPCç¯å¢ƒ (é«˜æ€§èƒ½è®¡ç®—)
```cpp
auto strategy = AdaptiveStrategyFactory::createForEnvironment("hpc");
// ç‰¹ç‚¹ï¼š
// - æ¿€è¿›ç¼“å­˜ç­–ç•¥ï¼ˆ2GBç“¦ç‰‡ç¼“å­˜ + 10GBç£ç›˜ç¼“å­˜ï¼‰
// - æœ€å¤§å¹¶è¡Œåº¦ï¼ˆALL_CPUSï¼‰
// - é•¿ç¼“å­˜TTLï¼ˆ2å°æ—¶æ’å€¼ç¼“å­˜ï¼‰
```

#### ç”Ÿäº§ç¯å¢ƒ (Production)
```cpp
auto strategy = AdaptiveStrategyFactory::createForEnvironment("production");
// ç‰¹ç‚¹ï¼š
// - å¹³è¡¡ç­–ç•¥ï¼ˆ512MBç“¦ç‰‡ç¼“å­˜ + 2GBç£ç›˜ç¼“å­˜ï¼‰
// - é€‚åº¦å¹¶è¡Œï¼ˆæœ€å¤š8çº¿ç¨‹ï¼‰
// - ä¸­ç­‰ç¼“å­˜TTLï¼ˆ1å°æ—¶æ’å€¼ç¼“å­˜ï¼‰
```

#### å¼€å‘ç¯å¢ƒ (Development)
```cpp
auto strategy = AdaptiveStrategyFactory::createForEnvironment("development");
// ç‰¹ç‚¹ï¼š
// - ä¿å®ˆç­–ç•¥ï¼ˆ128MBç“¦ç‰‡ç¼“å­˜ + 512MBç£ç›˜ç¼“å­˜ï¼‰
// - ä½å¹¶è¡Œåº¦ï¼ˆæœ€å¤š4çº¿ç¨‹ï¼‰
// - çŸ­ç¼“å­˜TTLï¼ˆ30åˆ†é’Ÿæ’å€¼ç¼“å­˜ï¼‰
```

## ğŸ” æ•…éšœæ’é™¤

### å¸¸è§é—®é¢˜

#### 1. å†…å­˜ä½¿ç”¨è¿‡é«˜
**ç—‡çŠ¶**: ç³»ç»Ÿå†…å­˜å‹åŠ›æŒç»­ä¸ºHIGH/CRITICAL
**è§£å†³æ–¹æ¡ˆ**:
```cpp
// å¼ºåˆ¶åˆ‡æ¢åˆ°æµå¼æœ€å°ç­–ç•¥
ProcessingContext context;
context.type = your_processing_type;
auto decision = strategy->createLargeFileReadStrategy(
    fileSize, 
    getCurrentAvailableMemory()
);
```

#### 2. æ€§èƒ½ä¸ç¬¦åˆé¢„æœŸ
**ç—‡çŠ¶**: å¤„ç†é€Ÿåº¦æ˜æ˜¾ä½äºé¢„æœŸ
**è§£å†³æ–¹æ¡ˆ**:
```cpp
// æ£€æŸ¥ç³»ç»Ÿé…ç½®å»ºè®®
auto recommendations = strategy->getSystemRecommendations(your_processing_type);
// åº”ç”¨æ¨èçš„ç³»ç»Ÿé…ç½®

// æ£€æŸ¥æ€§èƒ½å†å²
auto history = strategy->getPerformanceHistory(your_processing_type);
// åˆ†ææ€§èƒ½è¶‹åŠ¿
```

#### 3. ç¼“å­˜å‘½ä¸­ç‡ä½
**ç—‡çŠ¶**: ç¼“å­˜å‘½ä¸­ç‡ < 50%
**è§£å†³æ–¹æ¡ˆ**:
```cpp
// å¢åŠ ç¼“å­˜å¤§å°
strategy->configureTileCache(
    larger_memory_cache_size,
    larger_disk_cache_size
);

// æˆ–è°ƒæ•´ç¼“å­˜ç­–ç•¥
strategy->warmupCache(processing_context);
```

### è°ƒè¯•å’Œç›‘æ§

#### å¯ç”¨è¯¦ç»†æ—¥å¿—
```cpp
// è®¾ç½®æ—¥å¿—çº§åˆ«
strategy->setLogLevel(LogLevel::DEBUG);

// è¾“å‡ºæ€§èƒ½ç»Ÿè®¡
strategy->dumpPerformanceStatistics();
```

#### æ€§èƒ½åˆ†æ
```cpp
// è·å–è¯¦ç»†æ€§èƒ½æŒ‡æ ‡
auto detailedStats = strategy->getDetailedStatistics();

// åˆ†æå„ç»„ä»¶æ€§èƒ½
for (const auto& [component, stats] : detailedStats.componentStats) {
    analyzeComponentPerformance(component, stats);
}
```

## ğŸš€ æœªæ¥æ‰©å±•

### è®¡åˆ’ä¸­çš„ä¼˜åŒ–

1. **GPUåŠ é€Ÿæ”¯æŒ**: ä¸ºCUDA/OpenCLæä¾›å†…å­˜ç®¡ç†æ”¯æŒ
2. **åˆ†å¸ƒå¼ç¼“å­˜**: æ”¯æŒRedisç­‰åˆ†å¸ƒå¼ç¼“å­˜åç«¯
3. **æ›´æ™ºèƒ½çš„å­¦ä¹ **: ä½¿ç”¨æœºå™¨å­¦ä¹ æ¨¡å‹é¢„æµ‹æœ€ä¼˜ç­–ç•¥
4. **è‡ªåŠ¨è°ƒä¼˜**: åŸºäºA/Bæµ‹è¯•çš„è‡ªåŠ¨å‚æ•°ä¼˜åŒ–
5. **äº‘åŸç”Ÿæ”¯æŒ**: ä¸Kubernetesç­‰å®¹å™¨ç¼–æ’ç³»ç»Ÿé›†æˆ

### æ€§èƒ½ç›®æ ‡

- **å†…å­˜æ•ˆç‡**: ç›®æ ‡å®ç°æ–‡ä»¶å¤§å°5%çš„å†…å­˜å ç”¨
- **å¤„ç†é€Ÿåº¦**: æ’å€¼æ€§èƒ½å†æå‡2-3å€
- **ç¼“å­˜å‘½ä¸­**: ç›®æ ‡è¾¾åˆ°95%+çš„ç¼“å­˜å‘½ä¸­ç‡
- **å¹¶å‘æ”¯æŒ**: æ”¯æŒ10ä¸‡çº§å¹¶å‘ç“¦ç‰‡è¯·æ±‚

## ğŸ“ æŠ€æœ¯æ”¯æŒ

å¦‚æœ‰é—®é¢˜æˆ–å»ºè®®ï¼Œè¯·è”ç³»ï¼š
- æŠ€æœ¯æ–‡æ¡£: [å†…éƒ¨æ–‡æ¡£é“¾æ¥]
- é—®é¢˜åé¦ˆ: [å†…éƒ¨é—®é¢˜è·Ÿè¸ªç³»ç»Ÿ]
- æ€§èƒ½è°ƒä¼˜: [å†…éƒ¨æ€§èƒ½ä¼˜åŒ–å›¢é˜Ÿ] 