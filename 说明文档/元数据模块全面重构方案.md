# å…ƒæ•°æ®æ¨¡å—å…¨é¢é‡æ„æ–¹æ¡ˆ

## ğŸ“ **æ–‡æ¡£æ›´æ–°è®°å½•**
- **æœ€æ–°ç‰ˆæœ¬**: 2024-01-20 - åŸºäºæ¶æ„è¯„å®¡åé¦ˆçš„æœ€ç»ˆä¿®æ­£ç‰ˆæœ¬
- **å…³é”®ä¿®æ­£**: 
  - âœ… ç¡®è®¤ç»Ÿä¸€æ¥å£é‡‡ç”¨**å•ä¸€æ–‡ä»¶è®¾è®¡** (`unified_metadata_service.h`)
  - âœ… ç¡®è®¤å®Œå…¨æ¶ˆé™¤æœåŠ¡ç¼–æ’èŒè´£ï¼Œä¸“æ³¨å…ƒæ•°æ®æ ¸å¿ƒä¸šåŠ¡
  - âœ… ç¡®è®¤100%ä½¿ç”¨common_utilitiesåŸºç¡€è®¾æ–½ï¼Œé›¶é‡å¤å®ç°
  - âœ… ç¡®è®¤SQLite3å¤šåº“æ¶æ„è®¾è®¡æœ€ç»ˆæ–¹æ¡ˆ

## ğŸ“‹ æ‰§è¡Œæ‘˜è¦

åŸºäºå†å²è®¾è®¡æ–‡æ¡£å’Œéœ€æ±‚åˆ†æï¼Œå…ƒæ•°æ®æ¨¡å—éœ€è¦è¿›è¡Œ**å…¨é¢æ¶æ„é‡æ„**ï¼Œå®ç°ä»å•ä¸€æœåŠ¡å‘**ä¸“ä¸šåŒ–å…ƒæ•°æ®ç®¡ç†æœåŠ¡**çš„è½¬å˜ã€‚æœ¬æ–¹æ¡ˆéµå¾ª**æ¨¡å—èŒè´£å•ä¸€åŒ–**åŸåˆ™ï¼Œä¸“æ³¨äºå…ƒæ•°æ®çš„æå–ã€å­˜å‚¨ã€ç®¡ç†å’ŒæŸ¥è¯¢åŠŸèƒ½ã€‚

### ğŸ¯ **é‡æ„ç›®æ ‡å¯¹æ¯”**

| ç»´åº¦ | ç°çŠ¶ | é‡æ„åç›®æ ‡ |
|------|------|------------|
| **æ¶æ„æ¨¡å¼** | ç›´æ¥å®ä¾‹åŒ–ã€åŒæ­¥è°ƒç”¨ | å·¥å‚æ¨¡å¼ + å¼‚æ­¥ + ä¾èµ–æ³¨å…¥ |
| **æ•°æ®åº“æ¶æ„** | å•åº“SQLite | å¤šåº“åˆ†ç±»ç®¡ç†ï¼ˆæµ·æ´‹ç¯å¢ƒã€åœ°å½¢åº•è´¨ã€è¾¹ç•Œçº¿ã€å£°çº³ä¼ æ’­ï¼‰ |
| **å˜é‡è¯†åˆ«** | ç¡¬ç¼–ç å˜é‡å | å‚æ•°åŒ–é…ç½® + æ™ºèƒ½è¯†åˆ« + äººå·¥é…ç½® |
| **æŸ¥è¯¢èƒ½åŠ›** | åŸºç¡€æ–‡ä»¶æŸ¥è¯¢ | æ—¶ç©ºå˜é‡å¤šç»´åº¦è”åˆæŸ¥è¯¢ + æ™ºèƒ½æ’åº |
| **å…ƒæ•°æ®åˆ†ç±»** | ç®€å•æ–‡ä»¶åˆ†ç±» | æ™ºèƒ½åˆ†ç±» + æ‰‹åŠ¨é…ç½® + è‡ªåŠ¨æ›´æ–° |
| **æ¥å£æ¨¡å¼** | std::futureæ··ç”¨ | 100% boost::future + ç»Ÿä¸€é”™è¯¯å¤„ç† |
| **æ¨¡å—èŒè´£** | åŠŸèƒ½è¾¹ç•Œæ¨¡ç³Š | **ä¸“æ³¨å…ƒæ•°æ®ç®¡ç†ï¼Œæ¶ˆé™¤æœåŠ¡ç¼–æ’** |

## ğŸ” ç¬¬ä¸€éƒ¨åˆ†ï¼šæ¶æ„é‡æ„è¯¦ç»†æ–¹æ¡ˆ

### 1.1 **çº¯ç²¹å…ƒæ•°æ®æœåŠ¡æ¶æ„è®¾è®¡**

#### **ç°çŠ¶æ¶æ„é—®é¢˜**
```cpp
// âŒ å½“å‰é—®é¢˜æ¶æ„
class MetadataServiceImpl {
    // ç›´æ¥å®ä¾‹åŒ–ï¼Œç´§è€¦åˆ
    std::unique_ptr<SQLiteStorage> storage_;
    
    // åŒæ­¥è°ƒç”¨ï¼Œæ€§èƒ½ç“¶é¢ˆ
    std::optional<FileMetadata> extractMetadata(const std::string& path);
    
    // æ··ç”¨std::futureå’Œboost::future
    std::future<bool> someMethod();
    boost::future<void> anotherMethod();
};
```

#### **é‡æ„åç›®æ ‡æ¶æ„**
```cpp
// âœ… é‡æ„åçº¯ç²¹å…ƒæ•°æ®æœåŠ¡æ¶æ„
namespace oscean::core_services::metadata {

// å…ƒæ•°æ®æœåŠ¡å·¥å‚ - ä¸“æ³¨äºå…ƒæ•°æ®æœåŠ¡åˆ›å»º
class MetadataServiceFactory {
public:
    static std::unique_ptr<MetadataServiceFactory> create(
        std::shared_ptr<common_utils::infrastructure::CommonServicesFactory> commonServices
    );
    
    boost::future<AsyncResult<std::shared_ptr<IMetadataService>>> createServiceAsync(
        const MetadataServiceConfiguration& config
    );

private:
    std::shared_ptr<common_utils::infrastructure::CommonServicesFactory> commonServices_;
    std::shared_ptr<MultiDatabaseManagerFactory> databaseFactory_;
    std::shared_ptr<IntelligentIndexFactory> indexFactory_;
};

// çº¯ç²¹å…ƒæ•°æ®æœåŠ¡æ¥å£ - åªç®¡ç†å…ƒæ•°æ®
class IMetadataService {
public:
    // === å…ƒæ•°æ®æå–æ¥å£ ===
    virtual boost::future<AsyncResult<ExtractedMetadata>> extractMetadataAsync(
        const std::string& filePath,
        const std::optional<DataTypeHint>& hint = std::nullopt
    ) = 0;
    
    // === å…ƒæ•°æ®å­˜å‚¨æ¥å£ ===
    virtual boost::future<AsyncResult<std::string>> storeMetadataAsync(
        const ExtractedMetadata& metadata
    ) = 0;
    
    // === å…ƒæ•°æ®æŸ¥è¯¢æ¥å£ ===
    virtual boost::future<AsyncResult<std::vector<MetadataEntry>>> queryMetadataAsync(
        const MetadataQueryCriteria& criteria
    ) = 0;
    
    // === å…ƒæ•°æ®ç®¡ç†æ¥å£ ===
    virtual boost::future<AsyncResult<void>> updateMetadataAsync(
        const std::string& metadataId,
        const MetadataUpdate& update
    ) = 0;
    
    virtual boost::future<AsyncResult<void>> deleteMetadataAsync(
        const std::string& metadataId
    ) = 0;
    
    // === é…ç½®ç®¡ç†æ¥å£ ===
    virtual boost::future<AsyncResult<void>> updateClassificationConfigAsync(
        const VariableClassificationConfig& config
    ) = 0;
    
    // === æœåŠ¡çŠ¶æ€æ¥å£ ===
    virtual boost::future<AsyncResult<MetadataServiceStatus>> getServiceStatusAsync() = 0;
};

} // namespace oscean::core_services::metadata
```

### 1.2 **ä¾èµ–æ³¨å…¥å®¹å™¨è®¾è®¡**

```cpp
// å…ƒæ•°æ®æœåŠ¡ä¾èµ–å®¹å™¨ - ä»…ç®¡ç†å…ƒæ•°æ®æœåŠ¡ç›¸å…³ä¾èµ–
class MetadataServiceContainer {
public:
    // æ³¨å†Œæ ¸å¿ƒä¾èµ–
    void registerCommonServices(std::shared_ptr<common_utils::infrastructure::CommonServicesFactory> factory);
    
    // åˆ›å»ºçº¯ç²¹çš„å…ƒæ•°æ®æœåŠ¡
    boost::future<AsyncResult<std::shared_ptr<IMetadataService>>> createMetadataServiceAsync();
    
    // è·å–å†…éƒ¨ç»„ä»¶
    template<typename T>
    std::shared_ptr<T> resolve();

private:
    std::map<std::type_index, std::shared_ptr<void>> dependencies_;
    std::shared_ptr<MetadataServiceConfiguration> configuration_;
};
```

## ğŸ” ç¬¬äºŒéƒ¨åˆ†ï¼šåŠŸèƒ½é‡æ„è¯¦ç»†æ–¹æ¡ˆ

### 2.1 **åŠŸèƒ½è¾¹ç•Œé‡æ–°å®šä¹‰ - æ¶ˆé™¤æœåŠ¡ç¼–æ’**

#### **ä¿®æ­£åçš„åŠŸèƒ½è¾¹ç•Œè¡¨**

| åŠŸèƒ½ | ç°çŠ¶ | ä¿®æ­£å | è´Ÿè´£æ¨¡å— | å¤‡æ³¨ |
|------|------|--------|----------|------|
| **æ–‡ä»¶æ ¼å¼è§£æ** | âŒ å…ƒæ•°æ®æœåŠ¡é‡å¤å®ç° | âœ… é€šè¿‡æ¥å£è°ƒç”¨å…¶ä»–æœåŠ¡ | Data Access | æ¥å£è°ƒç”¨ï¼Œä¸ç¼–æ’ |
| **åæ ‡ç³»è½¬æ¢** | âŒ å…ƒæ•°æ®æœåŠ¡é‡å¤å®ç° | âœ… é€šè¿‡æ¥å£è°ƒç”¨å…¶ä»–æœåŠ¡ | CRS Service | æ¥å£è°ƒç”¨ï¼Œä¸ç¼–æ’ |
| **å…ƒæ•°æ®è¯†åˆ«æå–** | âœ… ä¿ç•™ï¼Œæ ¸å¿ƒåŠŸèƒ½ | âœ… å¼ºåŒ–ï¼Œæ™ºèƒ½è¯†åˆ« | **Metadata Service** | æ ¸å¿ƒèŒè´£ |
| **å¤šåº“ç®¡ç†** | âŒ ç¼ºå¤± | âœ… æ–°å¢ï¼Œæ ¸å¿ƒåŠŸèƒ½ | **Metadata Service** | æ ¸å¿ƒèŒè´£ |
| **æ™ºèƒ½åˆ†ç±»** | âŒ ç¼ºå¤± | âœ… æ–°å¢ï¼ŒAIé©±åŠ¨åˆ†ç±» | **Metadata Service** | æ ¸å¿ƒèŒè´£ |
| **å¤šç»´åº¦æŸ¥è¯¢** | âŒ åŸºç¡€æŸ¥è¯¢ | âœ… æ—¶ç©ºå˜é‡è”åˆæŸ¥è¯¢ | **Metadata Service** | æ ¸å¿ƒèŒè´£ |
| **é…ç½®ç®¡ç†** | âŒ ç¡¬ç¼–ç  | âœ… å‚æ•°åŒ–+å¯é…ç½® | **Metadata Service** | æ ¸å¿ƒèŒè´£ |
| **æœåŠ¡ç¼–æ’** | âŒ é”™è¯¯è®¾è®¡ | âŒ **ç§»é™¤ï¼Œä¸å±äºæ­¤å±‚** | **Application Layer** | èŒè´£è½¬ç§» |

### 2.2 **çº¯ç²¹å…ƒæ•°æ®æœåŠ¡æ ¸å¿ƒåŠŸèƒ½**

#### **æ™ºèƒ½å…ƒæ•°æ®è¯†åˆ«ä¸æå–ç³»ç»Ÿ**
```cpp
namespace oscean::core_services::metadata {

// æ™ºèƒ½å…ƒæ•°æ®è¯†åˆ«å™¨ - çº¯ç²¹çš„å…ƒæ•°æ®åŠŸèƒ½
class IntelligentMetadataRecognizer {
public:
    struct RecognitionResult {
        DataType detectedDataType;          // æ£€æµ‹åˆ°çš„æ•°æ®ç±»å‹
        double confidence;                  // ç½®ä¿¡åº¦ (0-1)
        std::vector<std::string> detectedVariables; // æ£€æµ‹åˆ°çš„å˜é‡
        std::map<std::string, std::string> variableMapping; // å˜é‡æ˜ å°„
        SpatialInfo spatialInfo;            // ç©ºé—´ä¿¡æ¯
        TemporalInfo temporalInfo;          // æ—¶é—´ä¿¡æ¯
        std::vector<std::string> warnings;  // è¯†åˆ«è­¦å‘Š
    };
    
    // æ™ºèƒ½è¯†åˆ«æ–‡ä»¶å…ƒæ•°æ® - ä¸æ¶‰åŠå…¶ä»–æœåŠ¡ç¼–æ’
    boost::future<AsyncResult<RecognitionResult>> recognizeFileAsync(
        const std::string& filePath,
        const RecognitionConfiguration& config = {}
    );
    
    // æ‰¹é‡è¯†åˆ«
    boost::future<AsyncResult<std::vector<RecognitionResult>>> recognizeBatchAsync(
        const std::vector<std::string>& filePaths,
        const RecognitionConfiguration& config = {}
    );

private:
    std::shared_ptr<VariableClassifier> variableClassifier_;
    std::shared_ptr<DataTypeClassifier> dataTypeClassifier_;
    std::shared_ptr<SpatialAnalyzer> spatialAnalyzer_;
    std::shared_ptr<TemporalAnalyzer> temporalAnalyzer_;
    
    // æ³¨æ„ï¼šä¸å†åŒ…å«å…¶ä»–æœåŠ¡çš„é€‚é…å™¨ï¼Œé¿å…ç¼–æ’èŒè´£
};

} // namespace oscean::core_services::metadata
```

### 2.3 **å¤šç»´åº¦æŸ¥è¯¢ç³»ç»Ÿ - ä¸“æ³¨å…ƒæ•°æ®æŸ¥è¯¢**

```cpp
// çº¯ç²¹çš„å…ƒæ•°æ®æŸ¥è¯¢å¼•æ“
class MetadataQueryEngine {
public:
    // å¤šç»´åº¦å…ƒæ•°æ®æŸ¥è¯¢
    boost::future<AsyncResult<QueryResultSet>> executeQueryAsync(
        const MetadataQueryCriteria& criteria
    );
    
    // å…ƒæ•°æ®ç»Ÿè®¡åˆ†æ
    boost::future<AsyncResult<MetadataStatistics>> getMetadataStatisticsAsync(
        const StatisticsRequest& request
    );
    
    // æŸ¥è¯¢æ€§èƒ½åˆ†æ
    boost::future<AsyncResult<QueryPerformanceReport>> analyzeQueryPerformanceAsync(
        const MetadataQueryCriteria& criteria
    );

private:
    std::shared_ptr<MultiDatabaseQueryExecutor> queryExecutor_;
    std::shared_ptr<MetadataRanking> rankingEngine_;
    std::shared_ptr<StatisticsCalculator> statisticsCalculator_;
    
    // æ³¨æ„ï¼šåªå¤„ç†å…ƒæ•°æ®æŸ¥è¯¢ï¼Œä¸æ¶‰åŠè·¨æœåŠ¡ç¼–æ’
};
```

## ğŸ” ç¬¬ä¸‰éƒ¨åˆ†ï¼šç°æœ‰ä»£ç é‡æ„å¤„ç†æ–¹æ¡ˆ

### 3.1 **ç°æœ‰æ–‡ä»¶å¤„ç†å¯¹ç…§è¡¨**

#### **ç›´æ¥ä¿ç•™çš„æ–‡ä»¶ï¼ˆâœ… æ— éœ€ä¿®æ”¹ï¼‰**
```
core_services_impl/metadata_service/include/core_services/data_access/
â””â”€â”€ boost_future_config.h                   # âœ… ä¿ç•™ï¼šboost::futureé…ç½®å®Œå–„
```

#### **âŒ åˆ é™¤é‡å¤commonåŠŸèƒ½çš„æ–‡ä»¶**
```cpp
// âŒ åˆ é™¤ï¼šmetadata_cache.h/cpp - é‡å¤common_utilitiesç¼“å­˜åŠŸèƒ½
// ç°æœ‰å®ç°ï¼š
class MetadataCache : public IMetadataCache {
    // âŒ é‡å¤å®ç°äº†LRUç¼“å­˜ã€è¿‡æœŸæ—¶é—´ç®¡ç†ç­‰commonå·²æœ‰åŠŸèƒ½
    std::unordered_map<std::string, CacheEntry> _cacheMap;
    std::list<std::string> _lruOrder;
    std::mutex _mutex;
};

// âœ… ä½¿ç”¨common_utilitiesç¼“å­˜
namespace oscean::core_services::metadata::impl {

class MetadataServiceImpl {
private:
    // ä½¿ç”¨commonçš„ç¼“å­˜å·¥å‚ï¼Œä¸è‡ªå·±å®ç°
    std::shared_ptr<common_utils::infrastructure::ICache<std::string, DatasetMetadataEntry>> metadataCache_;
    std::shared_ptr<common_utils::infrastructure::ICache<std::string, std::vector<DatasetMetadataEntry>>> queryCache_;
    
public:
    MetadataServiceImpl(std::shared_ptr<common_utils::infrastructure::CommonServicesFactory> commonServices) {
        // ä½¿ç”¨commonçš„ç¼“å­˜æœåŠ¡ï¼Œè€Œä¸æ˜¯è‡ªå·±å®ç°
        metadataCache_ = commonServices->createCache<std::string, DatasetMetadataEntry>(
            common_utils::infrastructure::CacheConfig{
                .maxSize = 1000,
                .ttl = std::chrono::minutes(30),
                .evictionPolicy = common_utils::infrastructure::EvictionPolicy::LRU
            }
        );
        
        queryCache_ = commonServices->createCache<std::string, std::vector<DatasetMetadataEntry>>(
            common_utils::infrastructure::CacheConfig{
                .maxSize = 500,
                .ttl = std::chrono::minutes(15),
                .evictionPolicy = common_utils::infrastructure::EvictionPolicy::LRU
            }
        );
    }
};

} // namespace oscean::core_services::metadata::impl
```

#### **ä¿ç•™å¹¶æ”¹è¿›çš„æ–‡ä»¶ï¼ˆğŸ”§ ä¸“æ³¨å…ƒæ•°æ®é€»è¾‘ï¼‰**
```cpp
// ğŸ”§ metadata_extractor.h/cpp - ä¿ç•™å…ƒæ•°æ®æå–é€»è¾‘ï¼Œä½¿ç”¨commonå¼‚æ­¥æ¡†æ¶
class MetadataExtractor {
public:
    MetadataExtractor(
        std::shared_ptr<IRawDataAccessService> rawDataAccessService,
        std::shared_ptr<common_utils::infrastructure::CommonServicesFactory> commonServices
    ) : rawDataAccessService_(rawDataAccessService),
        asyncExecutor_(commonServices->getAsyncExecutor()),  // âœ… ä½¿ç”¨commonå¼‚æ­¥æ‰§è¡Œå™¨
        logger_(commonServices->getLogger("MetadataExtractor")) {}  // âœ… ä½¿ç”¨commonæ—¥å¿—
    
    // ä¸“æ³¨å…ƒæ•°æ®æå–é€»è¾‘ï¼Œä½¿ç”¨commonå¼‚æ­¥æ¡†æ¶
    boost::future<AsyncResult<IntelligentRecognitionResult>> extractWithIntelligentAnalysisAsync(
        const std::string& filePath,
        const IntelligentRecognitionConfig& config = {}
    ) {
        return asyncExecutor_->executeAsync([=]() {
            // ä¸“æ³¨å…ƒæ•°æ®è¯†åˆ«é€»è¾‘ï¼Œä¸é‡å¤å®ç°å¼‚æ­¥æ¡†æ¶
            return performIntelligentRecognition(filePath, config);
        });
    }

private:
    std::shared_ptr<IRawDataAccessService> rawDataAccessService_;
    std::shared_ptr<common_utils::async::IAsyncExecutor> asyncExecutor_;  // âœ… ä½¿ç”¨commonå¼‚æ­¥
    std::shared_ptr<common_utils::logging::ILogger> logger_;  // âœ… ä½¿ç”¨commonæ—¥å¿—
    
    // âŒ åˆ é™¤ï¼šä¸å†è‡ªå·±å®ç°å¼‚æ­¥ã€ç¼“å­˜ã€å†…å­˜ç®¡ç†ç­‰
    // std::shared_ptr<boost::asio::thread_pool> threadPool_;
    // std::unique_ptr<boost::asio::steady_timer> timer_;
};
```

```cpp
// ğŸ”§ dataset_metadata_registry.h/cpp - ä¸“æ³¨æ³¨å†Œé€»è¾‘ï¼Œä½¿ç”¨commonåŸºç¡€è®¾æ–½
class DatasetMetadataRegistry {
public:
    DatasetMetadataRegistry(
        std::shared_ptr<IDatasetMetadataRegistryBackend> backend,
        std::shared_ptr<common_utils::infrastructure::CommonServicesFactory> commonServices
    ) : backend_(backend),
        performanceMonitor_(commonServices->getPerformanceMonitor()),  // âœ… ä½¿ç”¨commonæ€§èƒ½ç›‘æ§
        logger_(commonServices->getLogger("DatasetRegistry")) {}  // âœ… ä½¿ç”¨commonæ—¥å¿—
    
    // ä¸“æ³¨æ³¨å†Œé€»è¾‘ï¼Œæ€§èƒ½ç›‘æ§ä½¿ç”¨common
    boost::future<AsyncResult<bool>> registerDatasetAsync(const DatasetMetadataEntry& entry) {
        auto timer = performanceMonitor_->startTimer("dataset_registration");  // âœ… ä½¿ç”¨commonç›‘æ§
        
        return backend_->addOrUpdateDatasetAsync(entry)
            .then([timer](bool result) {
                timer->stop();  // âœ… ä½¿ç”¨commonæ€§èƒ½ç»Ÿè®¡
                return result;
            });
    }

private:
    std::shared_ptr<IDatasetMetadataRegistryBackend> backend_;
    std::shared_ptr<common_utils::performance::IPerformanceMonitor> performanceMonitor_;  // âœ… ä½¿ç”¨common
    std::shared_ptr<common_utils::logging::ILogger> logger_;  // âœ… ä½¿ç”¨common
    
    // âŒ åˆ é™¤ï¼šä¸å†é‡å¤å®ç°æ€§èƒ½ç›‘æ§ã€æ—¥å¿—ç­‰åŠŸèƒ½
};
```

#### **éœ€è¦é‡å¤§é‡æ„çš„æ–‡ä»¶ï¼ˆğŸ”¥ ä½¿ç”¨commonåŸºç¡€è®¾æ–½ï¼‰**

```cpp
// ğŸ”¥ metadata_service_impl.h/cpp - ä½¿ç”¨commonåŸºç¡€è®¾æ–½ï¼Œä¸“æ³¨å…ƒæ•°æ®ç®¡ç†

class MetadataServiceImpl : public IMetadataService {
public:
    static std::shared_ptr<MetadataServiceImpl> create(
        std::shared_ptr<MetadataServiceContainer> container
    );
    
    // å¹¶å‘æŸ¥è¯¢ï¼šä½¿ç”¨commonå¼‚æ­¥æ¡†æ¶
    boost::future<AsyncResult<std::vector<MetadataEntry>>> queryMetadataAsync(
        const MetadataQueryCriteria& criteria
    ) override {
        // âœ… ä½¿ç”¨commonå¼‚æ­¥æ‰§è¡Œå™¨è¿›è¡Œå¹¶å‘æŸ¥è¯¢
        std::vector<boost::future<std::vector<MetadataEntry>>> futures;
        
        auto targetDatabases = determineTargetDatabases(criteria);
        
        for (auto dbType : targetDatabases) {
            // ä½¿ç”¨commonå¼‚æ­¥æ‰§è¡Œå™¨å¹¶å‘æŸ¥è¯¢æ¯ä¸ªæ•°æ®åº“
            auto future = asyncExecutor_->executeAsync([=]() {
                auto storage = multiDbManager_->getStorageForType(dbType);
                return storage->findDatasets(criteria);
            });
            futures.push_back(std::move(future));
        }
        
        // âœ… ä½¿ç”¨commonçš„futureç»„åˆ
        return common_utils::async::when_all(futures)
            .then([this](auto results) {
                return mergeAndRankResults(results);  // ä¸“æ³¨å…ƒæ•°æ®ä¸šåŠ¡é€»è¾‘
            });
    }

private:
    // âœ… ä½¿ç”¨commonæœåŠ¡ï¼Œä¸é‡å¤å®ç°
    std::shared_ptr<common_utils::async::IAsyncExecutor> asyncExecutor_;
    std::shared_ptr<common_utils::infrastructure::ICache<std::string, DatasetMetadataEntry>> metadataCache_;
    std::shared_ptr<common_utils::logging::ILogger> logger_;
    std::shared_ptr<common_utils::performance::IPerformanceMonitor> performanceMonitor_;
    
    // ä¸“æ³¨å…ƒæ•°æ®æœåŠ¡ç»„ä»¶
    std::shared_ptr<MultiDatabaseManager> multiDbManager_;
    std::shared_ptr<IntelligentMetadataRecognizer> recognizer_;
    std::shared_ptr<MetadataQueryEngine> queryEngine_;
    std::shared_ptr<VariableClassificationManager> classificationManager_;
    
    // âŒ åˆ é™¤ï¼šä¸å†é‡å¤å®ç°commonåŠŸèƒ½
    // std::shared_ptr<boost::asio::thread_pool> _threadPool;
    // std::unique_ptr<boost::asio::steady_timer> _cacheCleanupTimer;
    // std::atomic<bool> _backgroundTaskRunning{false};
    // ç¼“å­˜ç›¸å…³çš„è‡ªå®šä¹‰å®ç°å…¨éƒ¨åˆ é™¤
};
```

### 3.2 **å¤šåº“å¹¶å‘æŸ¥è¯¢æ¶æ„è®¾è®¡**

#### **ä½¿ç”¨commonå¼‚æ­¥æ¡†æ¶çš„å¹¶å‘æŸ¥è¯¢**
```cpp
// å¤šåº“å¹¶å‘æŸ¥è¯¢ç®¡ç†å™¨ - ä½¿ç”¨commonå¼‚æ­¥åŸºç¡€è®¾æ–½
class MultiDatabaseQueryEngine {
public:
    MultiDatabaseQueryEngine(
        std::shared_ptr<MultiDatabaseManager> dbManager,
        std::shared_ptr<common_utils::infrastructure::CommonServicesFactory> commonServices
    ) : dbManager_(dbManager),
        asyncExecutor_(commonServices->getAsyncExecutor()),  // âœ… ä½¿ç”¨commonå¼‚æ­¥æ‰§è¡Œå™¨
        performanceMonitor_(commonServices->getPerformanceMonitor()) {}  // âœ… ä½¿ç”¨commonæ€§èƒ½ç›‘æ§
    
    // å¹¶å‘æŸ¥è¯¢å¤šä¸ªæ•°æ®åº“
    boost::future<AsyncResult<std::vector<MetadataEntry>>> executeParallelQueryAsync(
        const MetadataQueryCriteria& criteria
    ) {
        auto timer = performanceMonitor_->startTimer("parallel_query");  // âœ… ä½¿ç”¨commonæ€§èƒ½ç›‘æ§
        
        // ç¡®å®šéœ€è¦æŸ¥è¯¢çš„æ•°æ®åº“
        auto targetDatabases = determineTargetDatabases(criteria);
        
        if (targetDatabases.empty()) {
            return boost::make_ready_future(AsyncResult<std::vector<MetadataEntry>>::success({}));
        }
        
        // âœ… ä½¿ç”¨commonå¼‚æ­¥æ‰§è¡Œå™¨å¹¶å‘æŸ¥è¯¢
        std::vector<boost::future<QueryResult>> futures;
        futures.reserve(targetDatabases.size());
        
        for (auto dbType : targetDatabases) {
            auto future = asyncExecutor_->executeAsync([=]() -> QueryResult {
                try {
                    auto storage = dbManager_->getStorageForType(dbType);
                    auto results = storage->findDatasets(criteria);
                    return QueryResult::success(dbType, std::move(results));
                } catch (const std::exception& e) {
                    return QueryResult::error(dbType, e.what());
                }
            });
            futures.push_back(std::move(future));
        }
        
        // âœ… ä½¿ç”¨commonçš„futureç»„åˆ
        return common_utils::async::when_all(futures)
            .then([timer, this](auto futureResults) -> AsyncResult<std::vector<MetadataEntry>> {
                timer->stop();  // âœ… æ€§èƒ½ç›‘æ§
                
                std::vector<MetadataEntry> allResults;
                std::vector<std::string> errors;
                
                for (auto& futureResult : futureResults) {
                    auto result = futureResult.get();
                    if (result.isSuccess()) {
                        auto& dbResults = result.getData();
                        allResults.insert(allResults.end(), dbResults.begin(), dbResults.end());
                    } else {
                        errors.push_back(result.getError());
                    }
                }
                
                // æ™ºèƒ½æ’åºå’Œå»é‡ï¼ˆä¸“æ³¨å…ƒæ•°æ®ä¸šåŠ¡é€»è¾‘ï¼‰
                auto rankedResults = rankAndDeduplicateResults(allResults);
                
                if (!errors.empty() && allResults.empty()) {
                    return AsyncResult<std::vector<MetadataEntry>>::failure(
                        "All database queries failed: " + boost::algorithm::join(errors, "; ")
                    );
                }
                
                return AsyncResult<std::vector<MetadataEntry>>::success(std::move(rankedResults));
            });
    }
    
    // æ™ºèƒ½æ•°æ®åº“è·¯ç”± - æ ¹æ®æŸ¥è¯¢æ¡ä»¶ç¡®å®šç›®æ ‡æ•°æ®åº“
    std::vector<DatabaseType> determineTargetDatabases(const MetadataQueryCriteria& criteria) {
        std::vector<DatabaseType> targets;
        
        // åŸºäºæŸ¥è¯¢æ¡ä»¶æ™ºèƒ½è·¯ç”±
        if (criteria.dataTypes.empty()) {
            // å¦‚æœæ²¡æœ‰æŒ‡å®šæ•°æ®ç±»å‹ï¼ŒæŸ¥è¯¢æ‰€æœ‰æ•°æ®åº“
            targets = {
                DatabaseType::OCEAN_ENVIRONMENT,
                DatabaseType::TOPOGRAPHY_BATHYMETRY,
                DatabaseType::BOUNDARY_LINES,
                DatabaseType::SONAR_PROPAGATION
            };
        } else {
            // æ ¹æ®æ•°æ®ç±»å‹è¿‡æ»¤
            for (auto dataType : criteria.dataTypes) {
                auto dbType = mapDataTypeToDatabase(dataType);
                if (std::find(targets.begin(), targets.end(), dbType) == targets.end()) {
                    targets.push_back(dbType);
                }
            }
        }
        
        // åŸºäºå˜é‡åæ™ºèƒ½è·¯ç”±
        if (!criteria.variablesInclude.empty()) {
            auto inferredDbs = inferDatabasesFromVariables(criteria.variablesInclude);
            for (auto db : inferredDbs) {
                if (std::find(targets.begin(), targets.end(), db) == targets.end()) {
                    targets.push_back(db);
                }
            }
        }
        
        return targets;
    }

private:
    struct QueryResult {
        DatabaseType database;
        bool success;
        std::vector<MetadataEntry> data;
        std::string error;
        
        static QueryResult success(DatabaseType db, std::vector<MetadataEntry> results) {
            return {db, true, std::move(results), ""};
        }
        
        static QueryResult error(DatabaseType db, const std::string& err) {
            return {db, false, {}, err};
        }
        
        bool isSuccess() const { return success; }
        const std::vector<MetadataEntry>& getData() const { return data; }
        const std::string& getError() const { return error; }
    };
    
    std::shared_ptr<MultiDatabaseManager> dbManager_;
    std::shared_ptr<common_utils::async::IAsyncExecutor> asyncExecutor_;  // âœ… ä½¿ç”¨commonå¼‚æ­¥
    std::shared_ptr<common_utils::performance::IPerformanceMonitor> performanceMonitor_;  // âœ… ä½¿ç”¨commonç›‘æ§
    
    // ä¸“æ³¨å…ƒæ•°æ®ä¸šåŠ¡é€»è¾‘çš„æ–¹æ³•
    std::vector<MetadataEntry> rankAndDeduplicateResults(const std::vector<MetadataEntry>& results);
    DatabaseType mapDataTypeToDatabase(const std::string& dataType);
    std::vector<DatabaseType> inferDatabasesFromVariables(const std::vector<std::string>& variables);
};
```

### 3.3 **æ¸…ç†åçš„æ¶æ„è®¾è®¡**

#### **å…ƒæ•°æ®æœåŠ¡åªä¸“æ³¨æ ¸å¿ƒä¸šåŠ¡é€»è¾‘**
```cpp
namespace oscean::core_services::metadata {

// çº¯ç²¹çš„å…ƒæ•°æ®æœåŠ¡å·¥å‚ - ä½¿ç”¨commonä¾èµ–æ³¨å…¥
class MetadataServiceFactory {
public:
    static std::shared_ptr<IMetadataService> create(
        std::shared_ptr<common_utils::infrastructure::CommonServicesFactory> commonServices,
        const MetadataServiceConfiguration& config
    ) {
        // âœ… ä½¿ç”¨commonçš„ä¾èµ–æ³¨å…¥å®¹å™¨
        auto container = commonServices->createDependencyContainer();
        
        // æ³¨å†Œå…ƒæ•°æ®ä¸“ç”¨ç»„ä»¶
        container->registerSingleton<MultiDatabaseManager>(
            [=]() { return std::make_shared<MultiDatabaseManager>(config.databaseConfig, commonServices); }
        );
        
        container->registerSingleton<IntelligentMetadataRecognizer>(
            [=]() { return std::make_shared<IntelligentMetadataRecognizer>(commonServices); }
        );
        
        container->registerSingleton<MultiDatabaseQueryEngine>(
            [=]() { 
                auto dbManager = container->resolve<MultiDatabaseManager>();
                return std::make_shared<MultiDatabaseQueryEngine>(dbManager, commonServices);
            }
        );
        
        // åˆ›å»ºä¸»æœåŠ¡
        return container->resolve<MetadataServiceImpl>();
    }
};

// çº¯ç²¹çš„å…ƒæ•°æ®æœåŠ¡å®ç° - ä¸“æ³¨ä¸šåŠ¡é€»è¾‘
class MetadataServiceImpl : public IMetadataService {
public:
    MetadataServiceImpl(
        std::shared_ptr<MultiDatabaseManager> dbManager,
        std::shared_ptr<IntelligentMetadataRecognizer> recognizer,
        std::shared_ptr<MultiDatabaseQueryEngine> queryEngine,
        std::shared_ptr<common_utils::infrastructure::CommonServicesFactory> commonServices
    ) : dbManager_(dbManager),
        recognizer_(recognizer),
        queryEngine_(queryEngine),
        // âœ… ä½¿ç”¨commonæœåŠ¡
        metadataCache_(commonServices->createCache<std::string, DatasetMetadataEntry>("metadata_cache", 1000)),
        queryCache_(commonServices->createCache<std::string, std::vector<MetadataEntry>>("query_cache", 500)),
        logger_(commonServices->getLogger("MetadataService")) {}
    
    // å…ƒæ•°æ®æå– - ä¸“æ³¨ä¸šåŠ¡é€»è¾‘
    boost::future<AsyncResult<ExtractedMetadata>> extractMetadataAsync(
        const std::string& filePath,
        const std::optional<DataTypeHint>& hint = std::nullopt
    ) override {
        // å…ˆæ£€æŸ¥ç¼“å­˜ âœ… ä½¿ç”¨commonç¼“å­˜
        auto cached = metadataCache_->get(filePath);
        if (cached) {
            logger_->debug("Cache hit for metadata extraction: {}", filePath);
            return boost::make_ready_future(AsyncResult<ExtractedMetadata>::success(*cached));
        }
        
        // æ‰§è¡Œæ™ºèƒ½è¯†åˆ«
        return recognizer_->recognizeFileAsync(filePath)
            .then([this, filePath](auto result) -> AsyncResult<ExtractedMetadata> {
                if (result.isSuccess()) {
                    auto extracted = result.getData();
                    // âœ… ä½¿ç”¨commonç¼“å­˜å­˜å‚¨ç»“æœ
                    metadataCache_->put(filePath, extracted);
                    logger_->debug("Metadata extracted and cached: {}", filePath);
                    return AsyncResult<ExtractedMetadata>::success(std::move(extracted));
                } else {
                    logger_->warn("Metadata extraction failed: {}", result.getError());
                    return AsyncResult<ExtractedMetadata>::failure(result.getError());
                }
            });
    }
    
    // å¹¶å‘æŸ¥è¯¢ - ä½¿ç”¨ä¸“ç”¨æŸ¥è¯¢å¼•æ“
    boost::future<AsyncResult<std::vector<MetadataEntry>>> queryMetadataAsync(
        const MetadataQueryCriteria& criteria
    ) override {
        // ç”ŸæˆæŸ¥è¯¢ç¼“å­˜é”®
        auto cacheKey = generateQueryCacheKey(criteria);
        
        // æ£€æŸ¥æŸ¥è¯¢ç¼“å­˜ âœ… ä½¿ç”¨commonç¼“å­˜
        auto cached = queryCache_->get(cacheKey);
        if (cached) {
            logger_->debug("Cache hit for metadata query");
            return boost::make_ready_future(AsyncResult<std::vector<MetadataEntry>>::success(*cached));
        }
        
        // æ‰§è¡Œå¹¶å‘æŸ¥è¯¢
        return queryEngine_->executeParallelQueryAsync(criteria)
            .then([this, cacheKey](auto result) -> AsyncResult<std::vector<MetadataEntry>> {
                if (result.isSuccess()) {
                    auto results = result.getData();
                    // âœ… ä½¿ç”¨commonç¼“å­˜å­˜å‚¨æŸ¥è¯¢ç»“æœ
                    queryCache_->put(cacheKey, results);
                    logger_->debug("Query results cached, count: {}", results.size());
                    return AsyncResult<std::vector<MetadataEntry>>::success(std::move(results));
                } else {
                    logger_->warn("Metadata query failed: {}", result.getError());
                    return result;
                }
            });
    }

private:
    // ä¸“æ³¨å…ƒæ•°æ®ä¸šåŠ¡ç»„ä»¶
    std::shared_ptr<MultiDatabaseManager> dbManager_;
    std::shared_ptr<IntelligentMetadataRecognizer> recognizer_;
    std::shared_ptr<MultiDatabaseQueryEngine> queryEngine_;
    
    // âœ… ä½¿ç”¨commonåŸºç¡€è®¾æ–½
    std::shared_ptr<common_utils::infrastructure::ICache<std::string, DatasetMetadataEntry>> metadataCache_;
    std::shared_ptr<common_utils::infrastructure::ICache<std::string, std::vector<MetadataEntry>>> queryCache_;
    std::shared_ptr<common_utils::logging::ILogger> logger_;
    
    // ä¸“æ³¨ä¸šåŠ¡é€»è¾‘çš„è¾…åŠ©æ–¹æ³•
    std::string generateQueryCacheKey(const MetadataQueryCriteria& criteria);
};

} // namespace oscean::core_services::metadata
```

### 3.4 **é‡æ„å®æ–½ä¼˜å…ˆçº§ä¿®æ­£**

#### **é˜¶æ®µ1ï¼šæ¸…ç†é‡å¤åŠŸèƒ½ï¼ˆ1å‘¨ï¼‰**
1. **åˆ é™¤é‡å¤commonçš„æ–‡ä»¶**
   - åˆ é™¤ `metadata_cache.h/cpp` 
   - åˆ é™¤æ‰€æœ‰è‡ªå®šä¹‰å¼‚æ­¥ã€çº¿ç¨‹æ± ã€å®šæ—¶å™¨å®ç°
   - åˆ é™¤è‡ªå®šä¹‰æ€§èƒ½ç›‘æ§ã€æ—¥å¿—å®ç°

2. **é›†æˆcommonæœåŠ¡**
   - ä½¿ç”¨ `common_utils::infrastructure::CommonServicesFactory`
   - ä½¿ç”¨ `common_utils::async::IAsyncExecutor` 
   - ä½¿ç”¨ `common_utils::infrastructure::ICache`

#### **é˜¶æ®µ2ï¼šå¹¶å‘æŸ¥è¯¢å®ç°ï¼ˆ2å‘¨ï¼‰**
1. å®ç° `MultiDatabaseQueryEngine` ä½¿ç”¨commonå¼‚æ­¥æ¡†æ¶
2. å®ç°æ™ºèƒ½æ•°æ®åº“è·¯ç”±
3. ä¼˜åŒ–å¹¶å‘æŸ¥è¯¢æ€§èƒ½

#### **é˜¶æ®µ3ï¼šå…ƒæ•°æ®ä¸šåŠ¡é€»è¾‘ï¼ˆ2å‘¨ï¼‰**
1. ä¸“æ³¨æ™ºèƒ½å…ƒæ•°æ®è¯†åˆ«
2. å®ç°å˜é‡åˆ†ç±»å’Œæ•°æ®ç±»å‹è¯†åˆ«
3. å®Œå–„å¤šåº“ç®¡ç†

#### **é˜¶æ®µ4ï¼šé›†æˆæµ‹è¯•ï¼ˆ1å‘¨ï¼‰**
1. å¹¶å‘æŸ¥è¯¢æ€§èƒ½æµ‹è¯•
2. å¤šåº“æ•°æ®ä¸€è‡´æ€§æµ‹è¯•
3. ä¸commonæœåŠ¡é›†æˆæµ‹è¯•

## ğŸ” ç¬¬å››éƒ¨åˆ†ï¼šæ•°æ®åº“é…ç½®ç®¡ç†è¯¦ç»†æ–¹æ¡ˆ

### 4.1 **æ•°æ®åº“é…ç½®ç®¡ç†æ¨¡å—è®¾è®¡**

#### **æ•°æ®åº“é…ç½®ç®¡ç†æ¥å£**
```cpp
namespace oscean::core_services::metadata {

// æ•°æ®åº“é…ç½®ç®¡ç†æ¥å£
class IDatabaseConfigurationManager {
public:
    virtual boost::future<AsyncResult<void>> updateConfigurationAsync(
        const DatabaseConfiguration& config
    ) = 0;
    
    virtual boost::future<AsyncResult<DatabaseConfiguration>> getConfigurationAsync() = 0;
};

} // namespace oscean::core_services::metadata
```

#### **æ•°æ®åº“é…ç½®ç®¡ç†å®ç°**
```cpp
namespace oscean::core_services::metadata::impl {

// æ•°æ®åº“é…ç½®ç®¡ç†å®ç°
class DatabaseConfigurationManager : public IDatabaseConfigurationManager {
public:
    boost::future<AsyncResult<void>> updateConfigurationAsync(
        const DatabaseConfiguration& config
    ) override;
    
    boost::future<AsyncResult<DatabaseConfiguration>> getConfigurationAsync() override;

private:
    DatabaseConfiguration currentConfiguration_;
};

} // namespace oscean::core_services::metadata::impl
```

### 4.2 **æ•°æ®åº“è‡ªåŠ¨æ›´æ–°æ¨¡å—è®¾è®¡**

#### **æ•°æ®åº“è‡ªåŠ¨æ›´æ–°æ¥å£**
```cpp
namespace oscean::core_services::metadata {

// æ•°æ®åº“è‡ªåŠ¨æ›´æ–°æ¥å£
class IAutoUpdateManager {
public:
    virtual boost::future<AsyncResult<void>> updateDatabaseAsync(
        const std::string& databasePath
    ) = 0;
};

} // namespace oscean::core_services::metadata
```

#### **æ•°æ®åº“è‡ªåŠ¨æ›´æ–°å®ç°**
```cpp
namespace oscean::core_services::metadata::impl {

// æ•°æ®åº“è‡ªåŠ¨æ›´æ–°å®ç°
class AutoUpdateManager : public IAutoUpdateManager {
public:
    boost::future<AsyncResult<void>> updateDatabaseAsync(
        const std::string& databasePath
    ) override;
};

} // namespace oscean::core_services::metadata::impl
```

## ğŸ¯ **ä¿®æ­£åçš„å®æ–½è®¡åˆ’**

### Phase 1: çº¯ç²¹å…ƒæ•°æ®æœåŠ¡å®ç° (3å‘¨)
1. **æ ¸å¿ƒå…ƒæ•°æ®æœåŠ¡æ¶æ„**
   - `MetadataServiceFactory`
   - `MetadataServiceContainer`
   - çº¯ç²¹å¼‚æ­¥æ¥å£å®šä¹‰

2. **å¤šåº“æ¶æ„å®ç°**
   - `MultiDatabaseManager`
   - å››ç§æ•°æ®åº“Schemaè®¾è®¡
   - æ•°æ®åº“è¿æ¥æ± ç®¡ç†

### Phase 2: æ™ºèƒ½å…ƒæ•°æ®åŠŸèƒ½ (4å‘¨)  
3. **æ™ºèƒ½è¯†åˆ«ç³»ç»Ÿ**
   - `IntelligentMetadataRecognizer`
   - `VariableClassifier`
   - `SpatialAnalyzer`

4. **é…ç½®ç®¡ç†ç³»ç»Ÿ**
   - `VariableClassificationManager`
   - YAMLé…ç½®æ–‡ä»¶å¤„ç†
   - è¿è¡Œæ—¶é…ç½®æ›´æ–°

### Phase 3: æŸ¥è¯¢ç³»ç»Ÿå®ç° (2å‘¨)
5. **å…ƒæ•°æ®æŸ¥è¯¢å¼•æ“**
   - `MetadataQueryEngine`
   - å¤šç»´åº¦æŸ¥è¯¢æ¡ä»¶å¤„ç†
   - æ™ºèƒ½æ’åºå’Œæ¨è

### Phase 4: åº”ç”¨å±‚é›†æˆ (2å‘¨)
6. **å·¥ä½œæµå±‚å®ç°**
   - `MetadataProcessingWorkflow`ï¼ˆåº”ç”¨å±‚ï¼‰
   - æœåŠ¡é—´åè°ƒé€»è¾‘
   - é”™è¯¯å¤„ç†ç»Ÿä¸€

### Phase 5: æµ‹è¯•å’Œä¼˜åŒ– (1å‘¨)
7. **å…¨é¢æµ‹è¯•**
   - å•å…ƒæµ‹è¯•
   - é›†æˆæµ‹è¯•
   - æ€§èƒ½æµ‹è¯•

## ğŸ“Š **ä¿®æ­£åçš„éªŒæ”¶æ ‡å‡†**

### æ¶æ„çº¯å‡€åº¦éªŒæ”¶
- [ ] 100% å…ƒæ•°æ®æœåŠ¡èŒè´£å•ä¸€
- [ ] 0% æœåŠ¡ç¼–æ’é€»è¾‘åœ¨å…ƒæ•°æ®æœåŠ¡ä¸­
- [ ] 100% boost::futureå¼‚æ­¥æ¥å£  
- [ ] 100% å·¥å‚æ¨¡å¼åˆ›å»ºæœåŠ¡

### æ¨¡å—ç‹¬ç«‹æ€§éªŒæ”¶
- [ ] å…ƒæ•°æ®æœåŠ¡å¯ç‹¬ç«‹æµ‹è¯•
- [ ] å…ƒæ•°æ®æœåŠ¡å¯ç‹¬ç«‹éƒ¨ç½²
- [ ] ä¸å…¶ä»–æœåŠ¡ä»…é€šè¿‡æ¥å£äº¤äº’
- [ ] 0% ç›´æ¥ä¾èµ–å…¶ä»–æœåŠ¡å®ç°

### åŠŸèƒ½å®Œæ•´æ€§éªŒæ”¶
- [ ] æ”¯æŒå››ç§æ•°æ®ç±»å‹å¤šåº“ç®¡ç†
- [ ] æ™ºèƒ½å˜é‡è¯†åˆ«å‡†ç¡®ç‡ > 95%
- [ ] å…ƒæ•°æ®æŸ¥è¯¢å“åº”æ—¶é—´ < 200ms
- [ ] é…ç½®çƒ­æ›´æ–°æ”¯æŒ

---

## ğŸ“ **ä¿®æ­£æ€»ç»“**

æ„Ÿè°¢æ‚¨æŒ‡å‡ºçš„æ¶æ„é—®é¢˜ï¼ä¿®æ­£åçš„æ–¹æ¡ˆï¼š

1. **èŒè´£æ˜ç¡®**ï¼šå…ƒæ•°æ®æœåŠ¡ä¸“æ³¨äºå…ƒæ•°æ®ç®¡ç†ï¼Œä¸æ¶‰åŠæœåŠ¡ç¼–æ’
2. **å±‚æ¬¡æ¸…æ™°**ï¼šæœåŠ¡ç¼–æ’èŒè´£è½¬ç§»åˆ°åº”ç”¨å±‚æˆ–å·¥ä½œæµå¼•æ“
3. **æ¥å£çº¯å‡€**ï¼šä¸å…¶ä»–æœåŠ¡ä»…é€šè¿‡æ¥å£äº¤äº’ï¼Œä¸ç›´æ¥ä¾èµ–
4. **æ¨¡å—ç‹¬ç«‹**ï¼šå…ƒæ•°æ®æœåŠ¡å¯ç‹¬ç«‹å¼€å‘ã€æµ‹è¯•ã€éƒ¨ç½²

è¿™æ ·è®¾è®¡æ‰ç¬¦åˆ**å•ä¸€èŒè´£åŸåˆ™**å’Œ**æ¨¡å—åŒ–æ¶æ„**çš„æœ€ä½³å®è·µã€‚ 

## ğŸ” ç¬¬äº”éƒ¨åˆ†ï¼šé‡æ„åå®Œæ•´ç›®å½•ç»“æ„

### 5.1 **é‡æ„åç›®å½•ç»“æ„æ€»è§ˆ**

```
core_services_impl/metadata_service/
â”œâ”€â”€ CMakeLists.txt                                    # CMakeæ„å»ºé…ç½®
â”œâ”€â”€ include/                                          # å…¬å…±æ¥å£å¤´æ–‡ä»¶
â”‚   â””â”€â”€ core_services/
â”‚       â”œâ”€â”€ data_access/
â”‚       â”‚   â””â”€â”€ boost_future_config.h                # âœ… ä¿ç•™ï¼šboost::futureé…ç½®
â”‚       â””â”€â”€ metadata/
â”‚           â”œâ”€â”€ metadata_service_interface.h         # å…ƒæ•°æ®æœåŠ¡æ¥å£å®šä¹‰
â”‚           â”œâ”€â”€ metadata_types.h                     # å…ƒæ•°æ®ç±»å‹å®šä¹‰
â”‚           â”œâ”€â”€ query_criteria.h                     # æŸ¥è¯¢æ¡ä»¶å®šä¹‰
â”‚           â””â”€â”€ impl/
â”‚               â”œâ”€â”€ metadata_service_factory.h       # å…ƒæ•°æ®æœåŠ¡å·¥å‚
â”‚               â”œâ”€â”€ multi_database_manager.h         # å¤šåº“ç®¡ç†å™¨
â”‚               â”œâ”€â”€ intelligent_recognizer.h         # æ™ºèƒ½è¯†åˆ«å™¨
â”‚               â”œâ”€â”€ query_engine.h                   # å¹¶å‘æŸ¥è¯¢å¼•æ“
â”‚               â”œâ”€â”€ variable_classifier.h            # å˜é‡åˆ†ç±»å™¨
â”‚               â”œâ”€â”€ database_types.h                 # æ•°æ®åº“ç±»å‹å®šä¹‰
â”‚               â””â”€â”€ configuration_manager.h          # é…ç½®ç®¡ç†å™¨
â”œâ”€â”€ src/                                             # å®ç°æ–‡ä»¶
â”‚   â”œâ”€â”€ factory/                                     # å·¥å‚å®ç°
â”‚   â”‚   â””â”€â”€ metadata_service_factory.cpp            # æœåŠ¡å·¥å‚å®ç°ï¼ˆç®€åŒ–ç‰ˆï¼‰
â”‚   â”œâ”€â”€ core/                                        # æ ¸å¿ƒæœåŠ¡å®ç°  
â”‚   â”‚   â”œâ”€â”€ metadata_service_impl.cpp               # ğŸ”¥ é‡æ„ï¼šä¸»æœåŠ¡å®ç°
â”‚   â”‚   â”œâ”€â”€ metadata_extractor.cpp                  # ğŸ”§ æ”¹è¿›ï¼šå…ƒæ•°æ®æå–å™¨
â”‚   â”‚   â””â”€â”€ dataset_metadata_registry.cpp           # ğŸ”§ æ”¹è¿›ï¼šæ•°æ®é›†æ³¨å†Œè¡¨
â”‚   â”œâ”€â”€ database/                                    # æ•°æ®åº“ç®¡ç†
â”‚   â”‚   â”œâ”€â”€ multi_database_manager.cpp              # å¤šåº“ç®¡ç†å™¨å®ç°
â”‚   â”‚   â”œâ”€â”€ database_router.cpp                     # æ™ºèƒ½æ•°æ®åº“è·¯ç”±
â”‚   â”‚   â”œâ”€â”€ sqlite_storage_extended.cpp             # æ‰©å±•SQLiteå­˜å‚¨
â”‚   â”‚   â””â”€â”€ schema/                                  # æ•°æ®åº“æ¨¡å¼
â”‚   â”‚       â”œâ”€â”€ ocean_environment_schema.sql        # æµ·æ´‹ç¯å¢ƒæ•°æ®åº“æ¨¡å¼
â”‚   â”‚       â”œâ”€â”€ topography_bathymetry_schema.sql    # åœ°å½¢åº•è´¨æ•°æ®åº“æ¨¡å¼
â”‚   â”‚       â”œâ”€â”€ boundary_lines_schema.sql           # è¾¹ç•Œçº¿æ•°æ®åº“æ¨¡å¼
â”‚   â”‚       â””â”€â”€ sonar_propagation_schema.sql        # å£°çº³ä¼ æ’­æ•°æ®åº“æ¨¡å¼
â”‚   â”œâ”€â”€ intelligent/                                 # æ™ºèƒ½è¯†åˆ«æ¨¡å—
â”‚   â”‚   â”œâ”€â”€ metadata_recognizer.cpp                 # æ™ºèƒ½å…ƒæ•°æ®è¯†åˆ«
â”‚   â”‚   â”œâ”€â”€ variable_classifier.cpp                 # å˜é‡åˆ†ç±»å™¨
â”‚   â”‚   â”œâ”€â”€ data_type_classifier.cpp                # æ•°æ®ç±»å‹åˆ†ç±»å™¨
â”‚   â”‚   â”œâ”€â”€ spatial_analyzer.cpp                    # ç©ºé—´åˆ†æå™¨
â”‚   â”‚   â””â”€â”€ temporal_analyzer.cpp                   # æ—¶é—´åˆ†æå™¨
â”‚   â”œâ”€â”€ query/                                       # æŸ¥è¯¢å¼•æ“
â”‚   â”‚   â”œâ”€â”€ multi_database_query_engine.cpp         # å¹¶å‘æŸ¥è¯¢å¼•æ“
â”‚   â”‚   â”œâ”€â”€ query_optimizer.cpp                     # æŸ¥è¯¢ä¼˜åŒ–å™¨
â”‚   â”‚   â”œâ”€â”€ result_merger.cpp                       # ç»“æœåˆå¹¶å™¨
â”‚   â”‚   â””â”€â”€ ranking_engine.cpp                      # æ’åºå¼•æ“
â”‚   â””â”€â”€ configuration/                               # é…ç½®ç®¡ç†
â”‚       â”œâ”€â”€ configuration_manager.cpp               # é…ç½®ç®¡ç†å™¨
â”‚       â”œâ”€â”€ variable_classification_config.cpp      # å˜é‡åˆ†ç±»é…ç½®
â”‚       â””â”€â”€ database_configuration.cpp              # æ•°æ®åº“é…ç½®
â”œâ”€â”€ config/                                          # é…ç½®æ–‡ä»¶
â”‚   â”œâ”€â”€ variable_classification.yaml                # å˜é‡åˆ†ç±»é…ç½®
â”‚   â”œâ”€â”€ database_config.yaml                        # æ•°æ®åº“é…ç½®
â”‚   â””â”€â”€ metadata_service_config.yaml                # æœåŠ¡é…ç½®
â”œâ”€â”€ databases/                                       # æ•°æ®åº“æ–‡ä»¶ç›®å½•
â”‚   â”œâ”€â”€ ocean_environment.db                        # æµ·æ´‹ç¯å¢ƒæ•°æ®åº“
â”‚   â”œâ”€â”€ topography_bathymetry.db                    # åœ°å½¢åº•è´¨æ•°æ®åº“
â”‚   â”œâ”€â”€ boundary_lines.db                           # è¾¹ç•Œçº¿æ•°æ®åº“
â”‚   â””â”€â”€ sonar_propagation.db                        # å£°çº³ä¼ æ’­æ•°æ®åº“
â”œâ”€â”€ tests/                                           # æµ‹è¯•æ–‡ä»¶
â”‚   â”œâ”€â”€ unit/                                        # å•å…ƒæµ‹è¯•
â”‚   â”‚   â”œâ”€â”€ test_metadata_service.cpp               # æœåŠ¡æµ‹è¯•
â”‚   â”‚   â”œâ”€â”€ test_multi_database_manager.cpp         # å¤šåº“ç®¡ç†æµ‹è¯•
â”‚   â”‚   â”œâ”€â”€ test_intelligent_recognizer.cpp         # æ™ºèƒ½è¯†åˆ«æµ‹è¯•
â”‚   â”‚   â”œâ”€â”€ test_query_engine.cpp                   # æŸ¥è¯¢å¼•æ“æµ‹è¯•
â”‚   â”‚   â””â”€â”€ test_variable_classifier.cpp            # å˜é‡åˆ†ç±»æµ‹è¯•
â”‚   â”œâ”€â”€ integration/                                 # é›†æˆæµ‹è¯•
â”‚   â”‚   â”œâ”€â”€ test_end_to_end_workflow.cpp            # ç«¯åˆ°ç«¯æµ‹è¯•
â”‚   â”‚   â”œâ”€â”€ test_concurrent_queries.cpp             # å¹¶å‘æŸ¥è¯¢æµ‹è¯•
â”‚   â”‚   â””â”€â”€ test_database_integration.cpp           # æ•°æ®åº“é›†æˆæµ‹è¯•
â”‚   â”œâ”€â”€ performance/                                 # æ€§èƒ½æµ‹è¯•
â”‚   â”‚   â”œâ”€â”€ benchmark_concurrent_queries.cpp        # å¹¶å‘æŸ¥è¯¢åŸºå‡†æµ‹è¯•
â”‚   â”‚   â””â”€â”€ benchmark_intelligent_recognition.cpp   # æ™ºèƒ½è¯†åˆ«æ€§èƒ½æµ‹è¯•
â”‚   â”œâ”€â”€ mocks/                                       # æµ‹è¯•æ¨¡æ‹Ÿ
â”‚   â”‚   â”œâ”€â”€ mock_common_services.h                  # CommonæœåŠ¡æ¨¡æ‹Ÿ
â”‚   â”‚   â””â”€â”€ mock_database_storage.h                 # æ•°æ®åº“å­˜å‚¨æ¨¡æ‹Ÿ
â”‚   â””â”€â”€ test_data/                                   # æµ‹è¯•æ•°æ®
â”‚       â”œâ”€â”€ sample_ocean_data.nc                    # æµ·æ´‹æ•°æ®æ ·æœ¬
â”‚       â”œâ”€â”€ sample_topography.tif                   # åœ°å½¢æ•°æ®æ ·æœ¬
â”‚       â””â”€â”€ sample_config.yaml                      # é…ç½®æ ·æœ¬
â””â”€â”€ docs/                                            # æ–‡æ¡£
    â”œâ”€â”€ api_reference.md                             # APIå‚è€ƒæ–‡æ¡£
    â”œâ”€â”€ configuration_guide.md                      # é…ç½®æŒ‡å—
    â”œâ”€â”€ database_schema.md                          # æ•°æ®åº“æ¨¡å¼æ–‡æ¡£
    â””â”€â”€ performance_tuning.md                       # æ€§èƒ½è°ƒä¼˜æŒ‡å—
```

### 5.2 **âŒ å·²åˆ é™¤çš„ä¸å¿…è¦æ–‡ä»¶**

```
# ä»¥ä¸‹æ–‡ä»¶å·²åˆ é™¤ï¼Œä¸å±äºå…ƒæ•°æ®æœåŠ¡èŒè´£ï¼š

âŒ src/adapters/data_access_adapter.cpp              # åˆ é™¤ï¼šä¸åº”é€‚é…å…¶ä»–æœåŠ¡
âŒ src/adapters/crs_service_adapter.cpp              # åˆ é™¤ï¼šä¸åº”é€‚é…å…¶ä»–æœåŠ¡
âŒ src/adapters/ ç›®å½•                                 # åˆ é™¤ï¼šå…ƒæ•°æ®æœåŠ¡ä¸åº”åŒ…å«é€‚é…å™¨

# åˆ é™¤è¿‡åº¦è®¾è®¡çš„å¤æ‚ç»„ä»¶ï¼š
âŒ src/factory/dependency_container.cpp              # åˆ é™¤ï¼šCommonServicesFactoryå·²æä¾›ä¾èµ–ç®¡ç†
âŒ å¤æ‚çš„ä¾èµ–æ³¨å…¥å®¹å™¨å®ç°                              # åˆ é™¤ï¼šé¿å…é‡å¤å®ç°ï¼Œä¿æŒç®€å•

# é‡å¤çš„commonåŠŸèƒ½æ–‡ä»¶ï¼š
âŒ src/impl/cache/metadata_cache.h                   # åˆ é™¤ï¼šé‡å¤LRUç¼“å­˜å®ç°
âŒ src/impl/cache/metadata_cache.cpp                 # åˆ é™¤ï¼šä½¿ç”¨commonç¼“å­˜
âŒ src/impl/metadata_service_tasks.cpp               # åˆ é™¤ï¼šç¼–è¯‘é”™è¯¯ï¼Œé‡å¤å¼‚æ­¥å®ç°
âŒ src/impl/storage/sqlite_storage.h                 # åˆ é™¤ï¼šå•åº“è®¾è®¡è¿‡æ—¶
âŒ src/impl/storage/sqlite_storage.cpp               # åˆ é™¤ï¼šé‡æ„ä¸ºå¤šåº“ç®¡ç†

# é‡å¤çš„åŸºç¡€è®¾æ–½å®ç°ï¼š
âŒ è‡ªå®šä¹‰çº¿ç¨‹æ± å®ç°                                    # ä½¿ç”¨commonå¼‚æ­¥æ‰§è¡Œå™¨
âŒ è‡ªå®šä¹‰å®šæ—¶å™¨å’Œè°ƒåº¦å™¨                                # ä½¿ç”¨commonè°ƒåº¦å™¨
âŒ è‡ªå®šä¹‰æ€§èƒ½ç›‘æ§                                      # ä½¿ç”¨commonæ€§èƒ½ç›‘æ§
âŒ è‡ªå®šä¹‰æ—¥å¿—å®ç°                                      # ä½¿ç”¨commonæ—¥å¿—ç³»ç»Ÿ
âŒ è‡ªå®šä¹‰å†…å­˜ç®¡ç†                                      # ä½¿ç”¨commonå†…å­˜ç®¡ç†
```

### 5.3 **æ ¸å¿ƒæ–‡ä»¶è¯¦ç»†è¯´æ˜**

#### **5.3.1 å…ƒæ•°æ®æœåŠ¡å·¥å‚ - åªä¾èµ–CommonServicesFactory**

```cpp
// include/core_services/metadata/impl/metadata_service_factory.h
#pragma once
#include "common_utils/infrastructure/common_services_factory.h"  // âœ… åªä¾èµ–ç»Ÿä¸€æ¥å£
#include "metadata_service_interface.h"

namespace oscean::core_services::metadata {

class MetadataServiceFactory {
public:
    /**
     * @brief åˆ›å»ºå…ƒæ•°æ®æœåŠ¡ - ç®€åŒ–å·¥å‚æ¨¡å¼ï¼Œç›´æ¥ä½¿ç”¨CommonServicesFactory
     * 
     * ä¸éœ€è¦å¤æ‚çš„ä¾èµ–å®¹å™¨ï¼Œç›´æ¥é€šè¿‡CommonServicesFactoryè·å–æœåŠ¡ï¼š
     * - å†…å­˜ç®¡ç†ï¼šmemory manager
     * - å¼‚æ­¥æ‰§è¡Œï¼šasync executor  
     * - ç¼“å­˜æœåŠ¡ï¼šcache factory
     * - æ—¥å¿—æœåŠ¡ï¼šlogger
     * - æ€§èƒ½ç›‘æ§ï¼šperformance monitor
     * 
     * ä¿æŒç®€å•ç›´æ¥ï¼Œé¿å…è¿‡åº¦è®¾è®¡
     */
    static std::shared_ptr<IMetadataService> create(
        std::shared_ptr<common_utils::infrastructure::CommonServicesFactory> commonServices,
        const MetadataServiceConfiguration& config
    );

private:
    // ç®€åŒ–çš„ç»„ä»¶åˆ›å»ºæ–¹æ³•
    static std::shared_ptr<MultiDatabaseManager> createDatabaseManager(
        const MetadataServiceConfiguration& config,
        std::shared_ptr<common_utils::infrastructure::CommonServicesFactory> commonServices
    );
    
    static std::shared_ptr<IntelligentMetadataRecognizer> createRecognizer(
        std::shared_ptr<common_utils::infrastructure::CommonServicesFactory> commonServices
    );
    
    static std::shared_ptr<MultiDatabaseQueryEngine> createQueryEngine(
        std::shared_ptr<MultiDatabaseManager> dbManager,
        std::shared_ptr<common_utils::infrastructure::CommonServicesFactory> commonServices
    );
};

} // namespace oscean::core_services::metadata
```

```cpp
// src/factory/metadata_service_factory.cpp
#include "core_services/metadata/impl/metadata_service_factory.h"
#include "core_services/metadata/impl/metadata_service_impl.h"
#include "core_services/metadata/impl/multi_database_manager.h"
#include "core_services/metadata/impl/intelligent_recognizer.h"
#include "core_services/metadata/impl/query_engine.h"

namespace oscean::core_services::metadata {

std::shared_ptr<IMetadataService> MetadataServiceFactory::create(
    std::shared_ptr<common_utils::infrastructure::CommonServicesFactory> commonServices,
    const MetadataServiceConfiguration& config
) {
    // âœ… ç›´æ¥ä½¿ç”¨CommonServicesFactoryï¼Œæ— éœ€å¤æ‚çš„ä¾èµ–å®¹å™¨
    auto logger = commonServices->getLogger("MetadataServiceFactory");
    logger->info("Creating metadata service with configuration: {}", config.toString());
    
    try {
        // ç®€å•ç›´æ¥çš„ç»„ä»¶åˆ›å»º
        auto dbManager = createDatabaseManager(config, commonServices);
        auto recognizer = createRecognizer(commonServices);
        auto queryEngine = createQueryEngine(dbManager, commonServices);
        
        // ç›´æ¥æ„é€ ä¸»æœåŠ¡ï¼Œæ— éœ€å¤æ‚çš„å®¹å™¨
        auto metadataService = std::make_shared<impl::MetadataServiceImpl>(
            dbManager,
            recognizer, 
            queryEngine,
            commonServices
        );
        
        logger->info("Metadata service created successfully");
        return metadataService;
        
    } catch (const std::exception& e) {
        logger->error("Failed to create metadata service: {}", e.what());
        throw;
    }
}

// ç®€åŒ–çš„ç»„ä»¶åˆ›å»ºæ–¹æ³•
std::shared_ptr<MultiDatabaseManager> MetadataServiceFactory::createDatabaseManager(
    const MetadataServiceConfiguration& config,
    std::shared_ptr<common_utils::infrastructure::CommonServicesFactory> commonServices
) {
    return std::make_shared<impl::MultiDatabaseManager>(config.databaseConfig, commonServices);
}

std::shared_ptr<IntelligentMetadataRecognizer> MetadataServiceFactory::createRecognizer(
    std::shared_ptr<common_utils::infrastructure::CommonServicesFactory> commonServices
) {
    return std::make_shared<impl::IntelligentMetadataRecognizer>(commonServices);
}

std::shared_ptr<MultiDatabaseQueryEngine> MetadataServiceFactory::createQueryEngine(
    std::shared_ptr<MultiDatabaseManager> dbManager,
    std::shared_ptr<common_utils::infrastructure::CommonServicesFactory> commonServices
) {
    return std::make_shared<impl::MultiDatabaseQueryEngine>(dbManager, commonServices);
}

} // namespace oscean::core_services::metadata
```

#### **5.3.2 ä¸»æœåŠ¡å®ç° - ä¸“æ³¨å…ƒæ•°æ®æ ¸å¿ƒä¸šåŠ¡**

```cpp
// src/core/metadata_service_impl.cpp
#include "metadata_service_impl.h"
#include "common_utils/infrastructure/common_services_factory.h"  // âœ… åªä¾èµ–ç»Ÿä¸€æ¥å£

namespace oscean::core_services::metadata::impl {

class MetadataServiceImpl : public IMetadataService {
public:
    MetadataServiceImpl(
        std::shared_ptr<MultiDatabaseManager> dbManager,
        std::shared_ptr<IntelligentMetadataRecognizer> recognizer,
        std::shared_ptr<MultiDatabaseQueryEngine> queryEngine,
        std::shared_ptr<common_utils::infrastructure::CommonServicesFactory> commonServices
    ) : dbManager_(dbManager),
        recognizer_(recognizer),
        queryEngine_(queryEngine),
        // âœ… é€šè¿‡CommonServicesFactoryè·å–æ‰€æœ‰åŸºç¡€æœåŠ¡
        metadataCache_(commonServices->createCache<std::string, DatasetMetadataEntry>("metadata_cache", 1000)),
        queryCache_(commonServices->createCache<std::string, std::vector<MetadataEntry>>("query_cache", 500)),
        logger_(commonServices->getLogger("MetadataService")),
        asyncExecutor_(commonServices->getAsyncExecutor()),
        performanceMonitor_(commonServices->getPerformanceMonitor()) {}
    
    // å…ƒæ•°æ®æå– - çº¯å…ƒæ•°æ®ä¸šåŠ¡é€»è¾‘
    boost::future<AsyncResult<ExtractedMetadata>> extractMetadataAsync(
        const std::string& filePath,
        const std::optional<DataTypeHint>& hint = std::nullopt
    ) override {
        auto timer = performanceMonitor_->startTimer("metadata_extraction");
        
        // æ£€æŸ¥ç¼“å­˜
        auto cached = metadataCache_->get(filePath);
        if (cached) {
            logger_->debug("Cache hit for metadata extraction: {}", filePath);
            timer->stop();
            return boost::make_ready_future(AsyncResult<ExtractedMetadata>::success(*cached));
        }
        
        // âœ… ä¸“æ³¨å…ƒæ•°æ®è¯†åˆ«é€»è¾‘ï¼Œä¸è°ƒç”¨å…¶ä»–ä¸šåŠ¡æœåŠ¡
        return recognizer_->recognizeFileAsync(filePath, hint)
            .then([this, filePath, timer](auto result) -> AsyncResult<ExtractedMetadata> {
                timer->stop();
                
                if (result.isSuccess()) {
                    auto extracted = result.getData();
                    metadataCache_->put(filePath, extracted);
                    logger_->debug("Metadata extracted and cached: {}", filePath);
                    return AsyncResult<ExtractedMetadata>::success(std::move(extracted));
                } else {
                    logger_->warn("Metadata extraction failed: {}", result.getError());
                    return AsyncResult<ExtractedMetadata>::failure(result.getError());
                }
            });
    }
    
    // å¹¶å‘æŸ¥è¯¢ - ä¸“æ³¨å…ƒæ•°æ®æŸ¥è¯¢é€»è¾‘
    boost::future<AsyncResult<std::vector<MetadataEntry>>> queryMetadataAsync(
        const MetadataQueryCriteria& criteria
    ) override {
        auto timer = performanceMonitor_->startTimer("metadata_query");
        auto cacheKey = generateQueryCacheKey(criteria);
        
        // æ£€æŸ¥æŸ¥è¯¢ç¼“å­˜
        auto cached = queryCache_->get(cacheKey);
        if (cached) {
            logger_->debug("Cache hit for metadata query");
            timer->stop();
            return boost::make_ready_future(AsyncResult<std::vector<MetadataEntry>>::success(*cached));
        }
        
        // æ‰§è¡Œå¹¶å‘æŸ¥è¯¢
        return queryEngine_->executeParallelQueryAsync(criteria)
            .then([this, cacheKey, timer](auto result) -> AsyncResult<std::vector<MetadataEntry>> {
                timer->stop();
                
                if (result.isSuccess()) {
                    auto results = result.getData();
                    queryCache_->put(cacheKey, results);
                    logger_->debug("Query results cached, count: {}", results.size());
                    return AsyncResult<std::vector<MetadataEntry>>::success(std::move(results));
                } else {
                    logger_->warn("Metadata query failed: {}", result.getError());
                    return result;
                }
            });
    }

private:
    // ä¸“æ³¨å…ƒæ•°æ®ä¸šåŠ¡ç»„ä»¶
    std::shared_ptr<MultiDatabaseManager> dbManager_;
    std::shared_ptr<IntelligentMetadataRecognizer> recognizer_;
    std::shared_ptr<MultiDatabaseQueryEngine> queryEngine_;
    
    // âœ… ä½¿ç”¨CommonServicesç»Ÿä¸€åŸºç¡€è®¾æ–½
    std::shared_ptr<common_utils::infrastructure::ICache<std::string, DatasetMetadataEntry>> metadataCache_;
    std::shared_ptr<common_utils::infrastructure::ICache<std::string, std::vector<MetadataEntry>>> queryCache_;
    std::shared_ptr<common_utils::infrastructure::logging::ILogger> logger_;
    std::shared_ptr<common_utils::infrastructure::async::IAsyncExecutor> asyncExecutor_;
    std::shared_ptr<common_utils::infrastructure::performance::IPerformanceMonitor> performanceMonitor_;
    
    // ä¸“æ³¨ä¸šåŠ¡é€»è¾‘çš„è¾…åŠ©æ–¹æ³•
    std::string generateQueryCacheKey(const MetadataQueryCriteria& criteria) {
        // ç”ŸæˆæŸ¥è¯¢ç¼“å­˜é”®çš„é€»è¾‘
        return "query_" + std::to_string(std::hash<std::string>{}(criteria.toString()));
    }
};

} // namespace oscean::core_services::metadata::impl
```

### 5.4 **CMakeLists.txt é…ç½®ä¿®æ­£**

```cmake
# core_services_impl/metadata_service/CMakeLists.txt
cmake_minimum_required(VERSION 3.20)
project(metadata_service)

# è®¾ç½®C++æ ‡å‡†
set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# æŸ¥æ‰¾ä¾èµ–
find_package(Boost REQUIRED COMPONENTS system filesystem)
find_package(SQLite3 REQUIRED)

# åŒ…å«ç›®å½•
include_directories(
    include
    ${CMAKE_SOURCE_DIR}/common_utilities/include        # âœ… åªä¾èµ–common_utilities
    ${CMAKE_SOURCE_DIR}/core_service_interfaces/include # âœ… åªä¾èµ–æ¥å£å®šä¹‰
)

# æºæ–‡ä»¶ - åˆ é™¤äº†é€‚é…å™¨ç›¸å…³æ–‡ä»¶
set(METADATA_SERVICE_SOURCES
    # å·¥å‚å®ç°
    src/factory/metadata_service_factory.cpp
    
    # æ ¸å¿ƒæœåŠ¡ - ä¸“æ³¨å…ƒæ•°æ®ä¸šåŠ¡
    src/core/metadata_service_impl.cpp
    src/core/metadata_extractor.cpp
    src/core/dataset_metadata_registry.cpp
    
    # æ•°æ®åº“ç®¡ç† - å…ƒæ•°æ®ä¸“ç”¨
    src/database/multi_database_manager.cpp
    src/database/database_router.cpp
    src/database/sqlite_storage_extended.cpp
    
    # æ™ºèƒ½è¯†åˆ« - å…ƒæ•°æ®ä¸“ç”¨
    src/intelligent/metadata_recognizer.cpp
    src/intelligent/variable_classifier.cpp
    src/intelligent/data_type_classifier.cpp
    src/intelligent/spatial_analyzer.cpp
    src/intelligent/temporal_analyzer.cpp
    
    # æŸ¥è¯¢å¼•æ“ - å…ƒæ•°æ®ä¸“ç”¨
    src/query/multi_database_query_engine.cpp
    src/query/query_optimizer.cpp
    src/query/result_merger.cpp
    src/query/ranking_engine.cpp
    
    # é…ç½®ç®¡ç† - å…ƒæ•°æ®ä¸“ç”¨
    src/configuration/configuration_manager.cpp
    src/configuration/variable_classification_config.cpp
    src/configuration/database_configuration.cpp
)

# åˆ›å»ºåº“
add_library(metadata_service STATIC ${METADATA_SERVICE_SOURCES})

# é“¾æ¥ä¾èµ– - ç®€åŒ–ä¾èµ–å…³ç³»
target_link_libraries(metadata_service
    common_utilities                    # âœ… ä½¿ç”¨commonç»Ÿä¸€åŸºç¡€è®¾æ–½
    core_service_interfaces            # âœ… ä½¿ç”¨æ¥å£å®šä¹‰
    ${Boost_LIBRARIES}
    SQLite::SQLite3
)

# æµ‹è¯•
enable_testing()
add_subdirectory(tests)
```

### 5.5 **é…ç½®æ–‡ä»¶ç»“æ„**

#### **5.5.1 æ•°æ®åº“é…ç½®**
```yaml
# config/database_config.yaml
database:
  base_path: "./databases"
  connections:
    ocean_environment:
      file: "ocean_environment.db"
      max_connections: 10
      timeout_seconds: 30
    topography_bathymetry:
      file: "topography_bathymetry.db"
      max_connections: 5
      timeout_seconds: 30
    boundary_lines:
      file: "boundary_lines.db"
      max_connections: 5
      timeout_seconds: 30
    sonar_propagation:
      file: "sonar_propagation.db"
      max_connections: 8
      timeout_seconds: 30
```

#### **5.5.2 å˜é‡åˆ†ç±»é…ç½®**
```yaml
# config/variable_classification.yaml
variable_classification:
  ocean_variables:
    current: ["u", "v", "current_speed", "current_direction"]
    temperature: ["temperature", "temp", "sst", "water_temp"]
    salinity: ["salinity", "sal", "psu"]
  topography_variables:
    elevation: ["elevation", "height", "altitude"]
    bathymetry: ["depth", "bathymetry", "seafloor_depth"]
  boundary_variables:
    coastline: ["coastline", "shoreline"]
    administrative: ["boundary", "border", "limit"]
```

è¿™ä¸ªé‡æ„åçš„ç›®å½•ç»“æ„å½»åº•ï¼š
- âœ… **æ¶ˆé™¤äº†é‡å¤commonåŠŸèƒ½çš„æ–‡ä»¶**
- âœ… **ä¸“æ³¨å…ƒæ•°æ®æ ¸å¿ƒä¸šåŠ¡é€»è¾‘**  
- âœ… **æ”¯æŒå¤šåº“å¹¶å‘æŸ¥è¯¢**
- âœ… **æä¾›å®Œæ•´çš„é…ç½®ç®¡ç†**
- âœ… **åŒ…å«å…¨é¢çš„æµ‹è¯•è¦†ç›–**

æ¯ä¸ªæ¨¡å—éƒ½æœ‰æ˜ç¡®çš„èŒè´£åˆ†å·¥ï¼Œæ—¢ä¿æŒäº†æ¶æ„çš„çº¯å‡€æ€§ï¼Œåˆæä¾›äº†å¼ºå¤§çš„å…ƒæ•°æ®ç®¡ç†èƒ½åŠ›ï¼ 

## ğŸ” ç¬¬å…­éƒ¨åˆ†ï¼šç»Ÿä¸€æ¥å£é‡æ„æ–¹æ¡ˆ

### ğŸ“Œ **é‡è¦ç¡®è®¤ï¼šå•ä¸€ç»Ÿä¸€æ¥å£æ–‡ä»¶è®¾è®¡**
> **æœ€ç»ˆç¡®è®¤**: åŸºäºæ¶æ„è¯„å®¡ï¼Œå…ƒæ•°æ®æœåŠ¡é‡‡ç”¨**å•ä¸€ç»Ÿä¸€æ¥å£æ–‡ä»¶**è®¾è®¡ï¼š
> - âœ… **å”¯ä¸€æ¥å£æ–‡ä»¶**: `core_service_interfaces/include/core_services/metadata/unified_metadata_service.h`
> - âœ… **åŒ…å«æ‰€æœ‰å®šä¹‰**: æ¥å£å®šä¹‰ + ç±»å‹å®šä¹‰ + å·¥å‚æ¥å£ å…¨éƒ¨åœ¨ä¸€ä¸ªæ–‡ä»¶ä¸­
> - âœ… **é¿å…æ¥å£åˆ†æ•£**: ä¸å†æœ‰å¤šä¸ªå°çš„æ¥å£æ–‡ä»¶ï¼Œéµå¾ªå•ä¸€å…¥å£åŸåˆ™
> - âœ… **ç®€åŒ–ä¾èµ–å…³ç³»**: å¤–éƒ¨æ¨¡å—åªéœ€åŒ…å«ä¸€ä¸ªå¤´æ–‡ä»¶å³å¯ä½¿ç”¨å®Œæ•´æœåŠ¡

### 6.1 **âŒ å½“å‰æ¥å£é—®é¢˜åˆ†æ**

#### **æ¥å£åˆ†æ•£é—®é¢˜**
```
å½“å‰çŠ¶æ€ï¼šæ¥å£å®šä¹‰åˆ†æ•£åœ¨å¤šä¸ªä½ç½®
â”œâ”€â”€ core_service_interfaces/include/core_services/metadata/
â”‚   â”œâ”€â”€ i_metadata_service.h              # âŒ æ—§æ¥å£ï¼šåŒæ­¥è®¾è®¡ï¼ŒåŠŸèƒ½æœ‰é™
â”‚   â”œâ”€â”€ idataset_metadata_registry_backend.h  # âŒ å†…éƒ¨å®ç°æ¥å£æš´éœ²
â”‚   â””â”€â”€ i_metadata_cache.h                # âŒ é‡å¤commonåŠŸèƒ½
â”œâ”€â”€ core_services_impl/metadata_service/include/
â”‚   â””â”€â”€ metadata_service_interface.h      # âŒ é‡å¤å®šä¹‰æ¥å£
â””â”€â”€ å„ç§åˆ†æ•£çš„ç±»å‹å®šä¹‰                      # âŒ ç±»å‹å®šä¹‰ä¸ç»Ÿä¸€
```

#### **ç°æœ‰æ¥å£çš„å±€é™æ€§**
```cpp
// å½“å‰ i_metadata_service.h çš„é—®é¢˜ï¼š
class IMetadataService {
    // âŒ åŒæ­¥è®¾è®¡ï¼Œç¼ºå°‘ç°ä»£å¼‚æ­¥æ”¯æŒ
    virtual OSCEAN_FUTURE(std::vector<FileInfo>) findFilesAsync(...);
    
    // âŒ åŠŸèƒ½æœ‰é™ï¼Œç¼ºå°‘æ™ºèƒ½è¯†åˆ«
    virtual OSCEAN_FUTURE(FileMetadata) getFileMetadataAsync(...);
    
    // âŒ æ²¡æœ‰å¤šåº“æ”¯æŒ
    // âŒ æ²¡æœ‰æ™ºèƒ½åˆ†ç±»
    // âŒ æ²¡æœ‰å¹¶å‘æŸ¥è¯¢
    // âŒ æ²¡æœ‰å˜é‡åˆ†ç±»é…ç½®
};
```

### 6.2 **âœ… ç»Ÿä¸€æ¥å£é‡æ„æ–¹æ¡ˆ**

#### **6.2.1 åœ¨core_service_interfacesä¸­å®šä¹‰ç»Ÿä¸€ç°ä»£åŒ–æ¥å£**

```cpp
// core_service_interfaces/include/core_services/metadata/unified_metadata_service.h
#pragma once

#include "../common_data_types.h"
#include "common_utils/infrastructure/common_services_factory.h"
#include <boost/future.hpp>

namespace oscean::core_services::metadata {

/**
 * @brief ç°ä»£åŒ–ç»Ÿä¸€å…ƒæ•°æ®æœåŠ¡æ¥å£
 * 
 * ğŸ¯ è®¾è®¡åŸåˆ™ï¼š
 * âœ… ç»Ÿä¸€å¯¹å¤–æ¥å£ - æ‰€æœ‰å…ƒæ•°æ®åŠŸèƒ½çš„å”¯ä¸€å…¥å£
 * âœ… 100% å¼‚æ­¥è®¾è®¡ - å…¨é¢ä½¿ç”¨boost::future
 * âœ… æ™ºèƒ½åŒ–æ”¯æŒ - å†…ç½®AIé©±åŠ¨çš„è¯†åˆ«å’Œåˆ†ç±»
 * âœ… å¤šåº“æ¶æ„ - æ”¯æŒå¤šç§æ•°æ®ç±»å‹ä¸“ç”¨æ•°æ®åº“
 * âœ… ç°ä»£åŒ–æŸ¥è¯¢ - æ”¯æŒå¤æ‚çš„å¤šç»´åº¦æŸ¥è¯¢
 * âœ… é…ç½®é©±åŠ¨ - æ”¯æŒè¿è¡Œæ—¶é…ç½®æ›´æ–°
 */
class IUnifiedMetadataService {
public:
    virtual ~IUnifiedMetadataService() = default;

    // === ğŸ¤– æ™ºèƒ½å…ƒæ•°æ®è¯†åˆ«æ¥å£ ===
    
    /**
     * @brief æ™ºèƒ½è¯†åˆ«æ–‡ä»¶å…ƒæ•°æ®
     * 
     * è‡ªåŠ¨è¯†åˆ«æ–‡ä»¶ç±»å‹ã€å˜é‡ã€æ—¶ç©ºèŒƒå›´ç­‰ï¼Œæ”¯æŒï¼š
     * - æµ·æ´‹ç¯å¢ƒæ•°æ® (u,v,æ¸©åº¦,ç›åº¦ç­‰)
     * - åœ°å½¢åº•è´¨æ•°æ® (é«˜ç¨‹,æ·±åº¦ç­‰)  
     * - è¾¹ç•Œçº¿æ•°æ® (æµ·å²¸çº¿,è¾¹ç•Œç­‰)
     * - å£°çº³ä¼ æ’­æ•°æ® (ä¼ æ„Ÿå™¨,æ¨¡å¼ç­‰)
     */
    virtual boost::future<AsyncResult<IntelligentRecognitionResult>> recognizeFileAsync(
        const std::string& filePath,
        const RecognitionConfiguration& config = {}
    ) = 0;
    
    /**
     * @brief æ‰¹é‡æ™ºèƒ½è¯†åˆ«
     */
    virtual boost::future<AsyncResult<std::vector<IntelligentRecognitionResult>>> recognizeBatchAsync(
        const std::vector<std::string>& filePaths,
        const RecognitionConfiguration& config = {}
    ) = 0;

    // === ğŸ’¾ å…ƒæ•°æ®å­˜å‚¨ç®¡ç†æ¥å£ ===
    
    /**
     * @brief å­˜å‚¨å…ƒæ•°æ®åˆ°é€‚å½“çš„æ•°æ®åº“
     * 
     * è‡ªåŠ¨è·¯ç”±åˆ°ä¸“ç”¨æ•°æ®åº“ï¼š
     * - ocean_environment.db - æµ·æ´‹ç¯å¢ƒæ•°æ®
     * - topography_bathymetry.db - åœ°å½¢åº•è´¨æ•°æ®
     * - boundary_lines.db - è¾¹ç•Œçº¿æ•°æ®
     * - sonar_propagation.db - å£°çº³ä¼ æ’­æ•°æ®
     */
    virtual boost::future<AsyncResult<std::string>> storeMetadataAsync(
        const ExtractedMetadata& metadata,
        const StorageOptions& options = {}
    ) = 0;
    
    /**
     * @brief æ›´æ–°å·²å­˜å‚¨çš„å…ƒæ•°æ®
     */
    virtual boost::future<AsyncResult<void>> updateMetadataAsync(
        const std::string& metadataId,
        const MetadataUpdate& update
    ) = 0;
    
    /**
     * @brief åˆ é™¤å…ƒæ•°æ®
     */
    virtual boost::future<AsyncResult<void>> deleteMetadataAsync(
        const std::string& metadataId
    ) = 0;

    // === ğŸ” å¤šç»´åº¦å¹¶å‘æŸ¥è¯¢æ¥å£ ===
    
    /**
     * @brief å¤šç»´åº¦å¹¶å‘æŸ¥è¯¢
     * 
     * æ”¯æŒå¤æ‚æŸ¥è¯¢æ¡ä»¶ï¼š
     * - æ—¶é—´èŒƒå›´æŸ¥è¯¢
     * - ç©ºé—´èŒƒå›´æŸ¥è¯¢  
     * - å˜é‡åç§°æŸ¥è¯¢
     * - æ•°æ®ç±»å‹è¿‡æ»¤
     * - ä¼ æ„Ÿå™¨è”åˆæŸ¥è¯¢ (platform_id + sensor_id + working_mode_id)
     * - æ™ºèƒ½æ’åºå’Œæ¨è
     */
    virtual boost::future<AsyncResult<std::vector<MetadataEntry>>> queryMetadataAsync(
        const MultiDimensionalQueryCriteria& criteria
    ) = 0;
    
    /**
     * @brief è·¨åº“èšåˆæŸ¥è¯¢
     */
    virtual boost::future<AsyncResult<AggregatedQueryResult>> aggregateQueryAsync(
        const AggregationQueryCriteria& criteria
    ) = 0;
    
    /**
     * @brief æ™ºèƒ½æ¨èæŸ¥è¯¢
     */
    virtual boost::future<AsyncResult<std::vector<MetadataEntry>>> recommendSimilarAsync(
        const std::string& referenceMetadataId,
        const RecommendationOptions& options = {}
    ) = 0;

    // === ğŸ“Š ç»Ÿè®¡åˆ†ææ¥å£ ===
    
    /**
     * @brief è·å–å…ƒæ•°æ®ç»Ÿè®¡ä¿¡æ¯
     */
    virtual boost::future<AsyncResult<MetadataStatistics>> getStatisticsAsync(
        const StatisticsRequest& request = {}
    ) = 0;
    
    /**
     * @brief è·å–æ—¶ç©ºèŒƒå›´
     */
    virtual boost::future<AsyncResult<SpatioTemporalExtent>> getExtentAsync(
        const std::optional<QueryCriteria>& criteria = std::nullopt
    ) = 0;
    
    /**
     * @brief è·å–å¯ç”¨å˜é‡åˆ—è¡¨
     */
    virtual boost::future<AsyncResult<std::vector<VariableInfo>>> getAvailableVariablesAsync(
        const std::optional<QueryCriteria>& criteria = std::nullopt
    ) = 0;

    // === âš™ï¸ é…ç½®ç®¡ç†æ¥å£ ===
    
    /**
     * @brief æ›´æ–°å˜é‡åˆ†ç±»é…ç½®
     */
    virtual boost::future<AsyncResult<void>> updateVariableClassificationAsync(
        const VariableClassificationConfig& config
    ) = 0;
    
    /**
     * @brief æ›´æ–°æ•°æ®åº“é…ç½®
     */
    virtual boost::future<AsyncResult<void>> updateDatabaseConfigurationAsync(
        const DatabaseConfiguration& config
    ) = 0;
    
    /**
     * @brief è·å–å½“å‰é…ç½®
     */
    virtual boost::future<AsyncResult<MetadataServiceConfiguration>> getConfigurationAsync() = 0;

    // === ğŸ”§ æœåŠ¡çŠ¶æ€å’Œå¥åº·æ£€æŸ¥æ¥å£ ===
    
    /**
     * @brief è·å–æœåŠ¡çŠ¶æ€
     */
    virtual boost::future<AsyncResult<MetadataServiceStatus>> getServiceStatusAsync() = 0;
    
    /**
     * @brief æ‰§è¡Œå¥åº·æ£€æŸ¥
     */
    virtual boost::future<AsyncResult<HealthCheckResult>> performHealthCheckAsync() = 0;
    
    /**
     * @brief è·å–æ€§èƒ½æŒ‡æ ‡
     */
    virtual boost::future<AsyncResult<PerformanceMetrics>> getPerformanceMetricsAsync() = 0;
};

/**
 * @brief å…ƒæ•°æ®æœåŠ¡å·¥å‚æ¥å£
 * 
 * ç»Ÿä¸€çš„åˆ›å»ºå…¥å£ï¼Œå¤–éƒ¨åªéœ€è¦è¿™ä¸€ä¸ªå·¥å‚
 */
class IMetadataServiceFactory {
public:
    virtual ~IMetadataServiceFactory() = default;
    
    /**
     * @brief åˆ›å»ºç»Ÿä¸€å…ƒæ•°æ®æœåŠ¡å®ä¾‹
     */
    virtual std::shared_ptr<IUnifiedMetadataService> createService(
        std::shared_ptr<common_utils::infrastructure::CommonServicesFactory> commonServices,
        const MetadataServiceConfiguration& config
    ) = 0;
    
    /**
     * @brief è·å–é»˜è®¤é…ç½®
     */
    virtual MetadataServiceConfiguration getDefaultConfiguration() const = 0;
};

} // namespace oscean::core_services::metadata
```

#### **6.2.2 ç°ä»£åŒ–æ•°æ®ç±»å‹å®šä¹‰**

```cpp
// core_service_interfaces/include/core_services/metadata/metadata_types_v2.h
#pragma once

#include <string>
#include <vector>
#include <map>
#include <optional>
#include <chrono>
#include <boost/future.hpp>

namespace oscean::core_services::metadata {

// === ğŸ¤– æ™ºèƒ½è¯†åˆ«ç»“æœç±»å‹ ===

/**
 * @brief æ™ºèƒ½è¯†åˆ«ç»“æœ
 */
struct IntelligentRecognitionResult {
    std::string filePath;
    DataType detectedDataType;              // OCEAN_ENVIRONMENT, TOPOGRAPHY, etc.
    double confidence;                      // ç½®ä¿¡åº¦ 0-1
    
    // è¯†åˆ«åˆ°çš„å˜é‡ä¿¡æ¯
    std::vector<VariableInfo> detectedVariables;
    std::map<std::string, std::string> variableMapping;  // åŸå˜é‡å -> æ ‡å‡†å
    
    // æ—¶ç©ºä¿¡æ¯
    SpatialInfo spatialInfo;
    TemporalInfo temporalInfo;
    
    // è´¨é‡æŒ‡æ ‡
    double dataQuality;
    double completeness;
    std::vector<std::string> warnings;
    std::vector<std::string> recommendations;
    
    // åˆ†ç±»ä¿¡æ¯
    std::string suggestedDatabase;          // å»ºè®®çš„ç›®æ ‡æ•°æ®åº“
    std::map<std::string, std::string> classificationTags;
};

/**
 * @brief è¯†åˆ«é…ç½®
 */
struct RecognitionConfiguration {
    bool enableDeepAnalysis = true;         // å¯ç”¨æ·±åº¦åˆ†æ
    bool enableVariableMapping = true;     // å¯ç”¨å˜é‡æ˜ å°„
    bool enableQualityAssessment = true;   // å¯ç”¨è´¨é‡è¯„ä¼°
    std::vector<std::string> preferredVariableNames;  // ä¼˜å…ˆå˜é‡å
    std::optional<DataType> hintDataType;   // æ•°æ®ç±»å‹æç¤º
};

// === ğŸ” å¤šç»´åº¦æŸ¥è¯¢ç±»å‹ ===

/**
 * @brief å¤šç»´åº¦æŸ¥è¯¢æ¡ä»¶
 */
struct MultiDimensionalQueryCriteria {
    // æ—¶é—´ç»´åº¦
    std::optional<TimeRange> timeRange;
    
    // ç©ºé—´ç»´åº¦  
    std::optional<SpatialBounds> spatialBounds;
    
    // å˜é‡ç»´åº¦
    std::vector<std::string> variablesInclude;
    std::vector<std::string> variablesExclude;
    
    // æ•°æ®ç±»å‹ç»´åº¦
    std::vector<DataType> dataTypes;
    
    // ä¼ æ„Ÿå™¨ç»´åº¦ (å£°çº³æ•°æ®ä¸“ç”¨)
    std::optional<SensorCriteria> sensorCriteria;
    
    // è´¨é‡ç»´åº¦
    std::optional<QualityCriteria> qualityCriteria;
    
    // æ’åºå’Œé™åˆ¶
    SortOptions sortOptions;
    std::optional<size_t> limit;
    std::optional<size_t> offset;
};

/**
 * @brief ä¼ æ„Ÿå™¨æŸ¥è¯¢æ¡ä»¶
 */
struct SensorCriteria {
    std::optional<std::string> platformId;
    std::optional<std::string> sensorId;
    std::optional<std::string> workingModeId;
    std::optional<TimeRange> deploymentPeriod;
    std::optional<FrequencyRange> frequencyRange;
};

/**
 * @brief èšåˆæŸ¥è¯¢ç»“æœ
 */
struct AggregatedQueryResult {
    std::vector<MetadataEntry> entries;
    StatisticalSummary statisticalSummary;
    std::map<std::string, size_t> distributionByType;
    std::map<std::string, size_t> distributionByVariable;
    TimeSeriesInfo timeSeriesInfo;
    SpatialDistributionInfo spatialDistribution;
};

// === ğŸ“Š ç»Ÿè®¡å’Œç›‘æ§ç±»å‹ ===

/**
 * @brief å…ƒæ•°æ®æœåŠ¡çŠ¶æ€
 */
struct MetadataServiceStatus {
    bool isHealthy;
    std::string version;
    std::chrono::system_clock::time_point startTime;
    std::chrono::seconds uptime;
    
    // æ•°æ®åº“çŠ¶æ€
    std::map<std::string, DatabaseStatus> databaseStatus;
    
    // æ€§èƒ½æŒ‡æ ‡
    PerformanceMetrics currentMetrics;
    
    // æ´»è·ƒä»»åŠ¡
    std::vector<ActiveTask> activeTasks;
};

/**
 * @brief æ€§èƒ½æŒ‡æ ‡
 */
struct PerformanceMetrics {
    // æŸ¥è¯¢æ€§èƒ½
    double averageQueryTimeMs;
    double averageRecognitionTimeMs;
    size_t totalQueries;
    size_t totalRecognitions;
    
    // ç¼“å­˜æ€§èƒ½
    double cacheHitRate;
    size_t cacheSize;
    
    // å¹¶å‘æ€§èƒ½
    size_t activeConcurrentTasks;
    double averageTaskDurationMs;
    
    // æ•°æ®åº“æ€§èƒ½
    std::map<std::string, DatabaseMetrics> databaseMetrics;
};

// === ğŸ›¡ï¸ å¼‚æ­¥ç»“æœåŒ…è£… ===

/**
 * @brief ç»Ÿä¸€å¼‚æ­¥ç»“æœç±»å‹
 */
template<typename T>
class AsyncResult {
public:
    AsyncResult(T data) : data_(std::move(data)), success_(true) {}
    AsyncResult(std::string error) : error_(std::move(error)), success_(false) {}
    
    bool isSuccess() const { return success_; }
    const T& getData() const { 
        if (!success_) throw std::runtime_error("Result is not successful");
        return data_; 
    }
    const std::string& getError() const { return error_; }
    
    static AsyncResult<T> success(T data) { return AsyncResult<T>(std::move(data)); }
    static AsyncResult<T> failure(const std::string& error) { return AsyncResult<T>(error); }

private:
    T data_;
    std::string error_;
    bool success_;
};

} // namespace oscean::core_services::metadata
```

### 6.3 **æ¥å£ç»Ÿä¸€å®æ–½è®¡åˆ’**

#### **Phase 1: ç»Ÿä¸€æ¥å£å®šä¹‰ (1å‘¨)**
1. **é‡æ„core_service_interfaces**
   - æ–°å»º `unified_metadata_service.h` - ç°ä»£åŒ–ç»Ÿä¸€æ¥å£
   - æ–°å»º `metadata_types_v2.h` - å®Œæ•´ç±»å‹å®šä¹‰
   - æ ‡è®°æ—§æ¥å£ä¸º@deprecated

2. **æ¸…ç†åˆ†æ•£æ¥å£**
   - åˆ é™¤å®ç°æ¨¡å—ä¸­çš„æ¥å£å®šä¹‰é‡å¤
   - ç»Ÿä¸€æ‰€æœ‰ç±»å‹å®šä¹‰åˆ°interfacesæ¨¡å—

#### **Phase 2: å®ç°æ¥å£é€‚é… (1å‘¨)**  
3. **å®ç°ç»Ÿä¸€æ¥å£**
   - `UnifiedMetadataServiceImpl` å®ç°æ–°æ¥å£
   - é€‚é…ç°æœ‰åŠŸèƒ½åˆ°æ–°æ¥å£
   - ä¿æŒå‘åå…¼å®¹

#### **Phase 3: å¤–éƒ¨æ¨¡å—è¿ç§» (1å‘¨)**
4. **æ›´æ–°å¤–éƒ¨ä¾èµ–**
   - æ‰€æœ‰è°ƒç”¨æ–¹è¿ç§»åˆ°æ–°æ¥å£
   - æ›´æ–°æ–‡æ¡£å’Œç¤ºä¾‹ä»£ç 
   - ç§»é™¤æ—§æ¥å£

### 6.4 **ç»Ÿä¸€æ¥å£çš„ä¼˜åŠ¿**

#### **âœ… æ¶æ„ä¼˜åŠ¿**
- **å•ä¸€å…¥å£** - å¤–éƒ¨åªéœ€ä¾èµ–ä¸€ä¸ªæ¥å£
- **ç‰ˆæœ¬æ§åˆ¶** - æ¥å£å˜æ›´ç»Ÿä¸€ç®¡ç†
- **å‘åå…¼å®¹** - æ¸è¿›å¼å‡çº§æ”¯æŒ

#### **âœ… å¼€å‘ä¼˜åŠ¿**  
- **ç±»å‹å®‰å…¨** - ç»Ÿä¸€çš„ç±»å‹å®šä¹‰
- **æ–‡æ¡£é›†ä¸­** - æ‰€æœ‰æ¥å£æ–‡æ¡£åœ¨ä¸€å¤„
- **æµ‹è¯•ç®€åŒ–** - ç»Ÿä¸€çš„Mockå’Œæµ‹è¯•æ¡†æ¶

#### **âœ… ç»´æŠ¤ä¼˜åŠ¿**
- **æ¥å£ç¨³å®š** - å‡å°‘æ¥å£å˜æ›´å½±å“é¢
- **ä¾èµ–æ¸…æ™°** - æ˜ç¡®çš„ä¾èµ–å…³ç³»
- **å‡çº§ç®€å•** - ç»Ÿä¸€çš„å‡çº§è·¯å¾„

---

## ğŸ‰ **é‡æ„æ–¹æ¡ˆæœ€ç»ˆç¡®è®¤**

æœ¬é‡æ„æ–¹æ¡ˆå·²åŸºäºæ¶æ„è¯„å®¡åé¦ˆè¿›è¡Œæœ€ç»ˆä¿®æ­£ï¼Œç¡®ä¿ï¼š

1. **æ¶æ„çº¯å‡€æ€§** - å…ƒæ•°æ®æœåŠ¡ä¸“æ³¨æ ¸å¿ƒä¸šåŠ¡ï¼Œä¸æ¶‰åŠè·¨æœåŠ¡ç¼–æ’
2. **æŠ€æœ¯ç»Ÿä¸€æ€§** - 100%ä½¿ç”¨boost::futureï¼Œ100%ä¾èµ–common_utilities
3. **æ¥å£ç»Ÿä¸€æ€§** - å•ä¸€unified_metadata_service.hæ–‡ä»¶åŒ…å«å®Œæ•´æ¥å£å®šä¹‰
4. **åŠŸèƒ½å®Œæ•´æ€§** - æ”¯æŒå¤šåº“ç®¡ç†ã€æ™ºèƒ½è¯†åˆ«ã€å¹¶å‘æŸ¥è¯¢ã€é…ç½®ç®¡ç†

**æ–¹æ¡ˆçŠ¶æ€**: âœ… **æœ€ç»ˆç¡®è®¤ï¼Œå¯å¼€å§‹å®æ–½**