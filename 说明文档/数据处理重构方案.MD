# Data Access æ¨¡å—å®Œå…¨é‡æ„æ‰§è¡Œæ–¹æ¡ˆ

## ğŸ“‹ 1. é‡æ„æ¦‚è§ˆ

### 1.1 æ ¸å¿ƒç›®æ ‡
- **å½»åº•æ¶ˆé™¤ä»£ç é‡å¤**ï¼šåˆ é™¤ ~3,200 è¡Œé‡å¤ä»£ç ï¼Œä¸»è¦é›†ä¸­åœ¨ç¼“å­˜ã€å¼‚æ­¥å¤„ç†ã€æ—¶é—´è½¬æ¢ç­‰æ–¹é¢ã€‚
- **ç»Ÿä¸€åŸºç¡€è®¾æ–½**ï¼šå…¨é¢é‡‡ç”¨å¹¶é›†æˆ `common_utils` æä¾›çš„æˆç†Ÿç»„ä»¶ï¼ˆç¼“å­˜ã€å¼‚æ­¥ã€æ—¶é—´ã€æ—¥å¿—ã€é”™è¯¯å¤„ç†ç­‰ï¼‰ã€‚
- **æ¶æ„ç°ä»£åŒ–**ï¼šå®ç°ä¸€ä¸ªæ¥å£æ¸…æ™°ã€èŒè´£å•ä¸€ã€å¯æ‰©å±•ã€é«˜å†…èšã€ä½è€¦åˆçš„ç°ä»£åŒ–æ•°æ®è®¿é—®æ¶æ„ã€‚
- **æå‡å¯ç»´æŠ¤æ€§ä¸å¯æµ‹è¯•æ€§**ï¼šé€šè¿‡æ¸…æ™°çš„æ¨¡å—åˆ’åˆ†å’Œæ¥å£è®¾è®¡ï¼Œé™ä½ç»´æŠ¤æˆæœ¬ï¼Œæé«˜å•å…ƒæµ‹è¯•è¦†ç›–ç‡ã€‚
- **æµå¼å¤„ç†èƒ½åŠ›**ï¼šä¸ºå¤„ç†å¤§è§„æ¨¡æ•°æ®é›†ï¼ˆTBçº§ï¼‰æä¾›é«˜æ•ˆã€å†…å­˜å¯æ§çš„æµå¼è¯»å–èƒ½åŠ›ã€‚
- **æ€§èƒ½ä¼˜åŒ–**ï¼šæ˜¾è‘—æå‡ç¼“å­˜å‘½ä¸­ç‡ã€å†…å­˜åˆ©ç”¨ç‡å’Œå¹¶å‘å¤„ç†èƒ½åŠ›ã€‚

### 1.2 å…³é”®æ”¶ç›Šé¢„æœŸ
- **ç¼“å­˜å‘½ä¸­ç‡**ï¼šä» 45-60% æå‡è‡³ 80-85%ã€‚
- **å†…å­˜åˆ©ç”¨ç‡**ï¼šä» 60-70% æå‡è‡³ 85-90%ã€‚
- **ä»£ç è¡Œæ•°**ï¼šå‡€å‡å°‘çº¦ 1,400 è¡Œã€‚
- **ç»´æŠ¤å¤æ‚åº¦**ï¼šé¢„è®¡é™ä½ 60% ä»¥ä¸Šã€‚
- **ç³»ç»Ÿç¨³å®šæ€§ä¸æ‰©å±•æ€§**ï¼šæ˜¾è‘—å¢å¼ºã€‚

## ğŸ—‚ï¸ 2. æœ€ç»ˆç›®å½•ç»“æ„ä¸æ–‡ä»¶æ¸…å•

### 2.1 ç›®æ ‡ç›®å½•ç»“æ„ (`core_services_impl/data_access_service/`)
```
core_services_impl/data_access_service/
â”œâ”€â”€ include/core_services/data_access/  # å…¬å…±æ¥å£å’Œæ ¸å¿ƒç±»å‹ (å¯¹å¤–æš´éœ²)
â”‚   â”œâ”€â”€ i_data_access_service.h         # (ä¿æŒä¸å˜) æœåŠ¡ä¸»æ¥å£
â”‚   â”œâ”€â”€ common_types.h                  # (æ–°å¢/é‡æ„) æ¨¡å—ç‰¹å®šçš„å…¬å…±ç±»å‹å®šä¹‰ (å¦‚ DataChunkKey, FileMetadata, BoundingBox, TimeRange, DimensionDefinition ç­‰)
â”‚   â”œâ”€â”€ error_codes.h                   # (æ–°å¢) æ¨¡å—ç‰¹å®šçš„é”™è¯¯ç å®šä¹‰
â”‚   â””â”€â”€ api/                              # (æ–°å¢) æ–°çš„æ ¸å¿ƒæ¥å£å®šä¹‰
â”‚       â”œâ”€â”€ i_data_source.h
â”‚       â”œâ”€â”€ i_metadata_provider.h
â”‚       â”œâ”€â”€ i_data_provider.h
â”‚       â”œâ”€â”€ i_streaming_data_provider.h
â”‚       â”œâ”€â”€ data_access_requests.h      # (GridReadRequest, FeatureReadRequest, etc.)
â”‚       â”œâ”€â”€ data_access_responses.h     # (GridData, FeatureCollection, DataChunk etc.)
â”‚       â””â”€â”€ streaming_types.h           # (StreamingOptions, BackpressureControl etc.)
â”‚
â””â”€â”€ src/                                  # å®ç°ä»£ç  (å†…éƒ¨ç»†èŠ‚)
    â”œâ”€â”€ data_access_service_impl.h        # (é‡å‘½å/é‡æ„è‡ª raw_data_access_service_impl.h)
    â”œâ”€â”€ data_access_service_impl.cpp      # (é‡å‘½å/é‡æ„è‡ª raw_data_access_service_impl.cpp)
    â”œâ”€â”€ cache/                              # (æ–°å¢) ç»Ÿä¸€ç¼“å­˜å®ç°
    â”‚   â”œâ”€â”€ unified_data_access_cache.h
    â”‚   â”œâ”€â”€ unified_data_access_cache.cpp
    â”‚   â””â”€â”€ i_cacheable_value.h           # (æ–°å¢) å¯ç¼“å­˜å¯¹è±¡æ¥å£
    â”œâ”€â”€ async/                              # (æ–°å¢) ç»Ÿä¸€å¼‚æ­¥æ‰§è¡Œå™¨
    â”‚   â”œâ”€â”€ unified_async_executor.h
    â”‚   â””â”€â”€ unified_async_executor.cpp
    â”œâ”€â”€ time/                               # (æ–°å¢) æ—¶é—´å¤„ç†ç›¸å…³
    â”‚   â”œâ”€â”€ cf_time_extractor.h
    â”‚   â””â”€â”€ cf_time_extractor.cpp
    â”œâ”€â”€ readers/                            # (é‡æ„) è¯»å–å™¨ç›¸å…³å®ç°
    â”‚   â”œâ”€â”€ core/                           # (æ–°å¢) è¯»å–å™¨æ ¸å¿ƒç»„ä»¶
    â”‚   â”‚   â”œâ”€â”€ unified_data_reader.h     # æŠ½è±¡åŸºç±»
    â”‚   â”‚   â”œâ”€â”€ unified_data_reader.cpp
    â”‚   â”‚   â”œâ”€â”€ reader_registry.h
    â”‚   â”‚   â”œâ”€â”€ reader_registry.cpp
    â”‚   â”‚   â”œâ”€â”€ i_format_detector.h       # æ ¼å¼æ¢æµ‹å™¨æ¥å£
    â”‚   â”‚   â”œâ”€â”€ format_detector_impl.h    # å…·ä½“æ ¼å¼æ¢æµ‹å™¨å®ç°
    â”‚   â”‚   â””â”€â”€ format_detector_impl.cpp
    â”‚   â”œâ”€â”€ gdal/                           # (é‡æ„) GDAL è¯»å–å™¨å®ç°
    â”‚   â”‚   â”œâ”€â”€ gdal_unified_reader.h       # ç»§æ‰¿ UnifiedDataReader
    â”‚   â”‚   â”œâ”€â”€ gdal_unified_reader.cpp
    â”‚   â”‚   â””â”€â”€ internal/                   # GDALå†…éƒ¨è¾…åŠ©ç»„ä»¶ (ä¿æŒå°è£…, å†…å®¹é‡æ„)
    â”‚   â”‚       â”œâ”€â”€ gdal_dataset_handler.h/cpp
    â”‚   â”‚       â”œâ”€â”€ gdal_metadata_extractor.h/cpp (å„ç±»å…ƒæ•°æ®æå–å™¨)
    â”‚   â”‚       â”œâ”€â”€ gdal_raster_io.h/cpp
    â”‚   â”‚       â”œâ”€â”€ gdal_vector_io.h/cpp
    â”‚   â”‚       â””â”€â”€ utils/ (gdal_common_utils, gdal_type_conversion etc.)
    â”‚   â””â”€â”€ netcdf/                         # (é‡æ„) NetCDF è¯»å–å™¨å®ç°
    â”‚       â”œâ”€â”€ netcdf_unified_reader.h     # ç»§æ‰¿ UnifiedDataReader
    â”‚       â”œâ”€â”€ netcdf_unified_reader.cpp
    â”‚       â””â”€â”€ internal/                   # NetCDFå†…éƒ¨è¾…åŠ©ç»„ä»¶ (ä¿æŒå°è£…, å†…å®¹é‡æ„)
    â”‚           â”œâ”€â”€ netcdf_file_processor.h/cpp
    â”‚           â”œâ”€â”€ netcdf_metadata_manager.h/cpp
    â”‚           â”œâ”€â”€ io/ (netcdf_attribute_io, netcdf_variable_io etc.)
    â”‚           â””â”€â”€ parsing/ (netcdf_cf_conventions, netcdf_coordinate_system_parser (ç²¾ç®€å) etc.)
    â””â”€â”€ streaming/                          # (æ–°å¢) æµå¼å¤„ç†å®ç°
        â”œâ”€â”€ streaming_data_processor.h
        â””â”€â”€ streaming_data_processor.cpp
```

### 2.2 åˆ é™¤æ–‡ä»¶æ¸…å• (~2400+ è¡Œ)
```
core_services_impl/data_access_service/
â”œâ”€â”€ include/core_services/data_access/
â”‚   â””â”€â”€ âŒ boost_future_config.h                        # (è‹¥ä¸å†éœ€è¦)
â”‚   â””â”€â”€ âŒ readers/data_reader_common.h                # (å†…å®¹è¿ç§»æˆ–åˆ é™¤)
â”‚   â””â”€â”€ âŒ i_data_reader_impl.h                         # (è¢«æ–°APIå–ä»£)
â””â”€â”€ src/impl/
    â”œâ”€â”€ cache/
    â”‚   â”œâ”€â”€ âŒ data_chunk_cache.h                       (çº¦597è¡Œ)
    â”‚   â”œâ”€â”€ âŒ data_chunk_cache.cpp
    â”‚   â”œâ”€â”€ âŒ reader_cache.h                          (çº¦424è¡Œ)
    â”‚   â”œâ”€â”€ âŒ reader_cache.cpp
    â”‚   â”œâ”€â”€ âŒ metadata_cache.h                        (çº¦253è¡Œ)
    â”‚   â”œâ”€â”€ âŒ metadata_cache.cpp
    â”‚   â”œâ”€â”€ âŒ netcdf_cache_manager.h                  (çº¦429è¡Œ)
    â”‚   â”œâ”€â”€ âŒ netcdf_cache_manager.cpp
    â”‚   â””â”€â”€ âŒ cache_manager_template.h
    â”œâ”€â”€ factory/
    â”‚   â”œâ”€â”€ âŒ reader_factory.h                         # (åŠŸèƒ½è¢« ReaderRegistry å–ä»£)
    â”‚   â””â”€â”€ âŒ reader_factory.cpp
    â””â”€â”€ readers/netcdf/parsing/
        â”œâ”€â”€ âŒ netcdf_time_processor.h                  (çº¦200è¡Œ)
        â””â”€â”€ âŒ netcdf_time_processor.cpp
```
*æ³¨ï¼šåŸ `raw_data_access_service_impl.h/cpp` æ–‡ä»¶å°†è¢«é‡å‘½åå¹¶å½»åº•é‡æ„ä¸º `data_access_service_impl.h/cpp`ã€‚éƒ¨åˆ† `gdal` å’Œ `netcdf` å†…éƒ¨è¾…åŠ©æ–‡ä»¶ä¹Ÿä¼šè¢«å¤§å¹…ä¿®æ”¹æˆ–ç²¾ç®€ã€‚*

### 2.3 æ–°å¢æ–‡ä»¶æ¸…å• (~1800 - 2000 è¡Œ)
*è¯¦è§2.1ç›®æ ‡ç›®å½•ç»“æ„ä¸­æ ‡æ³¨çš„ (æ–°å¢) å’Œ (æ–°å¢/é‡æ„) éƒ¨åˆ†ã€‚æ ¸å¿ƒæ–°å¢åŒ…æ‹¬ï¼š*
```
âœ¨ include/core_services/data_access/common_types.h
âœ¨ include/core_services/data_access/error_codes.h
âœ¨ include/core_services/data_access/api/* (æ‰€æœ‰æ–°æ¥å£)
âœ¨ src/cache/* (ç»Ÿä¸€ç¼“å­˜ç›¸å…³)
âœ¨ src/async/* (ç»Ÿä¸€å¼‚æ­¥æ‰§è¡Œå™¨ç›¸å…³)
âœ¨ src/time/* (CFæ—¶é—´æå–å™¨ç›¸å…³)
âœ¨ src/readers/core/* (è¯»å–å™¨æ ¸å¿ƒç»„ä»¶ç›¸å…³)
âœ¨ src/streaming/* (æµå¼å¤„ç†å™¨ç›¸å…³)
```

### 2.4 ä¸»è¦é‡æ„æ–‡ä»¶æ¸…å• (å¤§é‡ä»£ç ä¿®æ”¹)
```
ğŸ”„ src/data_access_service_impl.h/cpp (åŸ raw_data_access_service_impl.h/cpp)
ğŸ”„ src/readers/gdal/gdal_raster_reader.h/cpp       # é‡æ„ä¸º GdalUnifiedReader
ğŸ”„ src/readers/gdal/gdal_vector_reader.h/cpp       # é‡æ„ä¸º GdalUnifiedReader (æˆ–åˆå¹¶)
ğŸ”„ src/readers/gdal/internal/*                     # å†…éƒ¨é€»è¾‘è°ƒæ•´ä»¥é€‚é…æ–°æ¥å£
ğŸ”„ src/readers/netcdf/netcdf_cf_reader.h/cpp       # é‡æ„ä¸º NetCdfUnifiedReader
ğŸ”„ src/readers/netcdf/internal/*                   # å†…éƒ¨é€»è¾‘è°ƒæ•´ï¼Œç‰¹åˆ«æ˜¯æ—¶é—´å¤„ç†ç§»é™¤
ğŸ”„ src/readers/netcdf/parsing/netcdf_coordinate_system_parser.h/cpp # å¤§å¹…ç²¾ç®€ï¼Œç§»é™¤æ—¶é—´å¤„ç†
```

## ğŸ“š 3. æ¸è¿›å¼å®Œå…¨é‡æ„æ‰§è¡Œè®¡åˆ’

æœ¬è®¡åˆ’å°†æ•´ä¸ªé‡æ„è¿‡ç¨‹åˆ†è§£ä¸º6ä¸ªä¸»è¦é˜¶æ®µï¼Œæ¯ä¸ªé˜¶æ®µéƒ½æœ‰æ˜ç¡®çš„ç›®æ ‡ã€ä»»åŠ¡ã€äº¤ä»˜ç‰©å’ŒéªŒè¯æ ‡å‡†ã€‚

---

### Phase 1: å¥ å®šæ–°æ¶æ„åŸºç¡€ (é¢„è®¡ Week 1)

**ğŸ¯ ç›®æ ‡:**
-   å»ºç«‹æ–°ä¸€ä»£æ•°æ®è®¿é—®æ¥å£çš„æ¸…æ™°å®šä¹‰ã€‚
-   æ­å»ºç»Ÿä¸€ç¼“å­˜æœåŠ¡çš„åŸºç¡€è®¾æ–½æ¡†æ¶ã€‚
-   å»ºç«‹å‡†ç¡®çš„æ€§èƒ½åŸºå‡†ï¼Œç”¨äºåç»­é˜¶æ®µçš„ä¼˜åŒ–éªŒè¯ã€‚
-   æ­¤é˜¶æ®µä¸ä¿®æ”¹ä»»ä½•ç°æœ‰ä¸šåŠ¡é€»è¾‘çš„æ‰§è¡Œè·¯å¾„ï¼Œé£é™©æœ€ä½ã€‚

**æ ¸å¿ƒä»»åŠ¡:**
1.  **å®šä¹‰æ ¸å¿ƒAPIæ¥å£**: åˆ›å»ºæ‰€æœ‰æ–°çš„ `IDataSource`, `IMetadataProvider`, `IDataProvider`, `IStreamingDataProvider` æ¥å£ä»¥åŠç›¸å…³çš„è¯·æ±‚/å“åº”ç»“æ„ä½“ã€‚
2.  **å®ç°ç»Ÿä¸€ç¼“å­˜æ¡†æ¶éª¨æ¶**: åˆ›å»º `ICacheableValue`, `UnifiedDataAccessCache` çš„å¤´æ–‡ä»¶å’ŒåŸºç¡€å®ç°æ¡†æ¶ã€‚
3.  **æ­å»ºæ€§èƒ½åŸºå‡†æµ‹è¯•ç¯å¢ƒ**: ç¼–å†™æµ‹è¯•ç”¨ä¾‹ï¼Œæµ‹é‡å½“å‰ç³»ç»Ÿçš„å…³é”®æ€§èƒ½æŒ‡æ ‡ï¼ˆå¦‚ç‰¹å®šæ“ä½œçš„å“åº”æ—¶é—´ã€ç¼“å­˜å‘½ä¸­ç‡ã€å†…å­˜ä½¿ç”¨ï¼‰ã€‚
4.  **åˆ›å»ºé€šç”¨ç±»å‹ä¸é”™è¯¯ç æ–‡ä»¶**: æ•´ç†å¹¶åˆ›å»º `common_types.h` å’Œ `error_codes.h`ã€‚

**è¯¦ç»†æ­¥éª¤ä¸ä»£ç å®ç°æŒ‡å¼•:**

1.  **åˆ›å»ºç›®å½•ç»“æ„ (include)**:
    ```bash
    mkdir -p core_services_impl/data_access_service/include/core_services/data_access/api
    ```
2.  **åˆ›å»ºæ¥å£æ–‡ä»¶**:
    *   `core_services_impl/data_access_service/include/core_services/data_access/api/i_data_source.h` (å†…å®¹å¦‚å‰ä¸€æ–¹æ¡ˆå®šä¹‰)
    *   `core_services_impl/data_access_service/include/core_services/data_access/api/i_metadata_provider.h` (å†…å®¹å¦‚å‰ä¸€æ–¹æ¡ˆå®šä¹‰)
    *   `core_services_impl/data_access_service/include/core_services/data_access/api/i_data_provider.h` (å®šä¹‰ `readGridDataAsync` å’Œ `readFeatureCollectionAsync` ç­‰ï¼Œä½¿ç”¨è¯·æ±‚ç»“æ„ä½“)
```cpp
        // i_data_provider.h (ç¤ºä¾‹)
#pragma once
        #include <memory>
#include <boost/future.hpp>
        #include "data_access_requests.h"
        #include "data_access_responses.h" // å‡è®¾GridData, FeatureCollectionå®šä¹‰åœ¨æ­¤

namespace oscean::core_services::data_access::api {
        class IDataProvider {
public:
            virtual ~IDataProvider() = default;
            virtual boost::future<std::shared_ptr<GridData>> readGridDataAsync(
                const GridReadRequest& request) = 0;
            virtual boost::future<FeatureCollection> readFeatureCollectionAsync(
                const FeatureReadRequest& request) = 0;
            // å¯é€‰: virtual boost::future<RawVariableData> readRawVariableDataAsync(
            //    const RawVariableReadRequest& request) = 0;
        };
        }
        ```
    *   `core_services_impl/data_access_service/include/core_services/data_access/api/i_streaming_data_provider.h` (å®šä¹‰ `streamVariableDataAsync`, `getNextDataChunkAsync` ç­‰)
```cpp
        // i_streaming_data_provider.h (ç¤ºä¾‹)
#pragma once
        #include <functional>
        #include <boost/future.hpp>
        #include "streaming_types.h" 
        #include "data_access_responses.h" // For DataChunk

namespace oscean::core_services::data_access::api {
        class IStreamingDataProvider {
        public:
            virtual ~IStreamingDataProvider() = default;
            virtual boost::future<void> streamVariableDataAsync(
                const std::string& variableName,
                std::function<boost::future<bool>(DataChunk)> chunkProcessor,
                const StreamingOptions& options = {}) = 0;
            // å¯é€‰ pull æ¨¡å¼
            // virtual boost::future<std::optional<DataChunk>> getNextDataChunkAsync(
            //    const std::string& streamHandle, 
            //    const StreamingOptions& options = {}) = 0; 
        };
        }
        ```
    *   `core_services_impl/data_access_service/include/core_services/data_access/api/data_access_requests.h` (åŒ…å« `GridReadRequest`, `FeatureReadRequest`, `RawVariableReadRequest`)
    *   `core_services_impl/data_access_service/include/core_services/data_access/api/data_access_responses.h` (åŒ…å« `GridData`, `FeatureCollection`, `DataChunk` ç­‰æ ¸å¿ƒæ•°æ®ç»“æ„)
    *   `core_services_impl/data_access_service/include/core_services/data_access/api/streaming_types.h` (åŒ…å« `StreamingOptions`, `BackpressureControl` (è‹¥éœ€è¦), `AdaptiveChunkingConfig` (è‹¥éœ€è¦))
3.  **åˆ›å»ºé€šç”¨ç±»å‹ä¸é”™è¯¯ç æ–‡ä»¶**:
    *   `core_services_impl/data_access_service/include/core_services/data_access/common_types.h`
    *   `core_services_impl/data_access_service/include/core_services/data_access/error_codes.h`
4.  **åˆ›å»ºç›®å½•ç»“æ„ (src)**:
    ```bash
    mkdir -p core_services_impl/data_access_service/src/cache
    mkdir -p core_services_impl/data_access_service/src/async
    mkdir -p core_services_impl/data_access_service/src/time
    mkdir -p core_services_impl/data_access_service/src/readers/core
    mkdir -p core_services_impl/data_access_service/src/streaming
    ```
5.  **åˆ›å»ºç¼“å­˜åŸºç¡€è®¾æ–½éª¨æ¶**:
    *   `core_services_impl/data_access_service/src/cache/i_cacheable_value.h`:
```cpp
#pragma once
        #include <cstddef>
namespace oscean::core_services::data_access::cache {
class ICacheableValue {
public:
    virtual ~ICacheableValue() = default;
    virtual size_t getSizeInBytes() const = 0;
            virtual void onEviction() {} // Callback on eviction
        };
        }
        ```
    *   `core_services_impl/data_access_service/src/cache/unified_data_access_cache.h` (å¤´æ–‡ä»¶æ¡†æ¶ï¼Œå¦‚å‰ä¸€æ–¹æ¡ˆå®šä¹‰ï¼Œä¾èµ– `common_utils/cache/i_cache_manager.h`)
    *   `core_services_impl/data_access_service/src/cache/unified_data_access_cache.cpp` (åˆ›å»ºç©ºçš„å®ç°æˆ–åŸºç¡€æ„é€ å‡½æ•°)
6.  **å»ºç«‹æ€§èƒ½åŸºå‡†æµ‹è¯•**:
    *   åœ¨æµ‹è¯•ç›®å½•ä¸‹ (e.g., `tests/data_access/`) åˆ›å»º `performance_baseline_tests.cpp`ã€‚
    *   ä½¿ç”¨ç°æœ‰ `RawDataAccessServiceImpl` (æˆ–å…¶æ¥å£ `IDataAccessService`)ã€‚
    *   é’ˆå¯¹å‡ ç§å…¸å‹åœºæ™¯ (å°æ–‡ä»¶è¯»å–ã€å¤§æ•°æ®å—è¯»å–ã€å…ƒæ•°æ®æŸ¥è¯¢ã€é«˜é¢‘è®¿é—®ç­‰) ç¼–å†™æµ‹è¯•ã€‚
    *   æµ‹é‡å¹¶è®°å½•ï¼šå¹³å‡å“åº”æ—¶é—´ã€P95/P99å“åº”æ—¶é—´ã€ç‰¹å®šæ“ä½œçš„å†…å­˜å³°å€¼ã€å½“å‰ç¼“å­˜ï¼ˆå¦‚æœå¯è§‚æµ‹ï¼‰çš„å‘½ä¸­ç‡ã€‚
    *   ç¡®ä¿è¿™äº›æµ‹è¯•æ˜¯å¯é‡å¤çš„ã€‚

**æ¶‰åŠæ–‡ä»¶ (Phase 1):**
*   **æ–°å¢**:
    *   `include/core_services/data_access/api/*` (æ‰€æœ‰æ–°æ¥å£å¤´æ–‡ä»¶)
    *   `include/core_services/data_access/common_types.h`
    *   `include/core_services/data_access/error_codes.h`
    *   `src/cache/i_cacheable_value.h`
    *   `src/cache/unified_data_access_cache.h`
    *   `src/cache/unified_data_access_cache.cpp` (éª¨æ¶)
    *   `tests/data_access/performance_baseline_tests.cpp`
*   **ä¿®æ”¹**: æ— ç”Ÿäº§ä»£ç ä¿®æ”¹ã€‚
*   **åˆ é™¤**: æ— ã€‚

**é£é™©æ§åˆ¶ä¸éªŒè¯ (Phase 1):**
*   **ä»£ç å®¡æŸ¥**: å¯¹æ‰€æœ‰æ–°æ¥å£å®šä¹‰è¿›è¡Œä¸¥æ ¼å®¡æŸ¥ï¼Œç¡®ä¿å…¶åˆç†æ€§ã€å®Œæ•´æ€§å’Œå‰ç»æ€§ã€‚
*   **ç¼–è¯‘é€šè¿‡**: ç¡®ä¿æ‰€æœ‰æ–°å¢çš„å¤´æ–‡ä»¶å’Œéª¨æ¶å®ç°èƒ½å¤Ÿç¼–è¯‘é€šè¿‡ã€‚
*   **æ€§èƒ½åŸºå‡†**: æˆåŠŸå»ºç«‹å¯é‡å¤çš„æ€§èƒ½åŸºå‡†æµ‹è¯•ï¼Œå¹¶è®°å½•åˆå§‹æ€§èƒ½æ•°æ®ã€‚
*   **æ— åŠŸèƒ½å½±å“**: ç”±äºæ­¤é˜¶æ®µä¸æ¶‰åŠä¿®æ”¹ç°æœ‰æœåŠ¡é€»è¾‘ï¼Œç°æœ‰ç³»ç»ŸåŠŸèƒ½åº”å®Œå…¨ä¸å—å½±å“ã€‚æ‰€æœ‰ç°æœ‰å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•å¿…é¡»100%é€šè¿‡ã€‚

**é¢„æœŸæˆæœ (Phase 1):**
1.  ä¸€å¥—å®Œæ•´ã€ç»è¿‡å®¡æŸ¥çš„æ–°æ•°æ®è®¿é—®APIå®šä¹‰ã€‚
2.  ç»Ÿä¸€ç¼“å­˜æœåŠ¡ `UnifiedDataAccessCache` çš„åŸºç¡€æ¡†æ¶æ­å»ºå®Œæˆã€‚
3.  ä¸€å¥—å¯é‡åŒ–ã€å¯é‡å¤çš„æ€§èƒ½åŸºå‡†æµ‹è¯•æ•°æ®ã€‚
4.  é¡¹ç›®ä»£ç ç»“æ„å·²åˆæ­¥è°ƒæ•´ï¼Œä¸ºåç»­é˜¶æ®µçš„å®ç°åšå¥½å‡†å¤‡ã€‚

---

### Phase 2: ç¼“å­˜ç³»ç»Ÿç»Ÿä¸€ä¸é›†æˆ (é¢„è®¡ Week 2)

**ğŸ¯ ç›®æ ‡:**
-   å®Œå…¨å®ç° `UnifiedDataAccessCache`ï¼Œåˆ©ç”¨ `common_utils::cache` æä¾›çš„èƒ½åŠ›ï¼Œæ”¯æŒå¤šç§ç¼“å­˜ç­–ç•¥ï¼ˆLRU, LFU, TTL ç­‰ï¼‰å’Œä¸åŒçš„ç¼“å­˜åŒºåŸŸï¼ˆå¦‚æ•°æ®å—ç¼“å­˜ã€è¯»å–å™¨å®ä¾‹ç¼“å­˜ã€å…ƒæ•°æ®ç¼“å­˜ï¼‰ã€‚
-   å°† `DataAccessServiceImpl` (åŸ `RawDataAccessServiceImpl`) ä¸­çš„æ‰€æœ‰ç¼“å­˜é€»è¾‘è¿ç§»åˆ°ä½¿ç”¨ `UnifiedDataAccessCache`ã€‚
-   å½»åº•åˆ é™¤é¡¹ç›®ä¸­æ‰€æœ‰æ—§çš„ã€ç‹¬ç«‹çš„ç¼“å­˜å®ç°ä»£ç ï¼Œå‡å°‘ä»£ç å†—ä½™ã€‚
-   éªŒè¯æ–°ç¼“å­˜ç³»ç»Ÿçš„åŠŸèƒ½æ­£ç¡®æ€§ã€æ€§èƒ½æå‡ï¼ˆå¯¹æ¯”Phase 1åŸºå‡†ï¼‰å’Œå†…å­˜ä½¿ç”¨æ•ˆç‡ã€‚

**æ ¸å¿ƒä»»åŠ¡:**
1.  **è¯¦ç»†å®ç° `UnifiedDataAccessCache`**: åŒ…æ‹¬åˆå§‹åŒ–é€»è¾‘ã€ç¼“å­˜åŒºåŸŸçš„åˆ›å»ºä¸ç®¡ç†ã€å¼‚æ­¥çš„get/putæ“ä½œã€ç»Ÿè®¡ä¿¡æ¯è·å–ç­‰ã€‚
2.  **é‡æ„ `DataAccessServiceImpl`**: ä¿®æ”¹å…¶æ„é€ å‡½æ•°ä»¥æ¥æ”¶ `UnifiedDataAccessCache` å®ä¾‹ï¼Œå¹¶æ›´æ–°æ‰€æœ‰æ•°æ®å’Œå…ƒæ•°æ®è¯»å–æ–¹æ³•ï¼Œä½¿å…¶é€šè¿‡æ–°ç¼“å­˜ç³»ç»Ÿè¿›è¡Œå­˜å–ã€‚
3.  **åˆ é™¤æ—§ç¼“å­˜ä»£ç **: å®‰å…¨ç§»é™¤ `src/impl/cache/` ç›®å½•ä¸‹çš„æ‰€æœ‰æ—§ç¼“å­˜æ–‡ä»¶ã€‚
4.  **ç¼–å†™å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•**: é’ˆå¯¹ `UnifiedDataAccessCache` çš„ä¸åŒç­–ç•¥å’Œ `DataAccessServiceImpl` ä¸­ç¼“å­˜ç›¸å…³çš„é€»è¾‘è¿›è¡Œæµ‹è¯•ã€‚
5.  **æ€§èƒ½å¯¹æ¯”æµ‹è¯•**: è¿è¡ŒPhase 1å»ºç«‹çš„æ€§èƒ½åŸºå‡†æµ‹è¯•ï¼ŒéªŒè¯æ–°ç¼“å­˜ç³»ç»Ÿå¸¦æ¥çš„æ€§èƒ½æå‡ã€‚

**è¯¦ç»†æ­¥éª¤ä¸ä»£ç å®ç°æŒ‡å¼•:**

1.  **å®ç° `UnifiedDataAccessCache` (`unified_data_access_cache.cpp`)**: 
    *   **æ„é€ å‡½æ•°**: æ¥æ”¶ `common_utils::logging::Logger`ã€‚
    *   **`initialize` æ–¹æ³•**: 
        *   æ¥æ”¶å…¨å±€ç¼“å­˜é…ç½® `common_utils::cache::CacheConfig` å’Œå¯é€‰çš„åŒºåŸŸç‰¹å®šé…ç½® `std::map<std::string, common_utils::cache::CacheConfig>`ã€‚
        *   æ ¹æ®é…ç½®åˆ›å»ºå¹¶å­˜å‚¨ä¸åŒç±»å‹çš„ç¼“å­˜å®ä¾‹ (`ICacheManager<KeyType, ValueType>`) åˆ° `cacheRegions_` mapä¸­ã€‚ä¾‹å¦‚ï¼š
            *   `data_chunks`: å¯èƒ½ä½¿ç”¨ `LRUCacheStrategy` æˆ– `AdaptiveCacheStrategy`ï¼Œé…ç½®è¾ƒå¤§çš„ `maxSizeBytes`ã€‚
            *   `readers`: å¯èƒ½ä½¿ç”¨ `LFUCacheStrategy`ï¼Œé…ç½® `maxItems`ï¼Œç”¨äºç¼“å­˜æ‰“å¼€çš„ `IDataSource` å®ä¾‹ã€‚
            *   `metadata`: å¯èƒ½ä½¿ç”¨ `TTLCacheStrategy`ï¼Œé…ç½®é»˜è®¤çš„ `defaultTtl`ï¼Œç”¨äºç¼“å­˜æ–‡ä»¶å…ƒæ•°æ®ã€‚
        *   ä½¿ç”¨ `common_utils::cache::CacheFactory` (å¦‚æœå­˜åœ¨) æˆ–ç›´æ¥å®ä¾‹åŒ–ç­–ç•¥ã€‚
```cpp
        // unified_data_access_cache.cpp (initialize ç¤ºä¾‹ç‰‡æ®µ)
#include "unified_data_access_cache.h"
        #include "common_utils/cache/lru_cache_strategy.h" // æˆ–å…¶ä»–ç­–ç•¥
        #include "common_utils/cache/lfu_cache_strategy.h"
        #include "common_utils/cache/ttl_cache_strategy.h"
        #include "common_utils/cache/cache_factory.h" // å‡è®¾æœ‰å·¥å‚
        #include "../api/data_access_responses.h" // For GridData etc.
        #include "../api/i_data_source.h" // For IDataSource

namespace oscean::core_services::data_access::cache {

UnifiedDataAccessCache::UnifiedDataAccessCache(
    std::shared_ptr<common_utils::logging::Logger> logger)
            : logger_(std::move(logger)) {}

void UnifiedDataAccessCache::initialize(
    const common_utils::cache::CacheConfig& globalConfig,
    const std::map<std::string, common_utils::cache::CacheConfig>& regionConfigs) {
    std::unique_lock<std::shared_mutex> lock(regionsMutex_);
    
            // ç¤ºä¾‹: æ•°æ®å—ç¼“å­˜åŒºåŸŸ (DataChunkKey åœ¨ common_types.h ä¸­å®šä¹‰)
            auto dataChunkConf = regionConfigs.count(DATA_CHUNKS_REGION) ? 
                                 regionConfigs.at(DATA_CHUNKS_REGION) : globalConfig;
            // å¼ºåˆ¶æˆ–æ¨èç­–ç•¥ï¼Œä¾‹å¦‚LRU
            dataChunkConf.strategyType = dataChunkConf.strategyType == common_utils::cache::CacheStrategyType::NONE ? 
                                         common_utils::cache::CacheStrategyType::LRU : dataChunkConf.strategyType;
            dataChunkConf.name = DATA_CHUNKS_REGION;
            auto dataChunkCache = common_utils::cache::CacheFactory::createCache<DataChunkKey, std::shared_ptr<GridData>>(
                dataChunkConf, logger_); // GridData å®šä¹‰åœ¨ data_access_responses.h
            cacheRegions_[DATA_CHUNKS_REGION] = dataChunkCache;
            logger_->info("Cache region '{}' initialized with strategy {} and size {}MB", 
                          DATA_CHUNKS_REGION, dataChunkConf.strategyType, dataChunkConf.maxSizeBytes / (1024*1024));
        
            // ç¤ºä¾‹: è¯»å–å™¨å®ä¾‹ç¼“å­˜åŒºåŸŸ
            auto readerConf = regionConfigs.count(READER_INSTANCES_REGION) ? 
                              regionConfigs.at(READER_INSTANCES_REGION) : globalConfig;
            readerConf.strategyType = common_utils::cache::CacheStrategyType::LFU;
            readerConf.maxItems = readerConf.maxItems.value_or(50); // Default max 50 readers
            readerConf.name = READER_INSTANCES_REGION;
            auto readerCache = common_utils::cache::CacheFactory::createCache<std::string, std::shared_ptr<api::IDataSource>>(
                readerConf, logger_); // Key: filePath, Value: reader instance
            cacheRegions_[READER_INSTANCES_REGION] = readerCache;
            logger_->info("Cache region '{}' initialized with strategy {} and max items {}", 
                          READER_INSTANCES_REGION, readerConf.strategyType, readerConf.maxItems.value());

            // ç¤ºä¾‹: å…ƒæ•°æ®ç¼“å­˜åŒºåŸŸ (FileMetadataKey åœ¨ common_types.h ä¸­å®šä¹‰)
            auto metadataConf = regionConfigs.count(FILE_METADATA_REGION) ? 
                               regionConfigs.at(FILE_METADATA_REGION) : globalConfig;
            metadataConf.strategyType = common_utils::cache::CacheStrategyType::TTL;
            metadataConf.defaultTtl = metadataConf.defaultTtl.value_or(std::chrono::minutes(30));
            metadataConf.name = FILE_METADATA_REGION;
            auto metadataCache = common_utils::cache::CacheFactory::createCache<FileMetadataKey, FileMetadata>(
                metadataConf, logger_); // FileMetadata å®šä¹‰åœ¨ common_types.h æˆ– responses.h
            cacheRegions_[FILE_METADATA_REGION] = metadataCache;
            logger_->info("Cache region '{}' initialized with strategy {} and TTL {}s", 
                          FILE_METADATA_REGION, metadataConf.strategyType, metadataConf.defaultTtl.value().count());
            
            logger_->info("UnifiedDataAccessCache initialized with {} regions.", cacheRegions_.size());
        }
        
        // ... å®ç° getAsync, putAsync, clearRegionAsync, getRegionStats ç­‰æ¨¡æ¿æ–¹æ³• ...
        // è¿™äº›æ–¹æ³•å†…éƒ¨ä¼šæ ¹æ® regionName è·å–å¯¹åº”çš„ ICacheManager å®ä¾‹å¹¶è°ƒç”¨å…¶æ–¹æ³•ã€‚
        // éœ€è¦æ³¨æ„ç±»å‹è½¬æ¢å’Œé”™è¯¯å¤„ç†ã€‚

        // åœ¨ .h æ–‡ä»¶ä¸­å®šä¹‰å¸¸é‡
        // static constexpr const char* DATA_CHUNKS_REGION = "data_chunks";
        // static constexpr const char* READER_INSTANCES_REGION = "reader_instances";
        // static constexpr const char* FILE_METADATA_REGION = "file_metadata";

} // namespace
```
    *   **`getAsync`, `putAsync` æ¨¡æ¿æ–¹æ³•**: å®ç°å¼‚æ­¥çš„ç¼“å­˜è·å–å’Œå­˜å…¥ï¼Œå†…éƒ¨é€šè¿‡regionNameæ‰¾åˆ°å¯¹åº”çš„ `ICacheManager` å®ä¾‹ï¼Œå¹¶è°ƒç”¨å…¶å¼‚æ­¥æ–¹æ³•ã€‚ç¡®ä¿çº¿ç¨‹å®‰å…¨å’Œæ­£ç¡®çš„ç±»å‹è½¬æ¢ã€‚
    *   **`clearRegionAsync`, `getRegionStats`**: å®ç°å¯¹ç‰¹å®šç¼“å­˜åŒºåŸŸçš„æ¸…ç†å’Œç»Ÿè®¡ä¿¡æ¯è·å–ã€‚
2.  **å®šä¹‰ç¼“å­˜é”®ç±»å‹ (åœ¨ `include/core_services/data_access/common_types.h` ä¸­)**:
    *   `DataChunkKey`: ç”¨äºæ•°æ®å—ç¼“å­˜ï¼Œåº”åŒ…å«æ–‡ä»¶è·¯å¾„ã€å˜é‡åã€åˆ‡ç‰‡èŒƒå›´ã€ç›®æ ‡CRSç­‰èƒ½å”¯ä¸€æ ‡è¯†ä¸€ä¸ªæ•°æ®è¯·æ±‚çš„å…ƒç´ ã€‚éœ€è¦å®ç° `std::hash` å’Œ `operator==`ã€‚
    *   `FileMetadataKey`: ç”¨äºæ–‡ä»¶å…ƒæ•°æ®ç¼“å­˜ï¼Œé€šå¸¸æ˜¯æ–‡ä»¶è·¯å¾„ï¼Œä½†ä¹Ÿå¯èƒ½åŒ…å«å…¶ä»–æ ‡è¯†ç¬¦ï¼ˆå¦‚æ–‡ä»¶ä¿®æ”¹æ—¶é—´ï¼Œä»¥å¤„ç†æ–‡ä»¶æ›´æ–°ï¼‰ã€‚
3.  **é‡æ„ `DataAccessServiceImpl` (åŸ `RawDataAccessServiceImpl`)**:
    *   åœ¨ `data_access_service_impl.h` ä¸­æ·»åŠ  `std::shared_ptr<cache::UnifiedDataAccessCache> unifiedCache_;` æˆå‘˜ã€‚
    *   ä¿®æ”¹æ„é€ å‡½æ•°ï¼Œæ³¨å…¥ `UnifiedDataAccessCache` çš„å®ä¾‹ã€‚
    *   **æ›¿æ¢è¯»å–æ•°æ®é€»è¾‘**: 
        *   åœ¨å¦‚ `readGridDataAsync` æ–¹æ³•ä¸­ï¼Œå…ˆæ ¹æ®è¯·æ±‚å‚æ•°æ„é€  `DataChunkKey`ã€‚
        *   è°ƒç”¨ `unifiedCache_->getAsync<DataChunkKey, std::shared_ptr<GridData>>(DATA_CHUNKS_REGION, cacheKey)`ã€‚
        *   å¦‚æœç¼“å­˜å‘½ä¸­ï¼Œç›´æ¥è¿”å›ç»“æœã€‚
        *   å¦‚æœæœªå‘½ä¸­ï¼Œåˆ™æ‰§è¡Œå®é™…çš„æ•°æ®è¯»å–é€»è¾‘ï¼ˆå°†åœ¨åç»­Phaseé‡æ„è¯»å–å™¨æ—¶å®Œå–„ï¼‰ï¼Œè¯»å–åå°†ç»“æœé€šè¿‡ `unifiedCache_->putAsync(...)` å­˜å…¥ç¼“å­˜ã€‚
```cpp
        // data_access_service_impl.cpp (readGridDataAsync ç¤ºä¾‹ç‰‡æ®µ)
        boost::future<std::shared_ptr<GridData>> DataAccessServiceImpl::readGridDataAsync(
            const api::GridReadRequest& request /* ä½¿ç”¨æ–°æ¥å£çš„è¯·æ±‚å¯¹è±¡ */) {
        
            // å‡è®¾ request åŒ…å« filePath, variableName, sliceRanges, targetCrs ç­‰
            // æ„é€  DataChunkKey (å®šä¹‰åœ¨ common_types.h)
            cache::DataChunkKey cacheKey { 
                resolveFilePath(request.filePath), // ç¡®ä¿è·¯å¾„è§„èŒƒåŒ– 
                request.variableName,
                request.sliceRanges.value_or(std::vector<IndexRange>()), // æä¾›é»˜è®¤å€¼
                request.targetCRS 
            };
        
            return unifiedCache_->getAsync<cache::DataChunkKey, std::shared_ptr<GridData>>(
                cache::UnifiedDataAccessCache::DATA_CHUNKS_REGION, cacheKey)
                .then(boost::launch::deferred, // æˆ–è€…ä½¿ç”¨çº¿ç¨‹æ± 
                    [this, request, cacheKey](boost::future<std::optional<std::shared_ptr<GridData>>> futureValue) {
                    auto cachedDataOpt = futureValue.get();
                    if (cachedDataOpt && *cachedDataOpt) {
                        logger_->debug("Data chunk cache hit for key: {}", cacheKey.toString());
                        // TODO: æ›´æ–°ç¼“å­˜ç»Ÿè®¡ï¼ˆå¯é€‰ï¼ŒICacheManagerå†…éƒ¨å¯èƒ½å·²å¤„ç†ï¼‰
                        return boost::make_ready_future(*cachedDataOpt);
                    }
        
                    logger_->debug("Data chunk cache miss for key: {}. Loading from source.", cacheKey.toString());
                    // å®é™…çš„åŠ è½½é€»è¾‘ (å½“å‰å¯èƒ½è¿˜æ˜¯æ—§çš„è¯»å–æ–¹å¼ï¼Œåç»­Phaseä¼šé‡æ„è¿™é‡Œ)
                    return this->loadAndCacheGridData(request, cacheKey); 
                }).unwrap();
        }
        
        // æ–°å¢è¾…åŠ©æ–¹æ³•
        boost::future<std::shared_ptr<GridData>> DataAccessServiceImpl::loadAndCacheGridData(
            const api::GridReadRequest& request, 
            const cache::DataChunkKey& cacheKey) {
            // ... æ—§çš„è¯»å–é€»è¾‘ï¼Œæˆ–è€…è°ƒç”¨å°†åœ¨Phase 5ä¸­é‡æ„çš„è¯»å–å™¨ ...
            // Puntero: std::shared_ptr<IDataReaderImpl> reader = readerFactory_->getReader(filePath);
            // auto data = reader->readGridData(...);
            // 
            // å‡è®¾å·²è·å– data (std::shared_ptr<GridData>)
            // return boost::make_ready_future(data) 
            //    .then([this, cacheKey, data](boost::future<std::shared_ptr<GridData>> /*futData*/) {
            //        unifiedCache_->putAsync(cache::UnifiedDataAccessCache::DATA_CHUNKS_REGION, cacheKey, data, std::nullopt /*ttl*/);
            //        return data;
            //    });
            // æ­¤éƒ¨åˆ†å®ç°ä¾èµ–åç»­è¯»å–å™¨é‡æ„ï¼Œæš‚æ—¶ä¿ç•™ç°æœ‰è¯»å–é€»è¾‘å¹¶åŒ…è£…ç¼“å­˜
            // ç¤ºä¾‹: å‡è®¾ loadFromSourceInternal æ˜¯æ—§çš„è¯»å–é€»è¾‘
            return loadFromSourceInternal(request)
                .then(boost::launch::deferred, [this, cacheKey](boost::future<std::shared_ptr<GridData>> dataFuture) {
                        auto data = dataFuture.get();
                    if (data) { // ç¡®ä¿æ•°æ®æœ‰æ•ˆå†ç¼“å­˜
                         // è®¡ç®—dataçš„å¤§å°ï¼Œå¦‚æœGridDataå®ç°äº†ICacheableValueåˆ™æ›´å¥½
                        size_t dataSize = 0; 
                        auto cacheableData = std::dynamic_pointer_cast<cache::ICacheableValue>(data);
                        if(cacheableData) dataSize = cacheableData->getSizeInBytes();
                        else { /* ä¼°ç®—å¤§å° */ }

                        // ä½¿ç”¨common_utilsçš„CacheItem
                        // auto cacheItem = common_utils::cache::CacheItem<std::shared_ptr<GridData>>(data, dataSize);
                        // unifiedCache_->putAsync(cache::UnifiedDataAccessCache::DATA_CHUNKS_REGION, cacheKey, std::move(cacheItem));
                        // æˆ–è€…ç›´æ¥ä¼ é€’å€¼ï¼Œå¦‚æœICacheManageræ”¯æŒ
                        unifiedCache_->putAsync(cache::UnifiedDataAccessCache::DATA_CHUNKS_REGION, cacheKey, data, std::nullopt);

                        logger_->debug("Data chunk stored in cache for key: {}", cacheKey.toString());
                    }
                        return data;
                    });
        }
        ```
    *   **æ›¿æ¢è·å–å…ƒæ•°æ®é€»è¾‘**: ç±»ä¼¼åœ°ï¼Œä½¿ç”¨ `FileMetadataKey` å’Œ `FILE_METADATA_REGION` åŒºåŸŸæ¥ç¼“å­˜æ–‡ä»¶çº§åˆ«çš„å…ƒæ•°æ®ã€‚
    *   **æ›¿æ¢è¯»å–å™¨å®ä¾‹ç®¡ç†**: å¦‚æœä¹‹å‰æœ‰è¯»å–å™¨å®ä¾‹çš„ç¼“å­˜ï¼ˆå¦‚ `ReaderCache`ï¼‰ï¼Œä¹Ÿå°†å…¶æ›¿æ¢ä¸ºä½¿ç”¨ `UnifiedDataAccessCache` çš„ `READER_INSTANCES_REGION`ã€‚
4.  **åˆ é™¤æ—§çš„ç¼“å­˜æ–‡ä»¶**:
    ```bash
    rm -rf core_services_impl/data_access_service/src/impl/cache/*
    # éªŒè¯ src/impl/ ç›®å½•æ˜¯å¦è¿˜å­˜åœ¨ï¼Œå¦‚æœcacheæ˜¯å…¶ä¸‹æœ€åä¸€ä¸ªå­ç›®å½•ï¼Œåˆ™å¯èƒ½éœ€è¦è°ƒæ•´è·¯å¾„
    # æ ¹æ®2.1çš„æœ€ç»ˆç›®å½•ç»“æ„ï¼Œæ–°çš„ç¼“å­˜æ–‡ä»¶åœ¨ core_services_impl/data_access_service/src/cache/
    ```
    ç¡®ä¿åœ¨ç‰ˆæœ¬æ§åˆ¶ä¸­æ­£ç¡®åˆ é™¤è¿™äº›æ–‡ä»¶ã€‚
5.  **ç¼–å†™å•å…ƒæµ‹è¯•**: 
    *   ä¸º `UnifiedDataAccessCache` ç¼–å†™å•å…ƒæµ‹è¯• (`tests/data_access/cache/unified_data_access_cache_tests.cpp`)ã€‚
        *   æµ‹è¯•ä¸åŒç¼“å­˜åŒºåŸŸçš„åˆ›å»ºå’Œé…ç½®ã€‚
        *   æµ‹è¯• LRU, LFU, TTL ç­–ç•¥çš„æ­£ç¡®æ€§ï¼ˆä¾‹å¦‚ï¼ŒéªŒè¯é¡¹çš„é©±é€é¡ºåºã€è¿‡æœŸï¼‰ã€‚
        *   æµ‹è¯•å¹¶å‘get/putæ“ä½œçš„çº¿ç¨‹å®‰å…¨æ€§ã€‚
        *   æµ‹è¯•ç»Ÿè®¡ä¿¡æ¯çš„å‡†ç¡®æ€§ã€‚
    *   ä¸º `DataAccessServiceImpl` ä¸­ä¸ç¼“å­˜ç›¸å…³çš„éƒ¨åˆ†ç¼–å†™å•å…ƒæµ‹è¯•ï¼Œä½¿ç”¨Mockçš„ `UnifiedDataAccessCache` æ¥éªŒè¯å…¶äº¤äº’é€»è¾‘ã€‚
6.  **é›†æˆä¸æ€§èƒ½æµ‹è¯•**:
    *   é‡æ–°è¿è¡Œ Phase 1 ä¸­å»ºç«‹çš„ `performance_baseline_tests.cpp`ã€‚
    *   æ¯”è¾ƒæ–°æ—§ç¼“å­˜ç³»ç»Ÿçš„æ€§èƒ½æŒ‡æ ‡ï¼šå“åº”æ—¶é—´ã€ç¼“å­˜å‘½ä¸­ç‡ï¼ˆé€šè¿‡ `getRegionStats` è·å–ï¼‰ã€‚
    *   ç›‘æ§å†…å­˜ä½¿ç”¨æƒ…å†µï¼Œç¡®ä¿æ²¡æœ‰æ„å¤–çš„å†…å­˜å¢é•¿ã€‚

**æ¶‰åŠæ–‡ä»¶ (Phase 2):**
*   **æ–°å¢/å®ç°**: 
    *   `src/cache/unified_data_access_cache.cpp` (å®Œæ•´å®ç°)
    *   `tests/data_access/cache/unified_data_access_cache_tests.cpp`
*   **ä¿®æ”¹**: 
    *   `include/core_services/data_access/common_types.h` (æ·»åŠ ç¼“å­˜é”®å®šä¹‰ `DataChunkKey`, `FileMetadataKey`)
    *   `src/data_access_service_impl.h` (æ·»åŠ  `UnifiedDataAccessCache` æˆå‘˜ï¼Œä¿®æ”¹æ„é€ å‡½æ•°)
    *   `src/data_access_service_impl.cpp` (å…¨é¢ä½¿ç”¨ `UnifiedDataAccessCache` æ›¿æ¢æ—§ç¼“å­˜é€»è¾‘)
    *   `tests/data_access/performance_baseline_tests.cpp` (ç”¨äºå¯¹æ¯”æµ‹è¯•ï¼Œå¯èƒ½éœ€è¦é€‚é…æ–°çš„ç»Ÿè®¡è·å–æ–¹å¼)
    *   CMakeLists.txt (æ·»åŠ æ–°æ–‡ä»¶ï¼Œç§»é™¤æ—§æ–‡ä»¶)
*   **åˆ é™¤**: 
    *   æ‰€æœ‰ä½äº `core_services_impl/data_access_service/src/impl/cache/` ä¸‹çš„æ—§ç¼“å­˜æ–‡ä»¶ (å¦‚ `data_chunk_cache.h/cpp`, `reader_cache.h/cpp`, `metadata_cache.h/cpp`, `netcdf_cache_manager.h/cpp`, `cache_manager_template.h`)ã€‚

**é£é™©æ§åˆ¶ä¸éªŒè¯ (Phase 2):**
*   **é€æ­¥æ›¿æ¢**: å¯ä»¥è€ƒè™‘å…ˆæ›¿æ¢ä¸€ä¸ªç¼“å­˜ç±»å‹ï¼ˆå¦‚æ•°æ®å—ç¼“å­˜ï¼‰ï¼ŒéªŒè¯é€šè¿‡åå†æ›¿æ¢å…¶ä»–ç±»å‹ã€‚
*   **åŠŸèƒ½å¼€å…³ (å¯é€‰)**: å¦‚æœç³»ç»Ÿå¤æ‚ï¼Œå¯ä»¥è€ƒè™‘å¼•å…¥ä¸€ä¸ªä¸´æ—¶çš„é…ç½®å¼€å…³ï¼Œå…è®¸åœ¨æ—§ç¼“å­˜å’Œæ–°ç¼“å­˜é—´åˆ‡æ¢ï¼Œä»¥ä¾¿å¿«é€Ÿå›æ»šã€‚
*   **ä¸¥æ ¼æµ‹è¯•**: å•å…ƒæµ‹è¯•è¦†ç›–ç‡åº”å°½å¯èƒ½é«˜ã€‚é›†æˆæµ‹è¯•åº”è¦†ç›–æ‰€æœ‰ä¸»è¦çš„ç”¨ä¾‹ã€‚
*   **æ€§èƒ½ç›‘æ§**: å¯†åˆ‡å…³æ³¨æ€§èƒ½æµ‹è¯•ç»“æœï¼Œä»»ä½•æ€§èƒ½ä¸‹é™éƒ½éœ€è¦è°ƒæŸ¥ã€‚ç›®æ ‡æ˜¯æ€§èƒ½æå‡æˆ–æŒå¹³ï¼ˆåœ¨æŸäº›å¤æ‚åœºæ™¯ä¸‹ï¼‰ã€‚
*   **å†…å­˜åˆ†æ**: ä½¿ç”¨å†…å­˜åˆ†æå·¥å…·æ£€æŸ¥æ˜¯å¦å­˜åœ¨å†…å­˜æ³„æ¼æˆ–ä¸åˆç†çš„å†…å­˜å ç”¨ã€‚
*   **ä»£ç å®¡æŸ¥**: å¯¹ `UnifiedDataAccessCache` çš„å®ç°å’Œ `DataAccessServiceImpl` çš„ä¿®æ”¹è¿›è¡Œå½»åº•å®¡æŸ¥ã€‚

**é¢„æœŸæˆæœ (Phase 2):**
1.  ä¸€ä¸ªåŠŸèƒ½å®Œæ•´ã€åŸºäº `common_utils` çš„ `UnifiedDataAccessCache` æœåŠ¡ã€‚
2.  `DataAccessServiceImpl` å®Œå…¨è¿ç§»åˆ°ä½¿ç”¨æ–°çš„ç»Ÿä¸€ç¼“å­˜ç³»ç»Ÿã€‚
3.  çº¦ 1000-1500 è¡Œæ—§çš„å†—ä½™ç¼“å­˜ä»£ç è¢«æˆåŠŸç§»é™¤ã€‚
4.  é€šè¿‡å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•éªŒè¯äº†æ–°ç¼“å­˜ç³»ç»Ÿçš„æ­£ç¡®æ€§å’Œç¨³å®šæ€§ã€‚
5.  æ€§èƒ½æµ‹è¯•ç»“æœæ˜¾ç¤ºç¼“å­˜å‘½ä¸­ç‡å’Œå“åº”æ—¶é—´å¾—åˆ°æ”¹å–„ï¼ˆæˆ–è‡³å°‘ä¸å·®äºåŸºå‡†ï¼‰ï¼Œå†…å­˜ä½¿ç”¨æ›´åŠ é«˜æ•ˆå¯æ§ã€‚
6.  ä¸ºåç»­çš„å¼‚æ­¥æ¡†æ¶ç»Ÿä¸€å’Œè¯»å–å™¨é‡æ„å¥ å®šäº†åšå®çš„ç¼“å­˜åŸºç¡€ã€‚

---
*è¿™æ˜¯Phase 2çš„è¯¦ç»†è®¡åˆ’ã€‚è¯·æ‚¨å®¡é˜…ã€‚ç¡®è®¤åï¼Œæˆ‘å°†ç»§ç»­æä¾›Phase 3ï¼ˆå¼‚æ­¥æ¡†æ¶ç»Ÿä¸€ï¼‰çš„è®¡åˆ’ã€‚* 

---

### Phase 3: å¼‚æ­¥æ¡†æ¶ç»Ÿä¸€ (é¢„è®¡ Week 3)

**ğŸ¯ ç›®æ ‡:**
-   è®¾è®¡å¹¶å®ç° `UnifiedAsyncExecutor`ï¼Œä½œä¸ºæ¨¡å—å†…æ‰€æœ‰å¼‚æ­¥æ“ä½œçš„ç»Ÿä¸€å…¥å£ï¼Œå°è£… `common_utils::async::TaskManager` çš„ä½¿ç”¨ã€‚
-   åœ¨ `DataAccessServiceImpl` ä¸­å…¨é¢é‡‡ç”¨ `UnifiedAsyncExecutor` æ¥æ‰§è¡Œæ‰€æœ‰è€—æ—¶çš„I/Oæ“ä½œå’Œè®¡ç®—ä»»åŠ¡ï¼Œå–ä»£ç›´æ¥çš„ `boost::async` æˆ–è‡ªå®šä¹‰çº¿ç¨‹æ± è°ƒç”¨ã€‚
-   æ¶ˆé™¤ `boost_future_config.h` ç­‰ä¸æ—§å¼‚æ­¥å®ç°ç›¸å…³çš„é…ç½®å’Œä»£ç ã€‚
-   æå‡å¼‚æ­¥ä»»åŠ¡çš„å¯ç®¡ç†æ€§ã€å¯é…ç½®æ€§ï¼ˆå¦‚ä¼˜å…ˆçº§ã€é‡è¯•ç­–ç•¥ï¼‰å’Œæ•´ä½“æ€§èƒ½ã€‚

**æ ¸å¿ƒä»»åŠ¡:**
1.  **å®ç° `UnifiedAsyncExecutor`**: å®šä¹‰å…¶æ¥å£ï¼ŒåŒ…æ‹¬æ‰§è¡Œé€šç”¨å¼‚æ­¥ä»»åŠ¡ã€ä»¥åŠå¯èƒ½é’ˆå¯¹è¯»å–å™¨æ“ä½œçš„ä¸“ç”¨æ–¹æ³•ã€‚å®ç°ä¸­åº”åˆç†åˆ©ç”¨ `TaskManager` çš„çº¿ç¨‹æ± å’Œä»»åŠ¡è°ƒåº¦èƒ½åŠ›ã€‚
2.  **é‡æ„ `DataAccessServiceImpl`**: ä¿®æ”¹å…¶æ„é€ å‡½æ•°ä»¥æ¥æ”¶ `UnifiedAsyncExecutor` å®ä¾‹ã€‚æ›´æ–°æ‰€æœ‰å¼‚æ­¥æ–¹æ³•ï¼ˆå¦‚ `readGridDataAsync`, `getMetadataAsync` ç­‰ï¼‰ï¼Œä½¿å…¶é€šè¿‡æ–°çš„æ‰§è¡Œå™¨æäº¤ä»»åŠ¡ã€‚
3.  **åˆ é™¤æ—§çš„å¼‚æ­¥ä»£ç å’Œé…ç½®**: ç§»é™¤å¦‚ `boost_future_config.h` åŠæœåŠ¡å†…éƒ¨ç›´æ¥åˆ›å»º `boost::future` çš„é€»è¾‘ã€‚
4.  **ç¼–å†™å•å…ƒæµ‹è¯•**: é’ˆå¯¹ `UnifiedAsyncExecutor` åŠå…¶ä¸ `TaskManager` çš„äº¤äº’è¿›è¡Œæµ‹è¯•ã€‚
5.  **éªŒè¯å¼‚æ­¥æ€§èƒ½å’Œè¡Œä¸º**: ç¡®ä¿å¼‚æ­¥æ“ä½œçš„æ­£ç¡®æ€§ï¼Œä»¥åŠåœ¨è´Ÿè½½ä¸‹çš„æ€§èƒ½è¡¨ç°ä¸åŠ£äºä¹‹å‰ï¼Œå¹¶åˆ†æèµ„æºä½¿ç”¨æƒ…å†µã€‚

**è¯¦ç»†æ­¥éª¤ä¸ä»£ç å®ç°æŒ‡å¼•:**

1.  **åˆ›å»º `UnifiedAsyncExecutor`**: (`src/async/`)
    *   `unified_async_executor.h`:
```cpp
#pragma once
#include <memory>
#include <functional>
#include <string>
        #include <optional>
#include <boost/future.hpp>
#include "common_utils/async/task_manager.h"
#include "common_utils/async/async_priority.h"
#include "common_utils/async/retry_policy.h"
#include "common_utils/logging/logger.h"

namespace oscean::core_services::data_access::async {

class UnifiedAsyncExecutor {
public:
    UnifiedAsyncExecutor(
        std::shared_ptr<common_utils::async::TaskManager> taskManager,
        std::shared_ptr<common_utils::logging::Logger> logger);
    
    template<typename ReturnType, typename TaskFunc>
            boost::future<ReturnType> submit(
        TaskFunc&& task,
                const std::string& taskDescription = "DataAccessGenericTask",
                common_utils::async::AsyncPriority priority = common_utils::async::AsyncPriority::NORMAL,
        std::optional<common_utils::async::RetryPolicy> retryPolicy = std::nullopt,
                // å¯é€‰ï¼šæ˜¯å¦å…è®¸ä»»åŠ¡çªƒå–ç­‰é«˜çº§TaskManagerç‰¹æ€§
                bool allowStealing = true 
            );
        
            // å¯ä»¥è€ƒè™‘ä¸ºç‰¹å®šæ“ä½œç±»å‹ï¼ˆå¦‚IOå¯†é›†å‹ã€CPUå¯†é›†å‹ï¼‰æä¾›ä¸åŒé…ç½®çš„æäº¤æ–¹æ³•
            // template<typename ReturnType, typename TaskFunc>
            // boost::future<ReturnType> submitIOBoundTask(...);
    
private:
    std::shared_ptr<common_utils::async::TaskManager> taskManager_;
    std::shared_ptr<common_utils::logging::Logger> logger_;
    
            // è¾…åŠ©å‡½æ•°ï¼Œå°† AsyncPriority è½¬æ¢ä¸º TaskManager å¯èƒ½éœ€è¦çš„å‚æ•°
            // common_utils::async::TaskAttributes priorityToAttributes(common_utils::async::AsyncPriority priority);
};

} // namespace
```
    *   `unified_async_executor.cpp`:
        ```cpp
        #include "unified_async_executor.h"
        
        namespace oscean::core_services::data_access::async {
        
        UnifiedAsyncExecutor::UnifiedAsyncExecutor(
            std::shared_ptr<common_utils::async::TaskManager> taskManager,
            std::shared_ptr<common_utils::logging::Logger> logger)
            : taskManager_(std::move(taskManager)), logger_(std::move(logger)) {
            if (!taskManager_) {
                throw std::invalid_argument("TaskManager cannot be null for UnifiedAsyncExecutor");
            }
            logger_->info("UnifiedAsyncExecutor initialized.");
        }
        
        template<typename ReturnType, typename TaskFunc>
        boost::future<ReturnType> UnifiedAsyncExecutor::submit(
            TaskFunc&& task, 
            const std::string& taskDescription,
            common_utils::async::AsyncPriority priority,
            std::optional<common_utils::async::RetryPolicy> retryPolicy, // retryPolicyæš‚æœªç›´æ¥é›†æˆè¿›TaskManager submit
            bool allowStealing) {
            
            // TaskManager::submit é€šå¸¸è¿”å› std::future, éœ€è¦é€‚é…ä¸º boost::future
            // æˆ–è€… TaskManager ç›´æ¥æ”¯æŒè¿”å› boost::future (éœ€ç¡®è®¤ common_utils å®ç°)
            // å‡è®¾ TaskManager::submit è¿”å› std::future
            
            // æ„é€  TaskAttributes (å¦‚æœ TaskManager éœ€è¦)
            common_utils::async::TaskAttributes attributes;
            attributes.description = taskDescription;
            attributes.priority = priority; 
            // attributes.allowStealing = allowStealing; 
            // attributes.retryPolicy = retryPolicy; // TaskManager å¯èƒ½å†…éƒ¨å¤„ç†é‡è¯•æˆ–è¿”å›å¯é‡è¯•çš„future

            // å°è£…ä¸€å±‚ä»¥é€‚é…è¿”å›ç±»å‹å’Œå¯èƒ½çš„é‡è¯•é€»è¾‘ (å¦‚æœTaskManagerä¸ç›´æ¥æ”¯æŒ)
            // å¦‚æœ TaskManager çš„ submit ç›´æ¥æ”¯æŒ boost::future å’Œ RetryPolicyï¼Œåˆ™å¯ä»¥ç›´æ¥è°ƒç”¨
            
            // ç®€åŒ–ç‰ˆï¼šç›´æ¥æäº¤ï¼Œä¸å¤„ç†é‡è¯•ç­–ç•¥äºæ­¤å±‚é¢ï¼Œä¾èµ–TaskManageræˆ–è°ƒç”¨è€…
            // æ³¨æ„ï¼šcommon_utils::TaskManager::submit çš„ç¡®åˆ‡ç­¾åå’Œèƒ½åŠ›æ˜¯å…³é”®
            auto stdFuture = taskManager_->submit<ReturnType>(std::forward<TaskFunc>(task), attributes);

            // å°† std::future è½¬æ¢ä¸º boost::future
            // è¿™é€šå¸¸éœ€è¦ä¸€ä¸ª promise å’Œä¸€ä¸ªåœ¨ stdFuture å®Œæˆæ—¶è®¾ç½® promise çš„æœºåˆ¶
            // æˆ–è€…ï¼Œå¦‚æœ common_utils æä¾›äº†è½¬æ¢å‡½æ•°ï¼Œåˆ™ä½¿ç”¨å®ƒã€‚
            // ç®€å•çš„è½¬æ¢ï¼ˆæ— å¼‚å¸¸ä¼ æ’­ç»†èŠ‚å¤„ç†çš„ç®€åŒ–ç¤ºä¾‹ï¼‰ï¼š
            boost::promise<ReturnType> promise;
            boost::future<ReturnType> boostFuture = promise.get_future();
            
            // åœ¨TaskManagerçš„çº¿ç¨‹ä¸­æ‰§è¡Œä»¥ä¸‹lambdaæ¥æ¡¥æ¥
            taskManager_->submit<void>([stdFuture = std::move(stdFuture), promise = std::move(promise)]() mutable {
                try {
                    if constexpr (std::is_same_v<ReturnType, void>) {
                        stdFuture.get();
                        promise.set_value();
                    } else {
                        promise.set_value(stdFuture.get());
                    }
                } catch (...) {
                    promise.set_exception(boost::current_exception());
                }
            }, "FutureBridgeTask"); // æäº¤ä¸€ä¸ªè¾…åŠ©ä»»åŠ¡æ¥å®Œæˆæ¡¥æ¥

            return boostFuture;
            
            // ---- æ›´ç†æƒ³çš„æƒ…å†µï¼šTaskManager ç›´æ¥æ”¯æŒ boost::future ----
            // return taskManager_->submitBoost<ReturnType>(std::forward<TaskFunc>(task), attributes);
        }

        // éœ€è¦ä¸ºæ¨¡æ¿æ–¹æ³•åœ¨cppä¸­æä¾›æ˜¾å¼å®ä¾‹åŒ–æˆ–å°†å…¶å®Œå…¨ç§»è‡³å¤´æ–‡ä»¶
        // æ˜¾å¼å®ä¾‹åŒ–ç¤ºä¾‹ (æ ¹æ®å®é™…ä½¿ç”¨çš„ç±»å‹):
        template boost::future<std::shared_ptr<oscean::core_services::data_access::api::GridData>> 
        UnifiedAsyncExecutor::submit<std::shared_ptr<oscean::core_services::data_access::api::GridData>, std::function<std::shared_ptr<oscean::core_services::data_access::api::GridData>()>>(
            std::function<std::shared_ptr<oscean::core_services::data_access::api::GridData>()>&&, 
            const std::string&, 
            common_utils::async::AsyncPriority, 
            std::optional<common_utils::async::RetryPolicy>, 
            bool);
        // ... ä¸ºå…¶ä»–éœ€è¦çš„ç±»å‹å®ä¾‹åŒ– ...

        } // namespace
        ```
        *æ³¨: `std::future` åˆ° `boost::future` çš„è½¬æ¢ï¼Œä»¥åŠé‡è¯•ç­–ç•¥çš„é›†æˆï¼Œä¾èµ– `common_utils::TaskManager` çš„å…·ä½“å®ç°ã€‚ä¸Šè¿°ä»£ç æä¾›äº†ä¸€ç§å¯èƒ½çš„æ¡¥æ¥æ–¹å¼ï¼Œä½†ç†æƒ³æƒ…å†µä¸‹ `TaskManager` åº”ç›´æ¥æ”¯æŒæˆ–æä¾›å·¥å…·ç±»ã€‚å¦‚æœæ¨¡æ¿æ–¹æ³•ä¸»ä½“è¾ƒå¤æ‚æˆ–ä¾èµ–è¾ƒå¤šï¼Œå»ºè®®å°†å…¶ä¿ç•™åœ¨å¤´æ–‡ä»¶ä¸­ã€‚*

2.  **é‡æ„ `DataAccessServiceImpl`**: 
    *   åœ¨ `data_access_service_impl.h` ä¸­æ·»åŠ  `std::shared_ptr<async::UnifiedAsyncExecutor> asyncExecutor_;` æˆå‘˜ã€‚
    *   ä¿®æ”¹æ„é€ å‡½æ•°ï¼Œæ³¨å…¥ `UnifiedAsyncExecutor` çš„å®ä¾‹ã€‚
    *   **æ›´æ–°å¼‚æ­¥æ–¹æ³•**: ä¾‹å¦‚ `loadAndCacheGridData` (åœ¨Phase 2ä¸­å¼•å…¥çš„è¾…åŠ©æ–¹æ³•ï¼Œç”¨äºå®é™…åŠ è½½æ•°æ®) æˆ–ç›´æ¥ä¿®æ”¹å¦‚ `readGridDataAsync` çš„æ ¸å¿ƒåŠ è½½éƒ¨åˆ†ã€‚
```cpp
        // data_access_service_impl.cpp (loadAndCacheGridData ç¤ºä¾‹ç‰‡æ®µ)
        boost::future<std::shared_ptr<GridData>> DataAccessServiceImpl::loadAndCacheGridData(
            const api::GridReadRequest& request, 
            const cache::DataChunkKey& cacheKey) {
            
            // å°†å®é™…çš„æ•°æ®åŠ è½½æ“ä½œå°è£…ä¸ºä¸€ä¸ª lambda
            auto loadOperation = [this, request]() -> std::shared_ptr<GridData> {
                // logger_->debug("Executing actual data load for: {}", request.filePath);
                // ... è¿™é‡Œæ˜¯ä¹‹å‰ç›´æ¥æ‰§è¡Œçš„I/Oå¯†é›†å‹æˆ–CPUå¯†é›†å‹çš„æ•°æ®è¯»å–é€»è¾‘ ...
                // ... (ä¾‹å¦‚ï¼Œè°ƒç”¨åº•å±‚çš„GDAL/NetCDFè¯»å–å‡½æ•°) ...
                // ... è¿™ä¸ªé€»è¾‘å°†åœ¨Phase 5è¢«è¿›ä¸€æ­¥é‡æ„ä¸ºé€šè¿‡UnifiedDataReaderæ‰§è¡Œ ...
                // å‡è®¾: auto data = performActualReadOperation(request);
                // return data;
                
                // ä¸´æ—¶çš„ä¼ªå®ç°ï¼Œç›´åˆ°Phase 5
                if (request.filePath.empty()) { // ç¤ºä¾‹é”™è¯¯å¤„ç†
                     throw std::runtime_error("File path is empty in GridReadRequest");
                }
                logger_->info("(Pseudo-load) Loading data for {} variable {}", request.filePath, request.variableName);
                // è¿”å›ä¸€ä¸ªä¼ªé€ çš„GridDataç”¨äºæµç¨‹æµ‹è¯•
                auto dummyData = std::make_shared<GridData>(); 
                // dummyData->tensor = ... åˆ›å»ºä¸€äº›æ•°æ® ...
                return dummyData; 
            };
        
            // ä½¿ç”¨ UnifiedAsyncExecutor æäº¤ä»»åŠ¡
            return asyncExecutor_->submit<std::shared_ptr<GridData>>(
                std::move(loadOperation), 
                "LoadGridData:" + request.filePath + "/" + request.variableName,
                common_utils::async::AsyncPriority::HIGH // æ ¹æ®æƒ…å†µè°ƒæ•´ä¼˜å…ˆçº§
            ).then(boost::launch::deferred, [this, cacheKey](boost::future<std::shared_ptr<GridData>> dataFuture) {
                // ... (ç¼“å­˜é€»è¾‘åŒPhase 2) ...
                 auto data = dataFuture.get(); // è·å–å¼‚æ­¥åŠ è½½çš„ç»“æœ
                 if (data) {
                     unifiedCache_->putAsync(cache::UnifiedDataAccessCache::DATA_CHUNKS_REGION, cacheKey, data, std::nullopt);
                     logger_->debug("Data chunk stored in cache for key: {}", cacheKey.toString());
                 }
                 return data;
            });
        }
        ```
    *   ç¡®ä¿æ‰€æœ‰çš„ `then` å’Œ `unwrap` è°ƒç”¨åœ¨åˆé€‚çš„æ‰§è¡Œä¸Šä¸‹æ–‡ä¸­ï¼ˆä¾‹å¦‚ï¼Œå¦‚æœå›è°ƒå¾ˆå¿«ï¼Œå¯ä»¥ç”¨ `boost::launch::deferred`ï¼›å¦‚æœå›è°ƒä¹Ÿè€—æ—¶ï¼Œä¹Ÿåº”é€šè¿‡ `asyncExecutor_` è°ƒåº¦ï¼‰ã€‚

3.  **åˆ é™¤æ—§çš„å¼‚æ­¥é…ç½®å’Œä»£ç **: 
    *   ä» `CMakeLists.txt` å’Œé¡¹ç›®ä¸­åˆ é™¤ `include/core_services/data_access/boost_future_config.h` (å¦‚æœå®ƒåªç”¨äºæ­¤æ¨¡å—çš„å¼‚æ­¥é…ç½®)ã€‚
    *   æ£€æŸ¥ `DataAccessServiceImpl` å’Œå…¶ä»–ç›¸å…³ç±»ï¼Œç§»é™¤æ‰€æœ‰ç›´æ¥çš„ `boost::async` è°ƒç”¨æˆ–è‡ªå®šä¹‰çš„çº¿ç¨‹ç®¡ç†ä»£ç ï¼Œæ›¿æ¢ä¸ºé€šè¿‡ `UnifiedAsyncExecutor`ã€‚

4.  **ç¼–å†™å•å…ƒæµ‹è¯•**: (`tests/data_access/async/unified_async_executor_tests.cpp`)
    *   æµ‹è¯• `UnifiedAsyncExecutor::submit` æ˜¯å¦èƒ½æˆåŠŸå°†ä»»åŠ¡æäº¤ç»™ `MockTaskManager`ã€‚
    *   éªŒè¯ä¸åŒä¼˜å…ˆçº§çš„ä»»åŠ¡æ˜¯å¦èƒ½è¢«æ­£ç¡®ä¼ é€’ã€‚
    *   æµ‹è¯•å½“ `TaskManager` è¿”å›æˆåŠŸæˆ–å¤±è´¥æ—¶ï¼Œ`UnifiedAsyncExecutor` æ˜¯å¦èƒ½æ­£ç¡®ä¼ é€’ç»“æœæˆ–å¼‚å¸¸ã€‚
    *   ä¸º `DataAccessServiceImpl` ä¸­ä½¿ç”¨ `UnifiedAsyncExecutor` çš„æ–¹æ³•ç¼–å†™å•å…ƒæµ‹è¯•ï¼ŒMock `UnifiedAsyncExecutor`ã€‚

5.  **é›†æˆä¸æ€§èƒ½æµ‹è¯•**: 
    *   è¿è¡Œæ‰€æœ‰ç°æœ‰é›†æˆæµ‹è¯•ï¼Œç¡®ä¿ç³»ç»ŸåŠŸèƒ½å’Œå¼‚æ­¥æµç¨‹çš„æ­£ç¡®æ€§ã€‚
    *   å†æ¬¡è¿è¡ŒPhase 1å»ºç«‹çš„æ€§èƒ½åŸºå‡†æµ‹è¯•ã€‚é‡ç‚¹å…³æ³¨ï¼š
        *   å¼‚æ­¥æ“ä½œçš„ç«¯åˆ°ç«¯å“åº”æ—¶é—´ã€‚
        *   ç³»ç»Ÿåœ¨é«˜å¹¶å‘è¯·æ±‚ä¸‹çš„ååé‡å’Œç¨³å®šæ€§ã€‚
        *   `TaskManager` çš„çº¿ç¨‹æ± åˆ©ç”¨ç‡å’Œä»»åŠ¡é˜Ÿåˆ—æƒ…å†µï¼ˆå¦‚æœ `TaskManager` æä¾›ç›¸åº”ç›‘æ§æ¥å£ï¼‰ã€‚
    *   ç›®æ ‡æ˜¯æ€§èƒ½ä¸æ˜¾è‘—ä¸‹é™ï¼Œç†æƒ³æƒ…å†µä¸‹å› æ›´ä¼˜çš„çº¿ç¨‹ç®¡ç†è€Œæœ‰æ‰€æå‡æˆ–æ›´ç¨³å®šã€‚

**æ¶‰åŠæ–‡ä»¶ (Phase 3):**
*   **æ–°å¢/å®ç°**: 
    *   `src/async/unified_async_executor.h`
    *   `src/async/unified_async_executor.cpp`
    *   `tests/data_access/async/unified_async_executor_tests.cpp`
*   **ä¿®æ”¹**: 
    *   `src/data_access_service_impl.h` (æ·»åŠ  `UnifiedAsyncExecutor` æˆå‘˜ï¼Œä¿®æ”¹æ„é€ å‡½æ•°)
    *   `src/data_access_service_impl.cpp` (æ‰€æœ‰å¼‚æ­¥æ“ä½œé€šè¿‡ `UnifiedAsyncExecutor` æäº¤)
    *   `tests/data_access/data_access_service_impl_tests.cpp` (é€‚é…Mockçš„ `UnifiedAsyncExecutor`)
    *   CMakeLists.txt (æ·»åŠ æ–°æ–‡ä»¶ï¼Œç§»é™¤æ—§æ–‡ä»¶)
*   **åˆ é™¤**: 
    *   `include/core_services/data_access/boost_future_config.h` (å¦‚æœç¡®è®¤ä¸å†è¢«å…¶ä»–åœ°æ–¹éœ€è¦)
    *   æœåŠ¡å†…éƒ¨ç›´æ¥åˆ›å»º `boost::packaged_task` æˆ–è°ƒç”¨ `boost::async` çš„ç›¸å…³ä»£ç ã€‚

**é£é™©æ§åˆ¶ä¸éªŒè¯ (Phase 3):**
*   **TaskManager ä¾èµ–**: `UnifiedAsyncExecutor` çš„å®ç°é«˜åº¦ä¾èµ– `common_utils::async::TaskManager` çš„æ¥å£å’Œè¡Œä¸ºã€‚ç¡®ä¿å¯¹å…¶æœ‰æ¸…æ™°ç†è§£ã€‚
*   **Future ç±»å‹æ¡¥æ¥**: `std::future` åˆ° `boost::future` çš„è½¬æ¢éœ€è¦å°å¿ƒå¤„ç†ï¼Œç¡®ä¿å¼‚å¸¸å’Œå€¼çš„æ­£ç¡®ä¼ æ’­ã€‚å¦‚æœ `TaskManager` èƒ½ç›´æ¥è¿”å› `boost::future` æˆ–æä¾›è½¬æ¢å·¥å…·ï¼Œå°†å¤§å¤§ç®€åŒ–å®ç°ã€‚
*   **çº¿ç¨‹æ¨¡å‹**: ç¡®ä¿ `UnifiedAsyncExecutor` çš„ä½¿ç”¨ä¸ `TaskManager` çš„çº¿ç¨‹æ¨¡å‹ï¼ˆå¦‚çº¿ç¨‹æ± å¤§å°ã€ä»»åŠ¡é˜Ÿåˆ—è¡Œä¸ºï¼‰ç›¸åŒ¹é…ï¼Œé¿å…ä¸å¿…è¦çš„é˜»å¡æˆ–èµ„æºç«äº‰ã€‚
*   **å›è°ƒæ‰§è¡Œä¸Šä¸‹æ–‡**: `boost::future::then()` çš„å›è°ƒé»˜è®¤æ‰§è¡Œæ–¹å¼å¯èƒ½ä¸é¢„æœŸä¸åŒã€‚éœ€è¦æ˜ç¡®æŒ‡å®š `boost::launch`ç­–ç•¥ï¼Œæˆ–ç¡®ä¿å›è°ƒæœ¬èº«ä¹Ÿé€šè¿‡ `UnifiedAsyncExecutor` æäº¤ï¼Œä»¥é¿å…é˜»å¡ `TaskManager` çš„å·¥ä½œçº¿ç¨‹æˆ–åœ¨éé¢„æœŸçº¿ç¨‹æ‰§è¡Œã€‚
*   **æ€§èƒ½å›å½’**: å¯†åˆ‡ç›‘æ§æ€§èƒ½æµ‹è¯•ï¼Œä»»ä½•æ˜¾è‘—çš„æ€§èƒ½ä¸‹é™éƒ½éœ€è¦åˆ†ææ˜¯ç”±äºæ‰§è¡Œå™¨æœ¬èº«å¼€é”€ï¼Œè¿˜æ˜¯ä»»åŠ¡æäº¤/è°ƒåº¦æ–¹å¼ä¸å½“ã€‚

**é¢„æœŸæˆæœ (Phase 3):**
1.  ä¸€ä¸ªåŠŸèƒ½å®Œå–„çš„ `UnifiedAsyncExecutor`ï¼Œä½œä¸ºæ¨¡å—å†…å¼‚æ­¥ä»»åŠ¡çš„ç»Ÿä¸€è°ƒåº¦ä¸­å¿ƒã€‚
2.  `DataAccessServiceImpl` ä¸­çš„å¼‚æ­¥æ“ä½œå…¨éƒ¨è¿ç§»è‡³é€šè¿‡ `UnifiedAsyncExecutor` æ‰§è¡Œã€‚
3.  ç§»é™¤äº†çº¦ 100-300 è¡Œä¸æ—§å¼‚æ­¥å®ç°ç›¸å…³çš„ä»£ç å’Œé…ç½®ã€‚
4.  å¼‚æ­¥ä»»åŠ¡çš„ç®¡ç†æ›´åŠ é›†ä¸­å’Œè§„èŒƒï¼Œä¸ºåç»­å¼•å…¥æ›´å¤æ‚çš„å¼‚æ­¥æ§åˆ¶ï¼ˆå¦‚è¶…æ—¶ã€å–æ¶ˆã€é‡è¯•ï¼‰æ‰“ä¸‹åŸºç¡€ã€‚
5.  ç³»ç»Ÿåœ¨å¤„ç†å¹¶å‘è¯·æ±‚æ—¶çš„ç¨³å®šæ€§å’Œèµ„æºåˆ©ç”¨ç‡å¾—åˆ°æ”¹å–„æˆ–ä¿æŒã€‚

---
*è¿™æ˜¯Phase 3çš„è¯¦ç»†è®¡åˆ’ã€‚è¯·æ‚¨å®¡é˜…ã€‚ç¡®è®¤åï¼Œæˆ‘å°†ç»§ç»­æä¾›Phase 4ï¼ˆæ—¶é—´å¤„ç†ç»Ÿä¸€ï¼‰çš„è®¡åˆ’ã€‚* 

---

### Phase 4: æ—¶é—´å¤„ç†ç»Ÿä¸€ (é¢„è®¡ Week 4)

**ğŸ¯ ç›®æ ‡:**
-   è®¾è®¡å¹¶å®ç° `CFTimeExtractor`ï¼Œåˆ©ç”¨ `common_utils::time` æä¾›çš„æ—¥å†å’Œæ—¶é—´è½¬æ¢èƒ½åŠ›ï¼Œä¸“é—¨å¤„ç†CFçº¦å®šä¸‹çš„æ—¶é—´åæ ‡ï¼ˆå¦‚ "days since YYYY-MM-DD HH:MM:SS" æ ¼å¼ï¼‰ã€‚
-   åœ¨éœ€è¦è¿›è¡Œæ—¶é—´è§£æå’Œè½¬æ¢çš„åœ°æ–¹ï¼ˆä¸»è¦æ˜¯åœ¨NetCDFè¯»å–å™¨ä¸­è·å–æ—¶é—´èŒƒå›´æˆ–å¤„ç†æ—¶é—´ç»´åº¦æ—¶ï¼‰ä½¿ç”¨ `CFTimeExtractor`ã€‚
-   å½»åº•åˆ é™¤æ—§çš„ `NetCDFTimeProcessor` åŠå…¶ç›¸å…³çš„æ—¶é—´å¤„ç†ä»£ç ï¼Œå‡å°‘é‡å¤å®ç°ã€‚
-   ç¡®ä¿æ—¶é—´è½¬æ¢çš„å‡†ç¡®æ€§ï¼Œå¹¶ç¬¦åˆCFæ ‡å‡†çº¦å®šã€‚

**æ ¸å¿ƒä»»åŠ¡:**
1.  **å®ç° `CFTimeExtractor`**: å®šä¹‰å…¶æ¥å£ï¼Œä½¿å…¶èƒ½å¤Ÿä»å…ƒæ•°æ®ä¸­æå–æ—¶é—´å•ä½ã€å‚è€ƒæ—¥æœŸã€æ—¥å†ç±»å‹ï¼Œå¹¶èƒ½å°†æ—¶é—´åæ ‡å€¼è½¬æ¢ä¸ºæ ‡å‡†çš„æ—¥æœŸæ—¶é—´å¯¹è±¡ (å¦‚ `common_utils::time::CalendarTime`)ã€‚
2.  **é‡æ„NetCDFè¯»å–å™¨ä¸­çš„æ—¶é—´å¤„ç†é€»è¾‘**: å½“NetCDFè¯»å–å™¨ï¼ˆå°†åœ¨Phase 5é‡æ„ä¸º `NetCDFUnifiedReader`ï¼‰éœ€è¦è§£ææ—¶é—´ä¿¡æ¯æ—¶ï¼Œåº”å®ä¾‹åŒ–å¹¶ä½¿ç”¨ `CFTimeExtractor`ã€‚
3.  **åˆ é™¤æ—§çš„æ—¶é—´å¤„ç†ä»£ç **: å®‰å…¨ç§»é™¤ `src/impl/readers/netcdf/parsing/netcdf_time_processor.h/cpp`ã€‚
4.  **ç¼–å†™å•å…ƒæµ‹è¯•**: é’ˆå¯¹ `CFTimeExtractor` çš„å„ç§CFæ—¶é—´å­—ç¬¦ä¸²æ ¼å¼å’Œæ—¥å†ç±»å‹è¿›è¡Œè¯¦å°½æµ‹è¯•ã€‚
5.  **éªŒè¯æ—¶é—´å¤„ç†çš„å‡†ç¡®æ€§**: é€šè¿‡é›†æˆæµ‹è¯•ï¼Œç¡®ä¿ä»NetCDFæ–‡ä»¶ä¸­è¯»å–çš„æ—¶é—´ä¿¡æ¯ä¸é¢„æœŸä¸€è‡´ã€‚

**è¯¦ç»†æ­¥éª¤ä¸ä»£ç å®ç°æŒ‡å¼•:**

1.  **åˆ›å»º `CFTimeExtractor`**: (`src/time/`)
    *   `cf_time_extractor.h`:
```cpp
#pragma once
#include <memory>
#include <string>
        #include <optional>
#include <boost/future.hpp>
        #include "common_utils/time/i_time_extractor.h" // ä» common_utils ç»§æ‰¿æˆ–ç±»ä¼¼æ¥å£
#include "common_utils/time/calendar_time.h"
#include "common_utils/time/time_range.h"
#include "common_utils/time/calendar_converter.h"
        #include "common_utils/logging/logger.h"
        #include "../api/i_metadata_provider.h" // ç”¨äºè·å–æ—¶é—´å˜é‡çš„å±æ€§

namespace oscean::core_services::data_access::time {

/**
         * @brief Extracts time information according to CF conventions.
         * Relies on common_utils::time for actual calendar conversions.
 */
class CFTimeExtractor : public common_utils::time::ITimeExtractor {
public:
    CFTimeExtractor(
                std::weak_ptr<api::IMetadataProvider> metadataProvider, // To fetch 'units' and 'calendar' attributes
                const std::string& timeVariableName, // The name of the time coordinate variable
        std::shared_ptr<common_utils::logging::Logger> logger);
    
            // Parses a CF-compliant time unit string (e.g., "days since 1970-01-01 00:00:00")
            // and a numeric time value, then converts it to CalendarTime.
    boost::future<std::optional<common_utils::time::CalendarTime>> 
                convertCoordinateToCalendarTimeAsync(double timeCoordinateValue) override;
        
            // Converts a vector of time coordinate values.
            boost::future<std::vector<std::optional<common_utils::time::CalendarTime>>>
                convertCoordinatesToCalendarTimesAsync(const std::vector<double>& timeCoordinateValues);
            
            // Extracts the overall time range for the configured time variable.
            boost::future<std::optional<common_utils::time::TimeRange>> getTimeRangeAsync() override;

            // ITimeExtractor (common_utils) MIGHT have these, if so, implement or remove if not needed by data_access
            // boost::future<std::optional<common_utils::time::CalendarTime>> 
            //     extractTimeAsync(const std::string& timeValueString) override; 
            // boost::future<std::optional<common_utils::time::TimeRange>> 
            //     extractTimeRangeAsync(const std::string& timeRangeString) override;
    
private:
            struct TimeAttrs {
                std::string units;
                common_utils::time::CalendarType calendar;
                // Potentially store the parsed reference_datetime from units here
                common_utils::time::CalendarDateTime referenceDateTime;
            };

    std::weak_ptr<api::IMetadataProvider> metadataProvider_;
            std::string timeVariableName_;
    std::shared_ptr<common_utils::logging::Logger> logger_;
            std::shared_ptr<common_utils::time::CalendarConverter> calendarConverter_;
    
            boost::shared_future<std::optional<TimeAttrs>> timeAttrsFuture_; // Cache for attributes
            mutable boost::shared_mutex timeAttrsMutex_; // To protect initialization of timeAttrsFuture_
    
            boost::future<std::optional<TimeAttrs>> fetchTimeAttributesAsync();
            std::optional<TimeAttrs> parseTimeAttributes(const std::vector<MetadataEntry>& attrs);
};

} // namespace
```
    *   `cf_time_extractor.cpp`:
        ```cpp
        #include "cf_time_extractor.h"
        #include "common_utils/time/cf_time_parser.h" // Assuming common_utils provides this parser
        #include "common_utils/string/string_utils.h" // For parsing helps

        namespace oscean::core_services::data_access::time {

        CFTimeExtractor::CFTimeExtractor(
            std::weak_ptr<api::IMetadataProvider> metadataProvider,
            const std::string& timeVariableName,
            std::shared_ptr<common_utils::logging::Logger> logger)
            : metadataProvider_(std::move(metadataProvider)), 
              timeVariableName_(timeVariableName),
              logger_(std::move(logger)),
              calendarConverter_(std::make_shared<common_utils::time::CalendarConverter>()) {
            logger_->info("CFTimeExtractor created for variable: {}", timeVariableName_);
        }

        boost::future<std::optional<CFTimeExtractor::TimeAttrs>> CFTimeExtractor::fetchTimeAttributesAsync() {
            auto provider = metadataProvider_.lock();
            if (!provider) {
                logger_->warn("MetadataProvider expired for CFTimeExtractor on var: {}", timeVariableName_);
                return boost::make_ready_future<std::optional<TimeAttrs>>(std::nullopt);
            }

            return provider->getVariableMetadataAsync(timeVariableName_)
                .then(boost::launch::deferred, [this](boost::future<std::optional<std::vector<MetadataEntry>>> futureAttrs) {
                    auto variableAttrsOpt = futureAttrs.get();
                    if (!variableAttrsOpt) {
                        logger_->warn("Could not fetch metadata for time variable: {}", timeVariableName_);
                        return std::optional<TimeAttrs>(std::nullopt);
                    }
                    return parseTimeAttributes(*variableAttrsOpt);
                });
        }

        std::optional<CFTimeExtractor::TimeAttrs> CFTimeExtractor::parseTimeAttributes(
            const std::vector<MetadataEntry>& attrs) {
            TimeAttrs parsedAttrs;
            std::string calendarStr = "standard"; // CF Default

            for (const auto& entry : attrs) {
                if (entry.key == "units") {
                    parsedAttrs.units = entry.value;
                } else if (entry.key == "calendar") {
                    calendarStr = common_utils::string::toLowerCase(entry.value);
                }
            }

            if (parsedAttrs.units.empty()) {
                logger_->warn("Time variable '{}' has no 'units' attribute.", timeVariableName_);
                return std::nullopt;
            }

            parsedAttrs.calendar = common_utils::time::stringToCalendarType(calendarStr);
            
            // Use common_utils::time::CFTimeParser to parse units string
            auto parseResult = common_utils::time::CFTimeParser::parseCFUnits(parsedAttrs.units, parsedAttrs.calendar);
            if (!parseResult) {
                 logger_->warn("Failed to parse CF units string '{}' for variable '{}'", parsedAttrs.units, timeVariableName_);
                 return std::nullopt;
            }
            parsedAttrs.referenceDateTime = parseResult->referenceTimestamp;
            // Store also the unit multiplier (e.g., seconds, days) from parseResult if needed for conversion logic

            logger_->debug("Parsed time attributes for '{}': units='{}', calendar='{}'", 
                timeVariableName_, parsedAttrs.units, calendarStr);
            return parsedAttrs;
        }

        // Helper to get (and cache) time attributes
        // boost::shared_future<std::optional<CFTimeExtractor::TimeAttrs>> getCachedTimeAttrs(CFTimeExtractor* self) {
        //      boost::unique_lock<boost::shared_mutex> lock(self->timeAttrsMutex_);
        //      if (!self->timeAttrsFuture_.is_ready()) { // Check if already fetching or fetched
        //          self->timeAttrsFuture_ = self->fetchTimeAttributesAsync().share();
        //      }
        //      return self->timeAttrsFuture_;
        // }
        // Corrected getCachedTimeAttrs to be a member function for easier access to member variables
        boost::shared_future<std::optional<CFTimeExtractor::TimeAttrs>> CFTimeExtractor::getCachedTimeAttrs() {
             boost::unique_lock<boost::shared_mutex> lock(timeAttrsMutex_); // Protects concurrent initialization
             if (!timeAttrsFuture_.is_valid() || !timeAttrsFuture_.is_ready()) { // is_valid() to check if it holds a shared state
                 timeAttrsFuture_ = fetchTimeAttributesAsync().share();
             }
             return timeAttrsFuture_;
        }


        boost::future<std::optional<common_utils::time::CalendarTime>> 
        CFTimeExtractor::convertCoordinateToCalendarTimeAsync(double timeCoordinateValue) {
            return getCachedTimeAttrs().then(boost::launch::deferred, 
                [this, timeCoordinateValue](boost::shared_future<std::optional<TimeAttrs>> futureCachedAttrs) {
                auto attrsOpt = futureCachedAttrs.get();
                if (!attrsOpt || !attrsOpt.has_value()) {
                    logger_->warn("Cannot convert time coordinate for '{}': missing attributes.", timeVariableName_);
                    return std::optional<common_utils::time::CalendarTime>(std::nullopt);
                }
                const auto& attrs = attrsOpt.value();
                
                // Actual conversion using CalendarConverter
                return calendarConverter_->convertCFTimeToCalendarTime(timeCoordinateValue, attrs.units, attrs.calendar);
            });
        }

        boost::future<std::vector<std::optional<common_utils::time::CalendarTime>>>
        CFTimeExtractor::convertCoordinatesToCalendarTimesAsync(const std::vector<double>& timeCoordinateValues) {
            return getCachedTimeAttrs().then(boost::launch::deferred, 
                [this, timeCoordinateValues](boost::shared_future<std::optional<TimeAttrs>> futureCachedAttrs) {
                auto attrsOpt = futureCachedAttrs.get();
                if (!attrsOpt || !attrsOpt.has_value()) {
                    logger_->warn("Cannot convert time coordinates for '{}': missing attributes.", timeVariableName_);
                    return std::vector<std::optional<common_utils::time::CalendarTime>>(timeCoordinateValues.size(), std::nullopt);
                }
                const auto& attrs = attrsOpt.value();
                std::vector<std::optional<common_utils::time::CalendarTime>> results;
                results.reserve(timeCoordinateValues.size());
                for (double val : timeCoordinateValues) {
                     results.push_back(calendarConverter_->convertCFTimeToCalendarTime(val, attrs.units, attrs.calendar));
                }
                return results;
            });
        }

        boost::future<std::optional<common_utils::time::TimeRange>> CFTimeExtractor::getTimeRangeAsync() {
            logger_->warn("getTimeRangeAsync for CFTimeExtractor is not fully implemented yet for '{}'. Needs coordinate data access or IMetadataProvider enhancement.", timeVariableName_);
            return boost::make_ready_future<std::optional<common_utils::time::TimeRange>>(std::nullopt);
        }

} // namespace
```
        *æ³¨: `CFTimeExtractor` çš„å®ç°ä¾èµ– `common_utils::time` ä¸­å¼ºå¤§çš„ `CalendarConverter` å’Œä¸€ä¸ªç†æƒ³çš„ `CFTimeParser`ã€‚`getTimeRangeAsync` çš„å®ç°æ¯”è¾ƒå¤æ‚ï¼Œå¯èƒ½éœ€è¦ `IDataProvider` çš„èƒ½åŠ›æ¥è¯»å–æ—¶é—´è½´çš„å®é™…æ•°å€¼èŒƒå›´ï¼Œè¿™è¶…å‡ºäº†çº¯å…ƒæ•°æ®æå–çš„èŒƒç•´ï¼Œéœ€è¦ä»”ç»†è€ƒè™‘å…¶èŒè´£åˆ’åˆ†ã€‚`getCachedTimeAttrs`è¾…åŠ©å‡½æ•°æ˜¯ä¸ºäº†é¿å…é‡å¤å¼‚æ­¥è·å–å…ƒæ•°æ®å±æ€§ã€‚*

2.  **åœ¨ NetCDF è¯»å–å™¨ä¸­ä½¿ç”¨ `CFTimeExtractor`** (å°†åœ¨Phase 5å…·ä½“å®ç° `NetCDFUnifiedReader` æ—¶é›†æˆ):
    *   å½“ `NetCDFUnifiedReader` (æœªæ¥çš„) éœ€è¦è·å–æ—¶é—´èŒƒå›´æˆ–è½¬æ¢æ—¶é—´åæ ‡æ—¶ï¼Œå®ƒä¼šåˆ›å»º `CFTimeExtractor` çš„å®ä¾‹ã€‚
```cpp
        // In NetCDFUnifiedReader.cpp (Conceptual for Phase 5)
        // ...
        // private:
        //  std::map<std::string, std::shared_ptr<time::CFTimeExtractor>> timeExtractors_;
        // ...
        // boost::future<std::optional<TimeRange>> NetCDFUnifiedReader::getTimeRangeAsync(
        //     const std::string& timeVariableName) const {
        //     
        //     auto it = timeExtractors_.find(timeVariableName);
        //     if (it == timeExtractors_.end()) {
        //         // Create on demand, passing 'this' as IMetadataProvider (if reader implements it)
        //         auto extractor = std::make_shared<time::CFTimeExtractor>(
        //              std::static_pointer_cast<api::IMetadataProvider>(shared_from_this()), 
        //              timeVariableName, 
        //              logger_);
        //         timeExtractors_[timeVariableName] = extractor; // Cache it
        //         it = timeExtractors_.find(timeVariableName);
        //     }
        //     return it->second->getTimeRangeAsync(); // This still has the issue of needing data
        // }
        ```
    *   å½“è¯»å–å…·ä½“çš„æ—¶é—´åæ ‡æ•°æ®åï¼Œå¯ä»¥ä½¿ç”¨ `CFTimeExtractor::convertCoordinatesToCalendarTimesAsync` è¿›è¡Œè½¬æ¢ã€‚

3.  **åˆ é™¤æ—§çš„æ—¶é—´å¤„ç†ä»£ç **:
    *   `src/impl/readers/netcdf/parsing/netcdf_time_processor.h`
    *   `src/impl/readers/netcdf/parsing/netcdf_time_processor.cpp`
    *   ä» `netcdf_coordinate_system_parser.cpp` (æˆ–ç±»ä¼¼æ–‡ä»¶) ä¸­ç§»é™¤æ‰€æœ‰ä¸æ—¶é—´å•ä½è§£æã€æ—¶é—´å€¼è½¬æ¢ç›¸å…³çš„æ—§é€»è¾‘ï¼Œä½¿å…¶åªå…³æ³¨ç©ºé—´åæ ‡ç³»ç»Ÿå’Œç»´åº¦ã€‚
    *   æ›´æ–° CMakeLists.txtã€‚

4.  **ç¼–å†™å•å…ƒæµ‹è¯•**: (`tests/data_access/time/cf_time_extractor_tests.cpp`)
    *   **Mock `IMetadataProvider`**: ç”¨äºæä¾›å„ç§æ—¶é—´å˜é‡çš„ `units` å’Œ `calendar` å±æ€§ç»„åˆã€‚
    *   æµ‹è¯• `convertCoordinateToCalendarTimeAsync`:
        *   ä¸åŒå•ä½: "seconds since ...", "days since ...", "hours since ...", etc.
        *   ä¸åŒå‚è€ƒæ—¥æœŸå’Œæ—¶é—´ã€‚
        *   ä¸åŒæ—¥å†: "standard", "gregorian", "proleptic_gregorian", "noleap", "360_day", "365_day", "366_day", etc.
        *   è¾¹ç•Œæ¡ä»¶å’Œæ— æ•ˆè¾“å…¥ï¼ˆå¦‚é”™è¯¯çš„å•ä½å­—ç¬¦ä¸²ã€ä¸æ”¯æŒçš„æ—¥å†ï¼‰ã€‚
    *   æµ‹è¯• `convertCoordinatesToCalendarTimesAsync` çš„æ‰¹é‡è½¬æ¢æ­£ç¡®æ€§ã€‚
    *   (å¦‚æœå®ç°) æµ‹è¯• `getTimeRangeAsync` çš„é€»è¾‘ï¼Œä½†è¿™å¯èƒ½éœ€è¦æ›´å¤æ‚çš„ Mock æˆ–å°†å…¶ä½œä¸ºé›†æˆæµ‹è¯•çš„ä¸€éƒ¨åˆ†ã€‚

5.  **é›†æˆä¸éªŒè¯**: 
    *   åœ¨NetCDFè¯»å–ç›¸å…³çš„é›†æˆæµ‹è¯•ä¸­ï¼ŒéªŒè¯é€šè¿‡ `CFTimeExtractor` è·å–çš„æ—¶é—´ä¿¡æ¯ï¼ˆå¦‚æ—¶é—´èŒƒå›´ã€å…·ä½“æ—¶é—´ç‚¹ï¼‰æ˜¯å¦ä¸å·²çŸ¥æµ‹è¯•æ–‡ä»¶ä¸­çš„å†…å®¹ä¸€è‡´ã€‚
    *   ç‰¹åˆ«å…³æ³¨ä¸åŒæ—¥å†ç±»å‹ä¸‹çš„æ—¥æœŸè®¡ç®—å‡†ç¡®æ€§ã€‚

**æ¶‰åŠæ–‡ä»¶ (Phase 4):**
*   **æ–°å¢/å®ç°**: 
    *   `src/time/cf_time_extractor.h`
    *   `src/time/cf_time_extractor.cpp`
    *   `tests/data_access/time/cf_time_extractor_tests.cpp`
*   **ä¿®æ”¹**: 
    *   `src/readers/netcdf/internal/netcdf_coordinate_system_parser.cpp` (æˆ–ç±»ä¼¼æ–‡ä»¶): ç§»é™¤æ—§çš„æ—¶é—´å¤„ç†é€»è¾‘ã€‚
    *   (åœ¨Phase 5) `src/readers/netcdf/netcdf_unified_reader.cpp` (å°†é›†æˆ `CFTimeExtractor`)
    *   CMakeLists.txt (æ·»åŠ æ–°æ–‡ä»¶ï¼Œç§»é™¤æ—§æ–‡ä»¶)
*   **åˆ é™¤**: 
    *   `src/impl/readers/netcdf/parsing/netcdf_time_processor.h`
    *   `src/impl/readers/netcdf/parsing/netcdf_time_processor.cpp`

**é£é™©æ§åˆ¶ä¸éªŒè¯ (Phase 4):**
*   **`common_utils::time` ä¾èµ–**: `CFTimeExtractor` çš„å¥å£®æ€§å’Œå‡†ç¡®æ€§é«˜åº¦ä¾èµ– `common_utils::time` ä¸­ `CalendarConverter` å’Œ `CFTimeParser` çš„æ­£ç¡®æ€§ã€‚ç¡®ä¿è¿™äº›åŸºç¡€ç»„ä»¶ç»è¿‡å……åˆ†æµ‹è¯•ã€‚
*   **CFçº¦å®šè¦†ç›–**: CFçº¦å®šå¯¹äºæ—¶é—´çš„è¡¨ç¤ºæœ‰å¾ˆå¤šç»†èŠ‚ã€‚ç¡®ä¿ `CFTimeExtractor` å’Œä¾èµ–çš„ `common_utils` ç»„ä»¶èƒ½è¦†ç›–å¸¸è§çš„å’Œä¸€äº›ä¸å¸¸è§çš„ä½†æœ‰æ•ˆçš„CFæ—¶é—´è¡¨ç¤ºã€‚
*   **`IMetadataProvider` æ¥å£**: `CFTimeExtractor` éœ€è¦ä» `IMetadataProvider` è·å–æ—¶é—´å˜é‡çš„å±æ€§ã€‚ç¡®ä¿æ­¤äº¤äº’æ¸…æ™°ä¸”é«˜æ•ˆï¼ˆå¦‚é€šè¿‡ `shared_future` ç¼“å­˜å±æ€§ï¼‰ã€‚
*   **`getTimeRangeAsync` èŒè´£**: å¦‚å‰è¿°ï¼Œè·å–å®Œæ•´æ—¶é—´èŒƒå›´å¯èƒ½éœ€è¦æ•°æ®è®¿é—®æƒé™ï¼Œéœ€è¦ä»”ç»†è€ƒè™‘æ­¤æ–¹æ³•åœ¨ `CFTimeExtractor` ä¸­çš„å®šä½å’Œå®ç°æ–¹å¼ï¼Œæˆ–è€…å°†å…¶ç§»è‡³æ›´é«˜å±‚çº§ã€‚
*   **æµ‹è¯•æ•°æ®**: éœ€è¦å‡†å¤‡åŒ…å«å„ç§CFæ—¶é—´å•ä½å’Œæ—¥å†ç±»å‹çš„NetCDFæµ‹è¯•æ–‡ä»¶ï¼Œä»¥è¿›è¡Œæœ‰æ•ˆçš„å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•ã€‚

**é¢„æœŸæˆæœ (Phase 4):**
1.  ä¸€ä¸ªåŠŸèƒ½å®Œå–„ã€ç»è¿‡æµ‹è¯•çš„ `CFTimeExtractor`ï¼Œèƒ½å¤Ÿå‡†ç¡®è§£æå’Œè½¬æ¢CFçº¦å®šçš„æ—¶é—´ä¿¡æ¯ã€‚
2.  ç§»é™¤äº†çº¦ 200+ è¡Œç‰¹å®šäºNetCDFçš„æ—§æ—¶é—´å¤„ç†ä»£ç ã€‚
3.  æ—¶é—´å¤„ç†é€»è¾‘æ›´åŠ é›†ä¸­ã€æ ‡å‡†åŒ–ï¼Œå¹¶ä¸ `common_utils` ä¿æŒä¸€è‡´ã€‚
4.  ä¸ºPhase 5ä¸­NetCDFè¯»å–å™¨çš„é‡æ„åšå¥½äº†æ—¶é—´å¤„ç†æ–¹é¢çš„å‡†å¤‡ã€‚
5.  é€šè¿‡æµ‹è¯•éªŒè¯äº†æ—¶é—´è½¬æ¢åœ¨å„ç§å¸¸è§CFçº¦å®šä¸‹çš„å‡†ç¡®æ€§ã€‚

---
*è¿™æ˜¯Phase 4çš„è¯¦ç»†è®¡åˆ’ã€‚è¯·æ‚¨å®¡é˜…ã€‚ç¡®è®¤åï¼Œæˆ‘å°†ç»§ç»­æä¾›Phase 5ï¼ˆè¯»å–å™¨æ¶æ„é‡æ„ï¼‰çš„è®¡åˆ’ã€‚*

---

### Phase 5: è¯»å–å™¨æ¶æ„é‡æ„ (é¢„è®¡ Week 5-6)

**ğŸ¯ ç›®æ ‡:**
-   å»ºç«‹ä¸€ä¸ªåŸºäºæ–°æ¥å£ (`IDataSource`, `IMetadataProvider`, `IDataProvider`, `IStreamingDataProvider`) çš„ç»Ÿä¸€è¯»å–å™¨æ¶æ„ã€‚
-   å®ç° `UnifiedDataReader` æŠ½è±¡åŸºç±»ï¼Œä¸ºå„ç§å…·ä½“æ–‡ä»¶æ ¼å¼çš„è¯»å–å™¨æä¾›é€šç”¨åŠŸèƒ½å’Œç»Ÿä¸€çš„å®ç°æ¨¡å¼ã€‚
-   å°†ç°æœ‰çš„ GDAL å’Œ NetCDF è¯»å–é€»è¾‘é‡æ„ä¸ºç»§æ‰¿è‡ª `UnifiedDataReader` çš„å…·ä½“å®ç°ç±» (å¦‚ `GdalUnifiedReader`, `NetCDFUnifiedReader`)ã€‚
-   å®ç° `ReaderRegistry` (è¯»å–å™¨æ³¨å†Œè¡¨) å’Œ `FormatDetector` (æ ¼å¼æ¢æµ‹å™¨)ï¼Œä»¥æ”¯æŒæ ¹æ®æ–‡ä»¶ç±»å‹/å†…å®¹åŠ¨æ€åˆ›å»ºåˆé€‚çš„è¯»å–å™¨å®ä¾‹ã€‚
-   å½»åº•ç§»é™¤æ—§çš„ `IDataReaderImpl` æ¥å£ã€`SharedReaderVariant` ä»¥åŠç›¸å…³çš„ `ReaderFactory`ã€‚
-   ä½¿ `DataAccessServiceImpl` é€šè¿‡ `ReaderRegistry` è·å–è¯»å–å™¨å®ä¾‹ï¼Œè€Œä¸æ˜¯ç›´æ¥å®ä¾‹åŒ–æˆ–ä½¿ç”¨æ—§å·¥å‚ã€‚

**æ ¸å¿ƒä»»åŠ¡:**
1.  **å®ç° `UnifiedDataReader` åŸºç±»**: åŒ…å«å¯¹ `IDataSource` éƒ¨åˆ†æ¥å£çš„é€šç”¨å®ç°ï¼Œå¹¶å£°æ˜å…¶ä»–æ¥å£çš„çº¯è™šå‡½æ•°ï¼Œä¾›å­ç±»å®ç°ã€‚
2.  **å®ç° `FormatDetector`**: è®¾è®¡ `IFormatDetector` æ¥å£åŠ `FormatDetectorImpl` å®ç°ï¼Œèƒ½å¤Ÿæ ¹æ®æ–‡ä»¶æ‰©å±•åã€æ–‡ä»¶å¤´éƒ¨é­”æ³•æ•°ç­‰ä¿¡æ¯åˆ¤æ–­æ–‡ä»¶æ ¼å¼ã€‚
3.  **å®ç° `ReaderRegistry`**: èƒ½å¤Ÿæ³¨å†Œä¸åŒæ ¼å¼çš„è¯»å–å™¨å·¥å‚å‡½æ•°ï¼Œå¹¶æ ¹æ® `FormatDetector` çš„ç»“æœåˆ›å»ºç›¸åº”çš„ `UnifiedDataReader` å®ä¾‹ã€‚
4.  **é‡æ„ GDAL è¯»å–å™¨**: åˆ›å»º `GdalUnifiedReader` (å¯èƒ½éœ€è¦åŒºåˆ† Raster å’Œ Vectorï¼Œæˆ–ç”¨ä¸€ä¸ªç±»å¤„ç†ä¸¤ç§æƒ…å†µ)ï¼Œå®ç°æ‰€æœ‰æ–°æ¥å£ï¼Œå†…éƒ¨å°è£…GDALåº“çš„è°ƒç”¨ã€‚å°†åŸ `gdal_raster_reader.h/cpp` å’Œ `gdal_vector_reader.h/cpp` çš„é€»è¾‘è¿ç§»å¹¶é‡æ„åˆ°è¿™é‡Œã€‚
5.  **é‡æ„ NetCDF è¯»å–å™¨**: åˆ›å»º `NetCDFUnifiedReader`ï¼Œå®ç°æ‰€æœ‰æ–°æ¥å£ï¼Œå†…éƒ¨å°è£…NetCDFåº“è°ƒç”¨ï¼Œå¹¶ä½¿ç”¨ Phase 4 åˆ›å»ºçš„ `CFTimeExtractor` å¤„ç†æ—¶é—´ã€‚å°†åŸ `netcdf_cf_reader.h/cpp` çš„é€»è¾‘è¿ç§»å¹¶é‡æ„ã€‚
6.  **é‡æ„ `DataAccessServiceImpl`**: ä¿®æ”¹å…¶è·å–å’Œä½¿ç”¨æ•°æ®è¯»å–å™¨çš„æ–¹å¼ï¼Œä½¿å…¶é€šè¿‡ `ReaderRegistry` æ¥åŠ¨æ€åˆ›å»ºè¯»å–å™¨å®ä¾‹ã€‚
7.  **åˆ é™¤æ—§çš„è¯»å–å™¨ç›¸å…³ä»£ç **: åŒ…æ‹¬ `IDataReaderImpl`, `SharedReaderVariant`, `ReaderFactory` ä»¥åŠæ—§çš„è¯»å–å™¨å®ç°æ–‡ä»¶ã€‚
8.  **ç¼–å†™å…¨é¢çš„å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•**: é’ˆå¯¹æ–°çš„è¯»å–å™¨åŸºç±»ã€å…·ä½“å®ç°ã€æ³¨å†Œè¡¨ã€æ ¼å¼æ¢æµ‹å™¨è¿›è¡Œæµ‹è¯•ã€‚

**è¯¦ç»†æ­¥éª¤ä¸ä»£ç å®ç°æŒ‡å¼•:**

1.  **åˆ›å»º `UnifiedDataReader` åŸºç±»**: (`src/readers/core/`)
    *   `unified_data_reader.h`:
```cpp
#pragma once
#include <string>
        #include <memory>
#include <boost/future.hpp>
        #include "../../api/i_data_source.h"
        #include "../../api/i_metadata_provider.h"
        #include "../../api/i_data_provider.h"
        #include "../../api/i_streaming_data_provider.h"
        #include "common_utils/logging/logger.h"
        #include "core_services/crs/i_crs_service.h" // ä¾èµ–CRSæœåŠ¡è¿›è¡Œåæ ‡è½¬æ¢

namespace oscean::core_services::data_access::readers {

        class UnifiedDataReader : public api::IDataSource,
                                  public api::IMetadataProvider,
                                  public api::IDataProvider,
                                  public api::IStreamingDataProvider,
                                  public std::enable_shared_from_this<UnifiedDataReader> { // enable_shared_from_this for async callbacks
        protected:
            std::string filePath_;
            bool isOpen_ = false;
            std::shared_ptr<common_utils::logging::Logger> logger_;
            std::shared_ptr<core_services::ICrsService> crsService_; // Injected CRS service
            // UnifiedAsyncExecutor might be needed here if reader operations are complex and need offloading
            // std::shared_ptr<async::UnifiedAsyncExecutor> asyncExecutor_;
        
public:
            UnifiedDataReader(
                const std::string& filePath,
        std::shared_ptr<common_utils::logging::Logger> logger,
                std::shared_ptr<core_services::ICrsService> crsService
                // std::shared_ptr<async::UnifiedAsyncExecutor> asyncExecutor // Optional injection
            );
            virtual ~UnifiedDataReader() = default;
        
            // IDataSource - éƒ¨åˆ†é»˜è®¤å®ç°
            std::string getFilePath() const noexcept override { return filePath_; }
            bool isOpen() const noexcept override { return isOpen_; }
        
            // IDataSource - å­ç±»å¿…é¡»å®ç°
            boost::future<bool> openAsync(const std::string& filePath) override = 0;
            boost::future<void> closeAsync() override = 0;
            std::string getDataSourceType() const noexcept override = 0; // e.g., "GDAL_RASTER", "NETCDF_CF"
            boost::future<std::optional<FileMetadata>> extractFileMetadataSummaryAsync() override = 0; // For caching/format detection aid

            // IMetadataProvider - å­ç±»å¿…é¡»å®ç°æ‰€æœ‰æ–¹æ³•
            // ... (getVariableNamesAsync, getNativeCrsAsync, etc.)
        
            // IDataProvider - å­ç±»å¿…é¡»å®ç°æ‰€æœ‰æ–¹æ³•

            ---

### Phase 6: æµå¼å¤„ç†å®ç°ä¸æœ€ç»ˆé›†æˆ (é¢„è®¡ Week 7)

**ğŸ¯ ç›®æ ‡:**
-   åœ¨æ–°çš„è¯»å–å™¨æ¶æ„åŸºç¡€ä¸Šï¼Œä¸º `DataAccessService` æ·»åŠ æµå¼æ•°æ®è¯»å–èƒ½åŠ›ï¼Œå…è®¸å®¢æˆ·ç«¯é€å—å¤„ç†å¤§è§„æ¨¡æ•°æ®é›†ï¼Œä»¥æ§åˆ¶å†…å­˜å ç”¨ã€‚
-   å®ç° `StreamingDataProcessor`ï¼Œè´Ÿè´£åè°ƒæµå¼è¯»å–æ“ä½œï¼Œç®¡ç†æ•°æ®å—çš„è·å–å’Œåˆ†å‘ã€‚
-   ç¡®ä¿ `GdalUnifiedReader` å’Œ `NetCDFUnifiedReader` æ­£ç¡®å¹¶é«˜æ•ˆåœ°å®ç° `IStreamingDataProvider` æ¥å£ã€‚
-   å®Œæˆæ‰€æœ‰ç»„ä»¶çš„æœ€ç»ˆé›†æˆï¼Œè¿›è¡Œå…¨é¢çš„å›å½’æµ‹è¯•ã€æ€§èƒ½æµ‹è¯•å’Œå‹åŠ›æµ‹è¯•ã€‚
-   ç¼–å†™æœ€ç»ˆçš„é‡æ„æŠ¥å‘Šå’Œæ›´æ–°ç›¸å…³æ–‡æ¡£ï¼Œç¡®è®¤æ‰€æœ‰é‡æ„ç›®æ ‡å‡å·²è¾¾æˆã€‚

**æ ¸å¿ƒä»»åŠ¡:**
1.  **å®Œå–„ `IStreamingDataProvider` æ¥å£å®ç°**: åœ¨ `GdalUnifiedReader` å’Œ `NetCDFUnifiedReader` ä¸­å…·ä½“å®ç° `streamVariableDataAsync` å’Œ/æˆ– `getNextDataChunkAsync` æ–¹æ³•ï¼Œç¡®ä¿èƒ½å¤Ÿæœ‰æ•ˆåœ°ä»åº•å±‚åº“é€å—è¯»å–æ•°æ®ã€‚
2.  **å®ç° `StreamingDataProcessor`**: è¯¥ç±»å°†ä½¿ç”¨ `ReaderRegistry` è·å–å®ç°äº† `IStreamingDataProvider` æ¥å£çš„è¯»å–å™¨ï¼Œå¹¶ç®¡ç†æµå¼æ•°æ®å—çš„å¤„ç†æµç¨‹ã€‚
3.  **åœ¨ `DataAccessServiceImpl` ä¸­æš´éœ²æµå¼API**: æ·»åŠ æ–°çš„å…¬å…±æ–¹æ³•åˆ° `IDataAccessService` å’Œ `DataAccessServiceImpl`ï¼Œå…è®¸å®¢æˆ·ç«¯å‘èµ·æµå¼è¯»å–è¯·æ±‚ï¼Œå¹¶æ¥æ”¶æ•°æ®å—æµã€‚
4.  **ç¼–å†™æµå¼å¤„ç†çš„å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•**: ä¸“æ³¨äºå¤§æ•°æ®é›†çš„æµå¼è¯»å–ã€å†…å­˜æ§åˆ¶ã€èƒŒå‹æœºåˆ¶ï¼ˆå¦‚æœå®ç°ï¼‰ã€é”™è¯¯å¤„ç†å’Œå–æ¶ˆæ“ä½œã€‚
5.  **è¿›è¡Œç³»ç»Ÿçº§é›†æˆä¸å›å½’æµ‹è¯•**: ç¡®ä¿æ‰€æœ‰é‡æ„åçš„ç»„ä»¶ï¼ˆç¼“å­˜ã€å¼‚æ­¥ã€æ—¶é—´ã€è¯»å–å™¨ã€æµå¼å¤„ç†ï¼‰ååŒå·¥ä½œæ­£å¸¸ï¼Œä¸”æ‰€æœ‰åŸæœ‰åŠŸèƒ½æœªå—å½±å“ã€‚
6.  **æ‰§è¡Œæœ€ç»ˆæ€§èƒ½å’Œå‹åŠ›æµ‹è¯•**: å¯¹æ¯”é‡æ„å‰åçš„æ€§èƒ½æŒ‡æ ‡ï¼ŒéªŒè¯æ˜¯å¦è¾¾åˆ°é¢„æœŸç›®æ ‡ï¼ˆç¼“å­˜å‘½ä¸­ç‡ã€å†…å­˜ä½¿ç”¨ã€å“åº”æ—¶é—´ç­‰ï¼‰ã€‚
7.  **ä»£ç å®¡æŸ¥ä¸æ–‡æ¡£æ›´æ–°**: å¯¹æ‰€æœ‰ä¸»è¦çš„æ–°ä»£ç å’Œé‡æ„ä»£ç è¿›è¡Œæœ€ç»ˆå®¡æŸ¥ã€‚æ›´æ–°æ‰€æœ‰ç›¸å…³çš„è®¾è®¡æ–‡æ¡£ã€APIæ–‡æ¡£å’Œç”¨æˆ·æ‰‹å†Œã€‚

**è¯¦ç»†æ­¥éª¤ä¸ä»£ç å®ç°æŒ‡å¼•:**

1.  **å®Œå–„ `GdalUnifiedReader` å’Œ `NetCDFUnifiedReader` ä¸­çš„ `IStreamingDataProvider` å®ç°**:
    *   **`streamVariableDataAsync` æ–¹æ³•**:
        *   å†…éƒ¨å¾ªç¯è¯»å–æ•°æ®å— (e.g., using GDAL\'s `RasterIO` with windowing, or NetCDF\'s `get_vara` for hyperslabs)ã€‚
        *   æ¯è¯»å–ä¸€ä¸ªæ•°æ®å— (`DataChunk`)ï¼Œå°±è°ƒç”¨ä¼ é€’è¿›æ¥çš„ `chunkProcessor` å›è°ƒå‡½æ•°ã€‚
        *   å¤„ç†å›è°ƒå‡½æ•°çš„ `boost::future<bool>` è¿”å›å€¼ï¼Œå¦‚æœä¸º `false`ï¼Œåˆ™æå‰ä¸­æ­¢æµå¼å¤„ç†ã€‚
        *   éœ€è¦ä»”ç»†ç®¡ç†è¯»å–çš„åç§»é‡/ç´¢å¼•ï¼Œç¡®ä¿ä¸é—æ¼ã€ä¸é‡å¤ã€‚
        *   è€ƒè™‘åˆé€‚çš„é»˜è®¤å—å¤§å°ï¼Œå¹¶å…è®¸é€šè¿‡ `StreamingOptions` è¿›è¡Œé…ç½®ã€‚
    *   **`getNextDataChunkAsync` æ–¹æ³• (å¦‚æœé€‰æ‹©å®ç°pullæ¨¡å¼)**:
        *   è¯»å–å™¨å†…éƒ¨éœ€è¦ç»´æŠ¤å½“å‰æµçš„çŠ¶æ€ï¼ˆå¦‚å½“å‰å—ç´¢å¼•ã€æ–‡ä»¶å¥æŸ„ï¼‰ã€‚
        *   æ¯æ¬¡è°ƒç”¨è¿”å›ä¸‹ä¸€ä¸ªæ•°æ®å—ï¼Œå¦‚æœåˆ°è¾¾æ•°æ®æœ«å°¾åˆ™è¿”å› `std::nullopt`ã€‚
    *   **é”™è¯¯å¤„ç†**: ç¡®ä¿åœ¨è¯»å–è¿‡ç¨‹ä¸­å‘ç”Ÿçš„ä»»ä½•I/Oé”™è¯¯æˆ–åº“é”™è¯¯éƒ½èƒ½è¢«æ­£ç¡®æ•è·å¹¶å‘ä¸Šä¼ æ’­ã€‚
    *   **èµ„æºç®¡ç†**: ç¡®ä¿åœ¨æµå¼å¤„ç†ç»“æŸæˆ–å‘ç”Ÿé”™è¯¯æ—¶ï¼Œæ‰€æœ‰æ‰“å¼€çš„èµ„æºéƒ½å¾—åˆ°é‡Šæ”¾ã€‚

2.  **åˆ›å»º `StreamingDataProcessor`**: (`src/streaming/`)
    *   `streaming_data_processor.h`:
```cpp
#pragma once
#include <memory>
#include <functional>
        #include <string>
#include <boost/future.hpp>
        #include "../api/i_streaming_data_provider.h" // For DataChunk
        #include "../api/streaming_types.h"
        #include "../async/unified_async_executor.h"
        #include "../readers/core/reader_registry.h"
        #include "common_utils/logging/logger.h"

namespace oscean::core_services::data_access::streaming {

class StreamingDataProcessor {
public:
    StreamingDataProcessor(
        std::shared_ptr<readers::ReaderRegistry> readerRegistry,
                std::shared_ptr<async::UnifiedAsyncExecutor> asyncExecutor, // For managing reader creation & stream operations
        std::shared_ptr<common_utils::logging::Logger> logger);
    
            // Initiates and manages a push-based stream of data chunks
    boost::future<void> processStreamAsync(
        const std::string& filePath,
        const std::string& variableName,
                const api::StreamingOptions& options,
                std::function<boost::future<bool>(api::DataChunk)> chunkProcessor);

            // Potentially: methods for pull-based streaming if getNextDataChunkAsync is implemented
            // boost::future<std::string> openStreamAsync(const std::string& filePath, ...); // Returns a stream handle
            // boost::future<std::optional<api::DataChunk>> pullNextChunkAsync(const std::string& streamHandle);
            // boost::future<void> closeStreamAsync(const std::string& streamHandle);
    
private:
    std::shared_ptr<readers::ReaderRegistry> readerRegistry_;
            std::shared_ptr<async::UnifiedAsyncExecutor> asyncExecutor_;
    std::shared_ptr<common_utils::logging::Logger> logger_;
    
            // Helper to get a reader that supports streaming
            boost::future<std::shared_ptr<api::IStreamingDataProvider>> getStreamingReaderAsync(
                const std::string& filePath);
        };

        } // namespace
        ```
    *   `streaming_data_processor.cpp`:
        ```cpp
        #include "streaming_data_processor.h"
        #include "../readers/core/unified_data_reader.h"

        namespace oscean::core_services::data_access::streaming {

        StreamingDataProcessor::StreamingDataProcessor(
            std::shared_ptr<readers::ReaderRegistry> readerRegistry,
            std::shared_ptr<async::UnifiedAsyncExecutor> asyncExecutor,
            std::shared_ptr<common_utils::logging::Logger> logger)
            : readerRegistry_(std::move(readerRegistry)),
              asyncExecutor_(std::move(asyncExecutor)),
              logger_(std::move(logger)) {
            logger_->info("StreamingDataProcessor initialized.");
        }

        boost::future<std::shared_ptr<api::IStreamingDataProvider>>
        StreamingDataProcessor::getStreamingReaderAsync(const std::string& filePath) {
            return readerRegistry_->createReaderAsync(filePath)
                .then(boost::launch::deferred, [this, filePath](boost::future<std::shared_ptr<readers::UnifiedDataReader>> futureReader) {
                    auto reader = futureReader.get();
                    if (!reader) {
                        logger_->error("Failed to create reader for file: {}", filePath);
                        throw std::runtime_error("Failed to create reader for streaming: " + filePath);
                    }
                    // Attempt to cast to IStreamingDataProvider
                    std::shared_ptr<api::IStreamingDataProvider> streamingProvider =
                        std::dynamic_pointer_cast<api::IStreamingDataProvider>(reader);
                    if (!streamingProvider) {
                        logger_->error("Reader for file \'{}\' does not support IStreamingDataProvider.", filePath);
                        // reader->closeAsync(); // Important to close if not usable
                        throw std::runtime_error("Reader does not support streaming: " + filePath);
                    }
                    return streamingProvider;
                });
        }

        boost::future<void> StreamingDataProcessor::processStreamAsync(
            const std::string& filePath,
        const std::string& variableName,
            const api::StreamingOptions& options,
            std::function<boost::future<bool>(api::DataChunk)> chunkProcessor) {

            return getStreamingReaderAsync(filePath)
                .then(boost::launch::deferred,
                    [this, variableName, options, chunkProcessor](boost::future<std::shared_ptr<api::IStreamingDataProvider>> futureProvider) {
                    auto streamingProvider = futureProvider.get();
                    // Ensure the reader (IDataSource part) is open before streaming
                    // This might be handled by createReaderAsync or needs explicit call
                    // For simplicity, assuming createReaderAsync already opens or it handles it internally.

                    // Submit the actual streaming operation via asyncExecutor if it's long-running
                    // or if the IStreamingDataProvider::streamVariableDataAsync itself is fully async.
                    // Here we assume streamVariableDataAsync is a boost::future returning method.
                    return streamingProvider->streamVariableDataAsync(variableName, chunkProcessor, options);
                })
                .then(boost::launch::deferred, [this, filePath](boost::future<void> streamFuture) {
                    try {
                        streamFuture.get(); // Propagate exceptions
                        logger_->info("Successfully completed streaming for file: {}", filePath);
                    } catch (const std::exception& e) {
                        logger_->error("Error during streaming for file \'{}\': {}", filePath, e.what());
                        // Reader should be closed by its own RAII or explicit close in IStreamingDataProvider impl
                        throw; // Re-throw to propagate
                    }
                    // Close the reader? If the reader was cached, this might be an issue.
                    // Lifecycle of reader needs care. If obtained from registry and cached,
                    // closing it here might affect other users of the cached reader.
                    // Best if IStreamingDataProvider methods handle their open/close internally for the stream,
                    // or if the reader is not cached for streaming operations, or ref-counted.
                });
        }

} // namespace
```

3.  **åœ¨ `DataAccessServiceImpl` ä¸­æš´éœ²æµå¼ API**: (`src/`)
    *   ä¿®æ”¹ `include/core_services/data_access/i_data_access_service.h`: æ·»åŠ æ–°çš„æµå¼æ¥å£ï¼Œä¾‹å¦‚ï¼š
        ```cpp
        virtual boost::future<void> streamGridVariableAsync(
            const std::string& filePath,
            const std::string& variableName,
            const api::StreamingOptions& options,
            std::function<boost::future<bool>(api::DataChunk)> chunkProcessor) = 0;
        ```
    *   åœ¨ `data_access_service_impl.h/cpp` ä¸­å®ç°æ­¤æ¥å£ï¼š
        *   æ³¨å…¥ `StreamingDataProcessor` å®ä¾‹ï¼ˆæˆ–åœ¨æ„é€ å‡½æ•°ä¸­åˆ›å»ºï¼‰ã€‚
        *   å®ç°æ–¹æ³•å°†è°ƒç”¨ `streamingDataProcessor_->processStreamAsync(...)`ã€‚
        ```cpp
        // data_access_service_impl.h
        // ... private members ...
        // std::shared_ptr<streaming::StreamingDataProcessor> streamingProcessor_;

        // data_access_service_impl.cpp - constructor
        // streamingProcessor_ = std::make_shared<streaming::StreamingDataProcessor>(readerRegistry_, asyncExecutor_, logger_);

        // data_access_service_impl.cpp - method impl
        boost::future<void> DataAccessServiceImpl::streamGridVariableAsync(
            const std::string& filePath,
            const std::string& variableName,
            const api::StreamingOptions& options,
            std::function<boost::future<bool>(api::DataChunk)> chunkProcessor) {
            if (!streamingProcessor_) { // Should have been initialized
                return boost::make_exceptional_future<void>(std::runtime_error("StreamingProcessor not initialized"));
            }
            return streamingProcessor_->processStreamAsync(filePath, variableName, options, chunkProcessor);
        }
        ```

4.  **æµå¼å¤„ç†çš„å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•**:
    *   **å•å…ƒæµ‹è¯•**:
        *   ä¸º `GdalUnifiedReader` å’Œ `NetCDFUnifiedReader` çš„æµå¼æ–¹æ³•ç¼–å†™å•å…ƒæµ‹è¯•ï¼ŒMockåº•å±‚åº“è°ƒç”¨ï¼ŒéªŒè¯æ•°æ®å—çš„æ­£ç¡®åˆ†å‰²å’Œå›è°ƒè°ƒç”¨ã€‚
        *   ä¸º `StreamingDataProcessor` ç¼–å†™å•å…ƒæµ‹è¯•ï¼ŒMock `ReaderRegistry` å’Œ `IStreamingDataProvider`ï¼Œæµ‹è¯•å…¶åè°ƒé€»è¾‘ã€‚
    *   **é›†æˆæµ‹è¯•**: (`tests/data_access/streaming_tests.cpp`)
        *   ä½¿ç”¨çœŸå®çš„ã€éå¸¸å¤§çš„æ …æ ¼å’ŒNetCDFæ–‡ä»¶ã€‚
        *   éªŒè¯æµå¼è¯»å–æ˜¯å¦èƒ½å®Œæ•´è¯»å–æ‰€æœ‰æ•°æ®ï¼Œä¸”é¡ºåºæ­£ç¡®ã€‚
        *   ç›‘æ§æµ‹è¯•è¿‡ç¨‹ä¸­çš„å†…å­˜ä½¿ç”¨ï¼Œç¡®ä¿å…¶ä¿æŒåœ¨è¾ƒä½ä¸”ç¨³å®šçš„æ°´å¹³ã€‚
        *   æµ‹è¯•ä¸åŒçš„ `StreamingOptions` (å¦‚ä¸åŒçš„å—å¤§å°)ã€‚
        *   æµ‹è¯•å½“ `chunkProcessor` è¿”å› `false` æ—¶ï¼Œæµæ˜¯å¦èƒ½æ­£ç¡®ä¸­æ­¢ã€‚
        *   æµ‹è¯•ç½‘ç»œæ–­å¼€ã€æ–‡ä»¶æŸåç­‰é”™è¯¯æƒ…å†µä¸‹çš„è¡Œä¸ºã€‚

5.  **ç³»ç»Ÿçº§é›†æˆä¸å›å½’æµ‹è¯•**:
    *   æ‰§è¡Œé¡¹ç›®ä¸­çš„æ‰€æœ‰ç°æœ‰å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•ï¼Œç¡®ä¿æ²¡æœ‰åŠŸèƒ½å›å½’ã€‚
    *   æ‰‹åŠ¨æµ‹è¯•æˆ–é€šè¿‡è‡ªåŠ¨åŒ–UI/APIæµ‹è¯•ï¼ˆå¦‚æœé€‚ç”¨ï¼‰æ¥éªŒè¯ç³»ç»Ÿçš„å…³é”®è·¯å¾„ã€‚

6.  **æœ€ç»ˆæ€§èƒ½å’Œå‹åŠ›æµ‹è¯•**:
    *   é‡æ–°è¿è¡Œ Phase 1 å»ºç«‹çš„æ€§èƒ½åŸºå‡†æµ‹è¯•ï¼Œå¹¶å¢åŠ é’ˆå¯¹æµå¼APIçš„æ€§èƒ½æµ‹è¯•ã€‚
    *   å¯¹æ¯”é‡æ„å‰åçš„å…³é”®æ€§èƒ½æŒ‡æ ‡ (ç¼“å­˜å‘½ä¸­ç‡ã€å†…å­˜åˆ©ç”¨ç‡ã€ç‰¹å®šæ“ä½œçš„å“åº”æ—¶é—´ã€å¤§æ•°æ®æ–‡ä»¶å¤„ç†æ—¶é—´)ã€‚
    *   è¿›è¡Œå‹åŠ›æµ‹è¯•ï¼Œæ¨¡æ‹Ÿé«˜å¹¶å‘è¯·æ±‚ï¼Œè§‚å¯Ÿç³»ç»Ÿçš„ç¨³å®šæ€§å’Œèµ„æºæ¶ˆè€—ã€‚

7.  **ä»£ç å®¡æŸ¥ä¸æ–‡æ¡£æ›´æ–°**:
    *   ç»„ç»‡å¯¹ Phase 1-6 ä¸­æ‰€æœ‰ä¸»è¦æ–°å¢å’Œä¿®æ”¹ä»£ç çš„å…¨é¢å®¡æŸ¥ã€‚
    *   æ›´æ–° `æ•°æ®å¤„ç†é‡æ„æ–¹æ¡ˆ.MD` ä»¥åæ˜ æœ€ç»ˆçš„å®ç°å†³ç­–å’Œé‡åˆ°çš„é—®é¢˜ã€‚
    *   æ›´æ–°æ¨¡å—çš„ READMEã€API æ–‡æ¡£ (Doxygen æ³¨é‡Š)ã€ç”¨æˆ·æŒ‡å—ç­‰ã€‚
    *   ç¼–å†™ä¸€ä»½æ€»ç»“æ€§çš„é‡æ„æŠ¥å‘Šï¼ŒåŒ…æ‹¬ç›®æ ‡è¾¾æˆæƒ…å†µã€é‡åˆ°çš„æŒ‘æˆ˜ã€å­¦åˆ°çš„ç»éªŒæ•™è®­ã€‚

**æ¶‰åŠæ–‡ä»¶ (Phase 6):**
*   **æ–°å¢/å®ç°**:
    *   `src/streaming/streaming_data_processor.h/cpp`
    *   `tests/data_access/streaming_tests.cpp`
*   **ä¿®æ”¹**:
    *   `src/readers/gdal/gdal_unified_reader.h/cpp` (å®ç° `IStreamingDataProvider`)
    *   `src/readers/netcdf/netcdf_unified_reader.h/cpp` (å®ç° `IStreamingDataProvider`)
    *   `include/core_services/data_access/i_data_access_service.h` (æ·»åŠ æµå¼API)
    *   `src/data_access_service_impl.h/cpp` (å®ç°æµå¼API, æ³¨å…¥ `StreamingDataProcessor`)
    *   CMakeLists.txt (æ·»åŠ æ–°æ–‡ä»¶)
    *   æ‰€æœ‰ç›¸å…³æµ‹è¯•æ–‡ä»¶ä»¥è¦†ç›–æ–°åŠŸèƒ½ã€‚
*   **åˆ é™¤**: æ— ç‰¹å®šæ–‡ä»¶åˆ é™¤ï¼Œä¸»è¦æ˜¯å®Œå–„å’Œé›†æˆã€‚

**é£é™©æ§åˆ¶ä¸éªŒè¯ (Phase 6):**
*   **æµå¼å®ç°çš„å¤æ‚æ€§**: æ­£ç¡®å®ç°é€å—è¯»å–ã€çŠ¶æ€ç®¡ç†ã€é”™è¯¯å¤„ç†å’Œèµ„æºé‡Šæ”¾å¯èƒ½å¾ˆå¤æ‚ï¼Œå°¤å…¶æ˜¯åœ¨æ¶‰åŠå›è°ƒå’Œå¼‚æ­¥æ“ä½œæ—¶ã€‚
*   **æ€§èƒ½å¼€é”€**: æµå¼å¤„ç†æœ¬èº«å¯èƒ½æœ‰ä¸€å®šçš„æ€§èƒ½å¼€é”€ï¼ˆå¦‚å¤šæ¬¡å°I/Oä»£æ›¿ä¸€æ¬¡å¤§I/Oï¼‰ã€‚éœ€è¦å¹³è¡¡å†…å­˜æ§åˆ¶å’Œååé‡ã€‚
*   **èƒŒå‹æœºåˆ¶**: å¦‚æœå®¢æˆ·ç«¯å¤„ç†æ•°æ®å—çš„é€Ÿåº¦è·Ÿä¸ä¸Šæ•°æ®å—ç”Ÿæˆçš„é€Ÿåº¦ï¼Œå¯èƒ½ä¼šå¯¼è‡´å†…å­˜ç§¯å‹ã€‚ä¸€ä¸ªå®Œæ•´çš„æµå¼ç³»ç»Ÿå¯èƒ½éœ€è¦èƒŒå‹æœºåˆ¶ (backpressure)ï¼Œè¿™ä¼šå¢åŠ å¤æ‚æ€§ (åˆæœŸå¯ç®€åŒ–ï¼Œä¸å®ç°å¤æ‚èƒŒå‹)ã€‚
*   **è¯»å–å™¨ç”Ÿå‘½å‘¨æœŸ**: åœ¨ `StreamingDataProcessor` ä¸­è·å–å’Œä½¿ç”¨è¯»å–å™¨æ—¶ï¼Œè¦æ³¨æ„å…¶ç”Ÿå‘½å‘¨æœŸç®¡ç†ï¼Œç‰¹åˆ«æ˜¯å½“è¯»å–å™¨å®ä¾‹è¢«ç¼“å­˜æ—¶ã€‚æµå¼æ“ä½œå¯èƒ½éœ€è¦ç‹¬å æˆ–ç‰¹æ®Šå¤„ç†è¯»å–å™¨å®ä¾‹ã€‚
*   **å…¨é¢æµ‹è¯•çš„éš¾åº¦**: æµ‹è¯•å¤§è§„æ¨¡æ•°æ®æµçš„å„ç§è¾¹ç•Œæ¡ä»¶å’Œé”™è¯¯æƒ…å†µå¯èƒ½å¾ˆæœ‰æŒ‘æˆ˜æ€§ã€‚

core_services_impl/data_access_service/
â”œâ”€â”€ include/core_services/data_access/  # å…¬å…±æ¥å£å’Œæ ¸å¿ƒç±»å‹ (å¯¹å¤–æš´éœ²)
â”‚   â”œâ”€â”€ i_data_access_service.h         # (ä¿æŒä¸å˜) æœåŠ¡ä¸»æ¥å£
â”‚   â”œâ”€â”€ common_types.h                  # (æ–°å¢/é‡æ„) æ¨¡å—ç‰¹å®šçš„å…¬å…±ç±»å‹å®šä¹‰ (å¦‚ DataChunkKey, FileMetadata, BoundingBox, TimeRange, DimensionDefinition ç­‰)
â”‚   â”œâ”€â”€ error_codes.h                   # (æ–°å¢) æ¨¡å—ç‰¹å®šçš„é”™è¯¯ç å®šä¹‰
â”‚   â””â”€â”€ api/                              # (æ–°å¢) æ–°çš„æ ¸å¿ƒæ¥å£å®šä¹‰
â”‚       â”œâ”€â”€ i_data_source.h
â”‚       â”œâ”€â”€ i_metadata_provider.h
â”‚       â”œâ”€â”€ i_data_provider.h
â”‚       â”œâ”€â”€ i_streaming_data_provider.h
â”‚       â”œâ”€â”€ data_access_requests.h      # (GridReadRequest, FeatureReadRequest, etc.)
â”‚       â”œâ”€â”€ data_access_responses.h     # (GridData, FeatureCollection, DataChunk etc.)
â”‚       â””â”€â”€ streaming_types.h           # (StreamingOptions, BackpressureControl etc.)
â”‚
â””â”€â”€ src/                                  # å®ç°ä»£ç  (å†…éƒ¨ç»†èŠ‚)
    â”œâ”€â”€ data_access_service_impl.h        # (é‡å‘½å/é‡æ„è‡ª raw_data_access_service_impl.h)
    â”œâ”€â”€ data_access_service_impl.cpp      # (é‡å‘½å/é‡æ„è‡ª raw_data_access_service_impl.cpp)
    â”œâ”€â”€ cache/                              # (æ–°å¢) ç»Ÿä¸€ç¼“å­˜å®ç°
    â”‚   â”œâ”€â”€ unified_data_access_cache.h
    â”‚   â”œâ”€â”€ unified_data_access_cache.cpp
    â”‚   â””â”€â”€ i_cacheable_value.h           # (æ–°å¢) å¯ç¼“å­˜å¯¹è±¡æ¥å£
    â”œâ”€â”€ async/                              # (æ–°å¢) ç»Ÿä¸€å¼‚æ­¥æ‰§è¡Œå™¨
    â”‚   â”œâ”€â”€ unified_async_executor.h
    â”‚   â””â”€â”€ unified_async_executor.cpp
    â”œâ”€â”€ time/                               # (æ–°å¢) æ—¶é—´å¤„ç†ç›¸å…³
    â”‚   â”œâ”€â”€ cf_time_extractor.h
    â”‚   â””â”€â”€ cf_time_extractor.cpp
    â”œâ”€â”€ readers/                            # (é‡æ„) è¯»å–å™¨ç›¸å…³å®ç°
    â”‚   â”œâ”€â”€ core/                           # (æ–°å¢) è¯»å–å™¨æ ¸å¿ƒç»„ä»¶
    â”‚   â”‚   â”œâ”€â”€ unified_data_reader.h     # æŠ½è±¡åŸºç±»
    â”‚   â”‚   â”œâ”€â”€ unified_data_reader.cpp
    â”‚   â”‚   â”œâ”€â”€ reader_registry.h
    â”‚   â”‚   â”œâ”€â”€ reader_registry.cpp
    â”‚   â”‚   â”œâ”€â”€ i_format_detector.h       # æ ¼å¼æ¢æµ‹å™¨æ¥å£
    â”‚   â”‚   â”œâ”€â”€ format_detector_impl.h    # å…·ä½“æ ¼å¼æ¢æµ‹å™¨å®ç°
    â”‚   â”‚   â””â”€â”€ format_detector_impl.cpp
    â”‚   â”œâ”€â”€ gdal/                           # (é‡æ„) GDAL è¯»å–å™¨å®ç°
    â”‚   â”‚   â”œâ”€â”€ gdal_unified_reader.h       # ç»§æ‰¿ UnifiedDataReader
    â”‚   â”‚   â”œâ”€â”€ gdal_unified_reader.cpp
    â”‚   â”‚   â””â”€â”€ internal/                   # GDALå†…éƒ¨è¾…åŠ©ç»„ä»¶ (ä¿æŒå°è£…, å†…å®¹é‡æ„)
    â”‚   â”‚       â”œâ”€â”€ gdal_dataset_handler.h/cpp
    â”‚   â”‚       â”œâ”€â”€ gdal_metadata_extractor.h/cpp (å„ç±»å…ƒæ•°æ®æå–å™¨)
    â”‚   â”‚       â”œâ”€â”€ gdal_raster_io.h/cpp
    â”‚   â”‚       â”œâ”€â”€ gdal_vector_io.h/cpp
    â”‚   â”‚       â””â”€â”€ utils/ (gdal_common_utils, gdal_type_conversion etc.)
    â”‚   â””â”€â”€ netcdf/                         # (é‡æ„) NetCDF è¯»å–å™¨å®ç°
    â”‚       â”œâ”€â”€ netcdf_unified_reader.h     # ç»§æ‰¿ UnifiedDataReader
    â”‚       â”œâ”€â”€ netcdf_unified_reader.cpp
    â”‚       â””â”€â”€ internal/                   # NetCDFå†…éƒ¨è¾…åŠ©ç»„ä»¶ (ä¿æŒå°è£…, å†…å®¹é‡æ„)
    â”‚           â”œâ”€â”€ netcdf_file_processor.h/cpp
    â”‚           â”œâ”€â”€ netcdf_metadata_manager.h/cpp
    â”‚           â”œâ”€â”€ io/ (netcdf_attribute_io, netcdf_variable_io etc.)
    â”‚           â””â”€â”€ parsing/ (netcdf_cf_conventions, netcdf_coordinate_system_parser (ç²¾ç®€å) etc.)
    â””â”€â”€ streaming/                          # (æ–°å¢) æµå¼å¤„ç†å®ç°
        â”œâ”€â”€ streaming_data_processor.h
        â””â”€â”€ streaming_data_processor.cpp

ä»¥ä¸‹æ˜¯åŸæ–‡ä»¶ç›®å½•æ¶æ„ä»¥åŠé‡æ„ä¸­çš„å»å‘æ–¹æ¡ˆã€‚
        core_services_impl/data_access_service/
â”œâ”€â”€ include/core_services/data_access/  # å¯¹å¤–å…¬å…±å¤´æ–‡ä»¶ç›®å½•
â”‚   â”œâ”€â”€ i_data_access_service.h         # ğŸ”’ ä¿ç•™ (é€‚é…): æ¥å£æœ¬èº«ä¸å˜ï¼Œä½†å…¶å®ç°ç±»ä¼šè¢«å½»åº•é‡æ„ã€‚æ–°å¢æµå¼APIã€‚
â”‚   â”‚                                   #    æ–°ä½ç½®: include/core_services/data_access/i_data_access_service.h
â”‚   â”œâ”€â”€ boost_future_config.h           # â¡ï¸ åˆ é™¤ (Phase 3): è¢«ç»Ÿä¸€çš„å¼‚æ­¥æ‰§è¡Œå™¨ UnifiedAsyncExecutor å–ä»£ï¼Œä¸å†éœ€è¦ç‰¹å®šé…ç½®ã€‚
â”‚   â”œâ”€â”€ readers/                        # (æ—§çš„è¯»å–å™¨ç›¸å…³å…¬å…±å¤´æ–‡ä»¶å­ç›®å½•)
â”‚   â”‚   â””â”€â”€ data_reader_common.h        # â¡ï¸ åˆ é™¤ (Phase 2/5): å…¶å†…å®¹ï¼ˆå¦‚é€šç”¨æšä¸¾ã€ç®€å•ç»“æ„ä½“ï¼‰å¯èƒ½éƒ¨åˆ†è¿ç§»è‡³æ–°çš„ `common_types.h` æˆ–è¢«æ–°APIç»“æ„å–ä»£ã€‚
â”‚   â””â”€â”€ i_data_reader_impl.h            # â¡ï¸ åˆ é™¤ (Phase 5): è¢«æ–°çš„APIæ¥å£ (`IDataSource`, `IMetadataProvider`, `IDataProvider`, `IStreamingDataProvider`) å’Œ `UnifiedDataReader` åŸºç±»å½»åº•å–ä»£ã€‚
â”‚   â””â”€â”€ (å…¶ä»–å¯èƒ½çš„æ—§å…¬å…±å¤´æ–‡ä»¶)          # ğŸ”— è¿ç§»/åˆå¹¶é€»è¾‘è‡³: æ ¹æ®å…·ä½“å†…å®¹ï¼Œæˆ–è¢«åˆ é™¤ï¼Œæˆ–å…¶å®šä¹‰è¿ç§»åˆ° `common_types.h`, `error_codes.h` æˆ–æ–°çš„APIæ¥å£æ–‡ä»¶ä¸­ã€‚
â”‚
â””â”€â”€ src/                                  # æºä»£ç å®ç°ç›®å½•
    â”œâ”€â”€ impl/                             # (é€šå¸¸åŒ…å«å¤§é‡çš„æ—§å®ç°ç»†èŠ‚)
    â”‚   â”œâ”€â”€ raw_data_access_service_impl.h  # ğŸ”„ é‡å‘½åä¸é‡æ„è‡³: src/data_access_service_impl.h (Phase 2-6) - ä½œä¸ºæœåŠ¡ä¸»å®ç°ç±»ï¼Œä½†å†…éƒ¨é€»è¾‘å®Œå…¨é‡å†™ã€‚
    â”‚   â”œâ”€â”€ raw_data_access_service_impl.cpp# ğŸ”„ é‡å‘½åä¸é‡æ„è‡³: src/data_access_service_impl.cpp (Phase 2-6) - åŒä¸Šã€‚
    â”‚   â”‚
    â”‚   â”œâ”€â”€ cache/                          # â¡ï¸ åˆ é™¤ (æ•´ä¸ªç›®å½•åŠå…¶ä¸‹æ‰€æœ‰æ–‡ä»¶åœ¨ Phase 2 è¢«ç§»é™¤)
    â”‚   â”‚   â”œâ”€â”€ data_chunk_cache.h          # â¡ï¸ åˆ é™¤: è¢« src/cache/unified_data_access_cache.h/cpp å–ä»£ã€‚
    â”‚   â”‚   â”œâ”€â”€ data_chunk_cache.cpp        # â¡ï¸ åˆ é™¤: åŒä¸Šã€‚
    â”‚   â”‚   â”œâ”€â”€ reader_cache.h              # â¡ï¸ åˆ é™¤: è¢« src/cache/unified_data_access_cache.h/cpp (ç”¨äºç¼“å­˜è¯»å–å™¨å®ä¾‹) å–ä»£ã€‚
    â”‚   â”‚   â”œâ”€â”€ reader_cache.cpp            # â¡ï¸ åˆ é™¤: åŒä¸Šã€‚
    â”‚   â”‚   â”œâ”€â”€ metadata_cache.h            # â¡ï¸ åˆ é™¤: è¢« src/cache/unified_data_access_cache.h/cpp (ç”¨äºç¼“å­˜å…ƒæ•°æ®) å–ä»£ã€‚
    â”‚   â”‚   â”œâ”€â”€ metadata_cache.cpp          # â¡ï¸ åˆ é™¤: åŒä¸Šã€‚
    â”‚   â”‚   â”œâ”€â”€ netcdf_cache_manager.h      # â¡ï¸ åˆ é™¤: NetCDFç‰¹å®šç¼“å­˜é€»è¾‘ç»Ÿä¸€åˆ°æ–°ç¼“å­˜æ¡†æ¶ä¸­ã€‚
    â”‚   â”‚   â”œâ”€â”€ netcdf_cache_manager.cpp    # â¡ï¸ åˆ é™¤: åŒä¸Šã€‚
    â”‚   â”‚   â””â”€â”€ cache_manager_template.h    # â¡ï¸ åˆ é™¤: é€šç”¨ç¼“å­˜æ¨¡æ¿è¢« `common_utils::cache` å’Œ `UnifiedDataAccessCache` å–ä»£ã€‚
    â”‚   â”‚
    â”‚   â”œâ”€â”€ factory/                        # â¡ï¸ åˆ é™¤ (æ•´ä¸ªç›®å½•åŠå…¶ä¸‹æ‰€æœ‰æ–‡ä»¶åœ¨ Phase 5 è¢«ç§»é™¤)
    â”‚   â”‚   â”œâ”€â”€ reader_factory.h            # â¡ï¸ åˆ é™¤: è¢« src/readers/core/reader_registry.h/cpp å’Œ src/readers/core/format_detector_impl.h/cpp å–ä»£ã€‚
    â”‚   â”‚   â””â”€â”€ reader_factory.cpp          # â¡ï¸ åˆ é™¤: åŒä¸Šã€‚
    â”‚   â”‚
    â”‚   â”œâ”€â”€ readers/                        # (æ—§çš„å…·ä½“è¯»å–å™¨å®ç°å­ç›®å½•)
    â”‚   â”‚   â”œâ”€â”€ gdal/                       # (GDAL ç›¸å…³æ—§å®ç°)
    â”‚   â”‚   â”‚   â”œâ”€â”€ gdal_raster_reader.h    # ğŸ”— è¿ç§»/åˆå¹¶é€»è¾‘è‡³: src/readers/gdal/gdal_unified_reader.h/cpp (Phase 5). é€»è¾‘è¢«é‡æ„ä»¥é€‚é…æ–°æ¥å£ã€‚
    â”‚   â”‚   â”‚   â”œâ”€â”€ gdal_raster_reader.cpp  # ğŸ”— è¿ç§»/åˆå¹¶é€»è¾‘è‡³: src/readers/gdal/gdal_unified_reader.h/cpp (Phase 5).
    â”‚   â”‚   â”‚   â”œâ”€â”€ gdal_vector_reader.h    # ğŸ”— è¿ç§»/åˆå¹¶é€»è¾‘è‡³: src/readers/gdal/gdal_unified_reader.h/cpp (Phase 5). (å¯èƒ½ä¸RasterReaderåˆå¹¶æˆ–å…±äº«å†…éƒ¨ç»„ä»¶).
    â”‚   â”‚   â”‚   â”œâ”€â”€ gdal_vector_reader.cpp  # ğŸ”— è¿ç§»/åˆå¹¶é€»è¾‘è‡³: src/readers/gdal/gdal_unified_reader.h/cpp (Phase 5).
    â”‚   â”‚   â”‚   â”œâ”€â”€ io/                     # (æ—§çš„GDAL IOè¾…åŠ©ç»„ä»¶)
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ (e.g., gdal_raster_io_utils.h/cpp) # ğŸ”— è¿ç§»/åˆå¹¶é€»è¾‘è‡³: src/readers/gdal/internal/gdal_raster_io.h/cpp æˆ–ç›´æ¥æ•´åˆè¿› gdal_unified_reader.cpp.
    â”‚   â”‚   â”‚   â”œâ”€â”€ metadata/               # (æ—§çš„GDALå…ƒæ•°æ®æå–è¾…åŠ©ç»„ä»¶)
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ (e.g., gdal_attribute_reader.h/cpp) # ğŸ”— è¿ç§»/åˆå¹¶é€»è¾‘è‡³: src/readers/gdal/internal/gdal_metadata_extractor.h/cpp æˆ–ç›´æ¥æ•´åˆè¿› gdal_unified_reader.cpp.
    â”‚   â”‚   â”‚   â””â”€â”€ utils/                  # (æ—§çš„GDALé€šç”¨è¾…åŠ©å·¥å…·)
    â”‚   â”‚   â”‚       â””â”€â”€ (e.g., gdal_type_converter.h/cpp) # ğŸ”— è¿ç§»/åˆå¹¶é€»è¾‘è‡³: src/readers/gdal/internal/utils/ (å¦‚ gdal_common_utils.h/cpp) æˆ–è¢« `common_utils` æ›¿ä»£.
    â”‚   â”‚   â”‚
    â”‚   â”‚   â”œâ”€â”€ netcdf/                     # (NetCDF ç›¸å…³æ—§å®ç°)
    â”‚   â”‚   â”‚   â”œâ”€â”€ netcdf_cf_reader.h      # ğŸ”— è¿ç§»/åˆå¹¶é€»è¾‘è‡³: src/readers/netcdf/netcdf_unified_reader.h/cpp (Phase 5). é€»è¾‘è¢«é‡æ„ä»¥é€‚é…æ–°æ¥å£å’Œæ–°çš„æ—¶é—´å¤„ç†.
    â”‚   â”‚   â”‚   â”œâ”€â”€ netcdf_cf_reader.cpp    # ğŸ”— è¿ç§»/åˆå¹¶é€»è¾‘è‡³: src/readers/netcdf/netcdf_unified_reader.h/cpp (Phase 5).
    â”‚   â”‚   â”‚   â”œâ”€â”€ io/                     # (æ—§çš„NetCDF IOè¾…åŠ©ç»„ä»¶)
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ (e.g., netcdf_variable_reader.h/cpp) # ğŸ”— è¿ç§»/åˆå¹¶é€»è¾‘è‡³: src/readers/netcdf/internal/io/ (å¦‚ netcdf_variable_io.h/cpp) æˆ–ç›´æ¥æ•´åˆè¿› netcdf_unified_reader.cpp.
    â”‚   â”‚   â”‚   â”œâ”€â”€ parsing/                # (æ—§çš„NetCDFè§£æè¾…åŠ©ç»„ä»¶)
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ netcdf_time_processor.h # â¡ï¸ åˆ é™¤ (Phase 4): è¢« src/time/cf_time_extractor.h/cpp å–ä»£.
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ netcdf_time_processor.cpp # â¡ï¸ åˆ é™¤ (Phase 4): åŒä¸Š.
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ netcdf_coordinate_system_parser.h # ğŸ”„ é‡æ„å¹¶è¿ç§»é€»è¾‘è‡³: src/readers/netcdf/internal/parsing/netcdf_coordinate_system_parser.h/cpp (Phase 4). ç§»é™¤æ—¶é—´å¤„ç†éƒ¨åˆ†ï¼Œä¸“æ³¨ç©ºé—´åæ ‡å’Œç»´åº¦è§£æ.
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ netcdf_coordinate_system_parser.cpp # ğŸ”„ é‡æ„å¹¶è¿ç§»é€»è¾‘è‡³: src/readers/netcdf/internal/parsing/netcdf_coordinate_system_parser.h/cpp (Phase 4).
    â”‚   â”‚   â”‚   â””â”€â”€ utils/                  # (æ—§çš„NetCDFé€šç”¨è¾…åŠ©å·¥å…·)
    â”‚   â”‚   â”‚       â””â”€â”€ (e.g., netcdf_attribute_utils.h/cpp) # ğŸ”— è¿ç§»/åˆå¹¶é€»è¾‘è‡³: src/readers/netcdf/internal/ (å¦‚ netcdf_metadata_manager.h/cpp) æˆ–è¢« `common_utils` æ›¿ä»£.
    â”‚   â”‚   â”‚
    â”‚   â”‚   â””â”€â”€ (å…¶ä»–å¯èƒ½çš„æ—§è¯»å–å™¨ç±»å‹å¦‚ HDF, GRIB, etc.) # ğŸ”— è¿ç§»/åˆå¹¶é€»è¾‘è‡³: å¦‚æœæ”¯æŒè¿™äº›æ ¼å¼ï¼Œä¼šåˆ›å»ºæ–°çš„å¯¹åº”çš„ UnifiedReader å®ç° (e.g., src/readers/hdf/hdf_unified_reader.h/cpp)ï¼Œå¹¶éµå¾ªç›¸åŒçš„é‡æ„æ¨¡å¼ã€‚
    â”‚   â”‚
    â”‚   â””â”€â”€ utils/                          # (æ—§çš„æœåŠ¡å±‚çº§é€šç”¨å·¥å…·)
    â”‚       â””â”€â”€ (e.g., data_access_string_utils.h/cpp) # ğŸ”— è¿ç§»/åˆå¹¶é€»è¾‘è‡³: éƒ¨åˆ†å¯èƒ½è¢« `common_utils/string` ç­‰å–ä»£ï¼Œéƒ¨åˆ†ç‰¹å®šé€»è¾‘å¯èƒ½å†…è”åˆ°ä½¿ç”¨å¤„ï¼Œæˆ–å¦‚æœä»å¿…è¦åˆ™æ”¾å…¥æ–°çš„æ›´å…·ä½“çš„ `utils` ç›®å½•ï¼ˆå¦‚è¯»å–å™¨å†…éƒ¨çš„ `utils`ï¼‰ã€‚å¤§éƒ¨åˆ†å¯èƒ½ä¼šè¢«åˆ é™¤ã€‚
    â”‚
    â””â”€â”€ (å…¶ä»–å¯èƒ½çš„é¡¶å±‚srcæ–‡ä»¶)             # é€šå¸¸åœ¨è‰¯å¥½ç»„ç»‡çš„æ¨¡å—ä¸­è¾ƒå°‘ï¼Œä½†å¦‚æœå­˜åœ¨ï¼Œä¼šæ ¹æ®å…¶åŠŸèƒ½è¿›è¡Œç±»ä¼¼çš„åˆ é™¤/é‡æ„/è¿ç§»åˆ†æã€‚

    core_services_impl/data_access_service/
â”œâ”€â”€ include/core_services/data_access/  # âœ¨ å…¬å…±æ¥å£å’Œæ ¸å¿ƒç±»å‹ (æ¸…æ™°åŒ–ã€æ ‡å‡†åŒ–)
â”‚   â”œâ”€â”€ i_data_access_service.h         # (åŸºæœ¬ä¿ç•™ï¼Œæ–°å¢æµå¼API)
â”‚   â”œâ”€â”€ common_types.h                  # âœ¨ æ–°å¢/é‡æ„: ç»Ÿä¸€å­˜æ”¾æ¨¡å—çº§æ•°æ®ç»“æ„
â”‚   â”œâ”€â”€ error_codes.h                   # âœ¨ æ–°å¢: ç»Ÿä¸€å­˜æ”¾é”™è¯¯ç 
â”‚   â””â”€â”€ api/                              # âœ¨ æ–°å¢: æ ¸å¿ƒæ–°æ¥å£å®šä¹‰
â”‚       â”œâ”€â”€ i_data_source.h
â”‚       â”œâ”€â”€ i_metadata_provider.h
â”‚       â”œâ”€â”€ i_data_provider.h
â”‚       â”œâ”€â”€ i_streaming_data_provider.h
â”‚       â”œâ”€â”€ data_access_requests.h
â”‚       â”œâ”€â”€ data_access_responses.h
â”‚       â””â”€â”€ streaming_types.h
â”‚
â””â”€â”€ src/                                  # âœ¨ å®ç°ä»£ç  (ç»“æ„æ›´æ¸…æ™°)
    â”œâ”€â”€ data_access_service_impl.h        # ğŸ”„ é‡æ„: (åŸ raw_data_access_service_impl.h)
    â”œâ”€â”€ data_access_service_impl.cpp      # ğŸ”„ é‡æ„: (åŸ raw_data_access_service_impl.cpp)
    â”œâ”€â”€ cache/                              # âœ¨ æ–°å¢: ç»Ÿä¸€ç¼“å­˜å®ç°
    â”‚   â”œâ”€â”€ unified_data_access_cache.h/cpp
    â”‚   â””â”€â”€ i_cacheable_value.h
    â”œâ”€â”€ async/                              # âœ¨ æ–°å¢: ç»Ÿä¸€å¼‚æ­¥æ‰§è¡Œå™¨
    â”‚   â”œâ”€â”€ unified_async_executor.h/cpp
    â”œâ”€â”€ time/                               # âœ¨ æ–°å¢: æ—¶é—´å¤„ç†ç›¸å…³
    â”‚   â”œâ”€â”€ cf_time_extractor.h/cpp
    â”œâ”€â”€ readers/                            # âœ¨ é‡æ„: è¯»å–å™¨ç›¸å…³å®ç° (ç»Ÿä¸€æ¶æ„)
    â”‚   â”œâ”€â”€ core/                           # âœ¨ æ–°å¢: è¯»å–å™¨æ ¸å¿ƒç»„ä»¶ (æ³¨å†Œè¡¨ã€æ¢æµ‹å™¨ã€åŸºç±»)
    â”‚   â”‚   â”œâ”€â”€ unified_data_reader.h/cpp
    â”‚   â”‚   â”œâ”€â”€ reader_registry.h/cpp
    â”‚   â”‚   â”œâ”€â”€ i_format_detector.h
    â”‚   â”‚   â””â”€â”€ format_detector_impl.h/cpp
    â”‚   â”œâ”€â”€ gdal/                           # âœ¨ é‡æ„: GDAL è¯»å–å™¨ (åŸºäºæ–°æ¶æ„)
    â”‚   â”‚   â”œâ”€â”€ gdal_unified_reader.h/cpp
    â”‚   â”‚   â””â”€â”€ internal/                   # (GDALå†…éƒ¨è¾…åŠ©ä»¶ï¼Œå†…å®¹é‡æ„)
    â”‚   â””â”€â”€ netcdf/                         # âœ¨ é‡æ„: NetCDF è¯»å–å™¨ (åŸºäºæ–°æ¶æ„)
    â”‚       â”œâ”€â”€ netcdf_unified_reader.h/cpp
    â”‚       â””â”€â”€ internal/                   # (NetCDFå†…éƒ¨è¾…åŠ©ä»¶ï¼Œå†…å®¹é‡æ„)
    â””â”€â”€ streaming/                          # âœ¨ æ–°å¢: æµå¼å¤„ç†å®ç°
        â”œâ”€â”€ streaming_data_processor.h/cpp

        core_services_impl/data_access_service/
â”œâ”€â”€ cmake/                              # (å¯èƒ½çš„CMakeç›¸å…³é…ç½®)
â”‚   â””â”€â”€ (e.g., data_access_config.cmake)  # ğŸ”— è¿ç§»/åˆå¹¶é€»è¾‘è‡³: é¡¶å±‚æˆ–æ¨¡å—çš„CMakeLists.txtä¼šæ›´æ–°ä»¥åæ˜ æ–°çš„æ–‡ä»¶ç»“æ„å’Œä¾èµ–ã€‚æ—§çš„ç‰¹å®šé…ç½®æ–‡ä»¶å¯èƒ½ä¸å†éœ€è¦æˆ–è¢«æ•´åˆã€‚
â”‚
â”œâ”€â”€ include/core_services/data_access/  # å¯¹å¤–å…¬å…±å¤´æ–‡ä»¶ç›®å½•
â”‚   â”œâ”€â”€ i_data_access_service.h         # ğŸ”’ ä¿ç•™ (é€‚é…): æ¥å£æœ¬èº«ä¸å˜ï¼Œä½†å…¶å®ç°ç±»ä¼šè¢«å½»åº•é‡æ„ã€‚æ–°å¢æµå¼APIã€‚
â”‚   â”‚                                   #    æ–°ä½ç½®: include/core_services/data_access/i_data_access_service.h
â”‚   â”œâ”€â”€ boost_future_config.h           # â¡ï¸ åˆ é™¤ (Phase 3): è¢«ç»Ÿä¸€çš„å¼‚æ­¥æ‰§è¡Œå™¨ UnifiedAsyncExecutor å–ä»£ã€‚
â”‚   â”œâ”€â”€ readers/                        # (æ—§çš„è¯»å–å™¨ç›¸å…³å…¬å…±å¤´æ–‡ä»¶å­ç›®å½•)
â”‚   â”‚   â””â”€â”€ data_reader_common.h        # â¡ï¸ åˆ é™¤ (Phase 2/5): å…¶å†…å®¹ï¼ˆå¦‚é€šç”¨æšä¸¾ã€ç®€å•ç»“æ„ä½“ï¼‰å¯èƒ½éƒ¨åˆ†è¿ç§»è‡³æ–°çš„ `common_types.h` æˆ–è¢«æ–°APIç»“æ„å–ä»£ã€‚
â”‚   â””â”€â”€ i_data_reader_impl.h            # â¡ï¸ åˆ é™¤ (Phase 5): è¢«æ–°çš„APIæ¥å£ (`IDataSource`, `IMetadataProvider`, `IDataProvider`, `IStreamingDataProvider`) å’Œ `UnifiedDataReader` åŸºç±»å½»åº•å–ä»£ã€‚
â”‚   â””â”€â”€ (å…¶ä»–å¯èƒ½çš„æ—§å…¬å…±å¤´æ–‡ä»¶, e.g., specific_request_types.h, error_enums.h)
â”‚                                       # ğŸ”— è¿ç§»/åˆå¹¶é€»è¾‘è‡³: ç›¸å…³çš„å®šä¹‰ä¼šè¿ç§»åˆ°æ–°çš„ `api/data_access_requests.h`, `api/data_access_responses.h`, `common_types.h`, `error_codes.h`ã€‚
â”‚
â”œâ”€â”€ src/                                  # æºä»£ç å®ç°ç›®å½•
â”‚   â”œâ”€â”€ impl/                             # (é€šå¸¸åŒ…å«å¤§é‡çš„æ—§å®ç°ç»†èŠ‚)
â”‚   â”‚   â”œâ”€â”€ raw_data_access_service_impl.h  # ğŸ”„ é‡å‘½åä¸é‡æ„è‡³: src/data_access_service_impl.h (Phase 2-6) - ä½œä¸ºæœåŠ¡ä¸»å®ç°ç±»ï¼Œä½†å†…éƒ¨é€»è¾‘å®Œå…¨é‡å†™ã€‚
â”‚   â”‚   â”œâ”€â”€ raw_data_access_service_impl.cpp# ğŸ”„ é‡å‘½åä¸é‡æ„è‡³: src/data_access_service_impl.cpp (Phase 2-6) - åŒä¸Šã€‚
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ cache/                          # â¡ï¸ åˆ é™¤ (æ•´ä¸ªç›®å½•åŠå…¶ä¸‹æ‰€æœ‰æ–‡ä»¶åœ¨ Phase 2 è¢«ç§»é™¤)
â”‚   â”‚   â”‚   â”œâ”€â”€ data_chunk_cache.h/cpp      # â¡ï¸ åˆ é™¤: è¢« src/cache/unified_data_access_cache.h/cpp å–ä»£ã€‚
â”‚   â”‚   â”‚   â”œâ”€â”€ reader_cache.h/cpp          # â¡ï¸ åˆ é™¤: è¢« src/cache/unified_data_access_cache.h/cpp (ç”¨äºç¼“å­˜è¯»å–å™¨å®ä¾‹) å–ä»£ã€‚
â”‚   â”‚   â”‚   â”œâ”€â”€ metadata_cache.h/cpp        # â¡ï¸ åˆ é™¤: è¢« src/cache/unified_data_access_cache.h/cpp (ç”¨äºç¼“å­˜å…ƒæ•°æ®) å–ä»£ã€‚
â”‚   â”‚   â”‚   â”œâ”€â”€ netcdf_cache_manager.h/cpp  # â¡ï¸ åˆ é™¤: NetCDFç‰¹å®šç¼“å­˜é€»è¾‘ç»Ÿä¸€åˆ°æ–°ç¼“å­˜æ¡†æ¶ä¸­ã€‚
â”‚   â”‚   â”‚   â””â”€â”€ cache_manager_template.h    # â¡ï¸ åˆ é™¤: é€šç”¨ç¼“å­˜æ¨¡æ¿è¢« `common_utils::cache` å’Œ `UnifiedDataAccessCache` å–ä»£ã€‚
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ factory/                        # â¡ï¸ åˆ é™¤ (æ•´ä¸ªç›®å½•åŠå…¶ä¸‹æ‰€æœ‰æ–‡ä»¶åœ¨ Phase 5 è¢«ç§»é™¤)
â”‚   â”‚   â”‚   â”œâ”€â”€ reader_factory.h/cpp        # â¡ï¸ åˆ é™¤: è¢« src/readers/core/reader_registry.h/cpp å’Œ src/readers/core/format_detector_impl.h/cpp å–ä»£ã€‚
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ crs_service/                    # (å¦‚æœ data_access å†…éƒ¨æœ‰å¯¹CRSçš„ç‰¹å®šé€‚é…å±‚æˆ–æ—§å®ç°)
â”‚   â”‚   â”‚   â””â”€â”€ (e.g., gdal_crs_service_impl.h/cpp) # â¡ï¸ åˆ é™¤/ğŸ”— è¿ç§»é€»è¾‘è‡³: å¦‚æœæ˜¯é‡å¤CRSé€»è¾‘ï¼Œåˆ é™¤ã€‚å¦‚æœæ˜¯å¿…è¦çš„é€‚é…ï¼Œå…¶é€»è¾‘å¯èƒ½èå…¥ `GdalUnifiedReader` æˆ–é€šè¿‡ä¾èµ–æ³¨å…¥çš„ `ICrsService` å®ç°ã€‚Phase 1-5å¼ºè°ƒäº†ä¸å¤–éƒ¨ `crs_service` çš„ä¾èµ–æ³¨å…¥å’Œåè°ƒã€‚
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ readers/                        # (æ—§çš„å…·ä½“è¯»å–å™¨å®ç°å­ç›®å½•)
â”‚   â”‚   â”‚   â”œâ”€â”€ gdal/                       # (GDAL ç›¸å…³æ—§å®ç°)
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ gdal_raster_reader.h/cpp    # ğŸ”— è¿ç§»/åˆå¹¶é€»è¾‘è‡³: src/readers/gdal/gdal_unified_reader.h/cpp (Phase 5).
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ gdal_vector_reader.h/cpp    # ğŸ”— è¿ç§»/åˆå¹¶é€»è¾‘è‡³: src/readers/gdal/gdal_unified_reader.h/cpp (Phase 5).
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ io/                     # ğŸ”— è¿ç§»/åˆå¹¶é€»è¾‘è‡³: src/readers/gdal/internal/ (å¦‚ gdal_raster_io.h/cpp, gdal_vector_io.h/cpp).
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ (e.g., gdal_raster_io_utils.h/cpp)
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ metadata/               # ğŸ”— è¿ç§»/åˆå¹¶é€»è¾‘è‡³: src/readers/gdal/internal/ (å¦‚ gdal_metadata_extractor.h/cpp).
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ (e.g., gdal_attribute_reader.h/cpp)
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ utils/                  # ğŸ”— è¿ç§»/åˆå¹¶é€»è¾‘è‡³: src/readers/gdal/internal/utils/ (å¦‚ gdal_common_utils.h/cpp) æˆ–è¢« `common_utils` æ›¿ä»£.
â”‚   â”‚   â”‚   â”‚       â””â”€â”€ (e.g., gdal_type_converter.h/cpp, gdal_error_handler.h/cpp)
â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”œâ”€â”€ netcdf/                     # (NetCDF ç›¸å…³æ—§å®ç°)
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ netcdf_cf_reader.h/cpp      # ğŸ”— è¿ç§»/åˆå¹¶é€»è¾‘è‡³: src/readers/netcdf/netcdf_unified_reader.h/cpp (Phase 5).
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ io/                     # ğŸ”— è¿ç§»/åˆå¹¶é€»è¾‘è‡³: src/readers/netcdf/internal/io/ (å¦‚ netcdf_variable_io.h/cpp).
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ (e.g., netcdf_variable_reader.h/cpp)
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ parsing/                # (æ—§çš„NetCDFè§£æè¾…åŠ©ç»„ä»¶)
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ netcdf_time_processor.h/cpp # â¡ï¸ åˆ é™¤ (Phase 4): è¢« src/time/cf_time_extractor.h/cpp å–ä»£.
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ netcdf_coordinate_system_parser.h/cpp # ğŸ”„ é‡æ„å¹¶è¿ç§»é€»è¾‘è‡³: src/readers/netcdf/internal/parsing/netcdf_coordinate_system_parser.h/cpp (Phase 4). ç§»é™¤æ—¶é—´å¤„ç†éƒ¨åˆ†.
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ (e.g., netcdf_attribute_parser.h/cpp) # ğŸ”— è¿ç§»/åˆå¹¶é€»è¾‘è‡³: src/readers/netcdf/internal/netcdf_metadata_manager.h/cpp æˆ– parsing/.
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ utils/                  # ğŸ”— è¿ç§»/åˆå¹¶é€»è¾‘è‡³: src/readers/netcdf/internal/ (æˆ–å…¶ä¸‹çš„ utils/) æˆ–è¢« `common_utils` æ›¿ä»£.
â”‚   â”‚   â”‚   â”‚       â””â”€â”€ (e.g., netcdf_attribute_utils.h/cpp)
â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â””â”€â”€ (å…¶ä»–å¯èƒ½çš„æ—§è¯»å–å™¨ç±»å‹å¦‚ HDF, GRIB, etc.) # ğŸ”— è¿ç§»/åˆå¹¶é€»è¾‘è‡³: å¦‚æœæ”¯æŒè¿™äº›æ ¼å¼ï¼Œä¼šåˆ›å»ºæ–°çš„å¯¹åº”çš„ UnifiedReader å®ç° (e.g., src/readers/hdf/hdf_unified_reader.h/cpp)ï¼Œå¹¶éµå¾ªç›¸åŒçš„é‡æ„æ¨¡å¼ã€‚
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ utils/                          # (æ—§çš„æœåŠ¡å±‚çº§é€šç”¨å·¥å…·)
â”‚   â”‚       â””â”€â”€ (e.g., data_access_string_utils.h/cpp, data_conversion_helpers.h/cpp) # ğŸ”— è¿ç§»/åˆå¹¶é€»è¾‘è‡³: éƒ¨åˆ†è¢« `common_utils` å–ä»£ï¼Œç‰¹å®šé€»è¾‘å†…è”æˆ–ç§»è‡³æ›´å…·ä½“çš„ `utils` (å¦‚è¯»å–å™¨å†…éƒ¨)ï¼Œå¤§éƒ¨åˆ†å¯èƒ½è¢«åˆ é™¤ã€‚
â”‚   â”‚
â”‚   â””â”€â”€ (å…¶ä»–å¯èƒ½çš„é¡¶å±‚srcæ–‡ä»¶æˆ–å­ç›®å½•ï¼Œå¦‚ `common/`, `helpers/` ç­‰)
â”‚                                           # ğŸ”— è¿ç§»/åˆå¹¶é€»è¾‘è‡³: æ ¹æ®å…·ä½“åŠŸèƒ½ï¼Œå¤§éƒ¨åˆ†ä¼šè¢«æ•´åˆåˆ°æ–°çš„ç»“æ„åŒ–å­ç›®å½• (`cache`, `async`, `time`, `readers`, `streaming`) ä¸­ï¼Œæˆ–è¢« `common_utils` æ›¿ä»£ï¼Œæˆ–å› å†—ä½™è€Œè¢«åˆ é™¤ã€‚
â”‚
â”œâ”€â”€ testdata/                             # æµ‹è¯•æ•°æ®ç›®å½•
â”‚   â”œâ”€â”€ GRAY_LR_SR_W/                     # ğŸ”’ ä¿ç•™ (æµ‹è¯•æ•°æ®ï¼Œæ ¹æ®æ–°æµ‹è¯•éœ€æ±‚å¯èƒ½è°ƒæ•´æˆ–å¢åˆ )
â”‚   â”‚   â””â”€â”€ ... (files)
â”‚   â”œâ”€â”€ ne_10m_admin_0_countries/         # ğŸ”’ ä¿ç•™ (æµ‹è¯•æ•°æ®ï¼Œæ ¹æ®æ–°æµ‹è¯•éœ€æ±‚å¯èƒ½è°ƒæ•´æˆ–å¢åˆ )
â”‚   â”‚   â””â”€â”€ ... (files)
â”‚   â””â”€â”€ (å…¶ä»–æµ‹è¯•æ•°æ®é›†)                    # ğŸ”’ ä¿ç•™ (æµ‹è¯•æ•°æ®)
â”‚
â””â”€â”€ tests/                                # æµ‹è¯•ä»£ç ç›®å½•
    â”œâ”€â”€ core_services/                    # (å¯èƒ½çš„å­ç›®å½•ç»“æ„)
    â”‚   â””â”€â”€ (e.g., data_access_tests.cpp, gdal_reader_tests.cpp, netcdf_reader_tests.cpp)
    â”‚                                     # ğŸ—‘ï¸ åºŸå¼ƒ/é‡å†™: å¤§éƒ¨åˆ†æ—§çš„å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•éœ€è¦é‡å†™ï¼Œä»¥é€‚åº”æ–°çš„APIã€ç±»å’Œä¾èµ–æ³¨å…¥æœºåˆ¶ã€‚
    â”‚                                     #    æ–°çš„æµ‹è¯•å°†éµå¾ªAAAæ¨¡å¼ï¼Œé’ˆå¯¹ `UnifiedDataAccessCache`, `UnifiedAsyncExecutor`, `CFTimeExtractor`,
    â”‚                                     #    å„ä¸ª `UnifiedDataReader` å®ç°, `ReaderRegistry`, `StreamingDataProcessor` ä»¥åŠ
    â”‚                                     #    `DataAccessServiceImpl` çš„æ–°é€»è¾‘ç¼–å†™ã€‚
    â”‚                                     #    æ–°æµ‹è¯•æ–‡ä»¶ä¼šåˆ›å»ºåœ¨ç±»ä¼¼ `tests/data_access/cache/`, `tests/data_access/async/`,
    â”‚                                     #    `tests/data_access/readers/`, `tests/data_access/streaming/` ç­‰æ–°ç»“æ„ä¸‹ã€‚
    â”œâ”€â”€ mocks/                              # (å¯èƒ½çš„æµ‹è¯•Mocks)
    â”‚   â””â”€â”€ (e.g., mock_gdal_bindings.h, mock_cache_user.h)
    â”‚                                     # ğŸ—‘ï¸ åºŸå¼ƒ/é‡å†™: æ—§çš„mockså¯èƒ½ä¸å†é€‚ç”¨ã€‚æ–°çš„æµ‹è¯•ä¼šä½¿ç”¨å¦‚GMockç­‰å·¥å…·åˆ›å»ºé’ˆå¯¹æ–°æ¥å£çš„mocks
    â”‚                                     #    (e.g., MockUnifiedCache, MockDataReader, MockCrsService, MockMetadataProvider).
    â””â”€â”€ (å…¶ä»–æµ‹è¯•è¾…åŠ©æ–‡ä»¶æˆ–ä¸»æµ‹è¯•æ–‡ä»¶ main.cpp) # ğŸ—‘ï¸ åºŸå¼ƒ/é‡å†™ æˆ– ğŸ”’ ä¿ç•™ (é€‚é…): æµ‹è¯•å¯åŠ¨é€»è¾‘å¯èƒ½ä¿ç•™ï¼Œä½†æµ‹è¯•ç”¨ä¾‹æœ¬èº«ä¼šå¤§æ”¹ã€‚