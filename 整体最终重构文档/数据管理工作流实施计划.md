# 数据管理工作流实施计划

## 项目概述

基于您提出的关键需求，我们需要实现一个智能的数据管理工作流系统，重点解决以下核心问题：

### 🎯 核心需求
1. **网格精度管理**：不同精度数据的自动识别和插值计算支持
2. **时间分辨率分类**：年平均、月平均、日平均、小时等不同时间分辨率的统一管理
3. **数据连续性保证**：确保分析中使用相同时间分辨率且时间连续的数据
4. **缺失数据处理**：自动检测数据缺口并提供前端提示信息

### 🏗️ 技术架构
```
涡流分析应用
    ↓ 查询请求 (指定时间分辨率和精度要求)
数据管理工作流层
    ↓ 智能数据选择 + 连续性验证
增强的元数据服务
    ↓ 精度感知 + 时间分辨率管理
数据库存储层 (包含质量和连续性信息)
    ↓ 文件系统
NetCDF数据文件
```

## 第一阶段：数据库设计与元数据增强（2-3周）

### 1.1 数据库表结构实现

#### 优先级1：核心表结构
```sql
-- 1. 增强文件表，添加精度和分辨率信息
ALTER TABLE nc_files ADD COLUMN temporal_resolution TEXT;
ALTER TABLE nc_files ADD COLUMN temporal_resolution_seconds INTEGER;
ALTER TABLE nc_files ADD COLUMN spatial_resolution_lon REAL;
ALTER TABLE nc_files ADD COLUMN spatial_resolution_lat REAL;
ALTER TABLE nc_files ADD COLUMN spatial_resolution_meters REAL;
ALTER TABLE nc_files ADD COLUMN grid_type TEXT;
ALTER TABLE nc_files ADD COLUMN data_completeness REAL DEFAULT 1.0;
ALTER TABLE nc_files ADD COLUMN fill_value_ratio REAL DEFAULT 0.0;

-- 2. 创建时间分辨率定义表
CREATE TABLE temporal_resolution_definitions (
    resolution_id TEXT PRIMARY KEY,
    resolution_name TEXT NOT NULL,
    resolution_seconds INTEGER NOT NULL,
    resolution_hours REAL NOT NULL,
    category TEXT NOT NULL,
    description TEXT,
    sort_order INTEGER DEFAULT 0,
    is_regular BOOLEAN DEFAULT TRUE
);

-- 3. 创建空间分辨率等级表
CREATE TABLE spatial_resolution_levels (
    level_id TEXT PRIMARY KEY,
    level_name TEXT NOT NULL,
    min_resolution_degrees REAL NOT NULL,
    max_resolution_degrees REAL NOT NULL,
    description TEXT,
    interpolation_method TEXT,
    quality_weight REAL DEFAULT 1.0
);

-- 4. 创建时间连续性表
CREATE TABLE temporal_continuity (
    continuity_id TEXT PRIMARY KEY,        -- 连续性记录ID
    dataset_id TEXT NOT NULL,              -- 数据集ID
    temporal_resolution TEXT NOT NULL,     -- 时间分辨率
    period_start INTEGER NOT NULL,         -- 期间开始时间
    period_end INTEGER NOT NULL,           -- 期间结束时间
    expected_steps INTEGER NOT NULL,       -- 期望的时间步数
    actual_steps INTEGER NOT NULL,         -- 实际的时间步数
    missing_steps INTEGER DEFAULT 0,       -- 缺失的时间步数
    continuity_ratio REAL NOT NULL,        -- 连续性比例 (0-1)
    max_gap_hours INTEGER DEFAULT 0,       -- 最大间隙(小时)
    status TEXT DEFAULT 'valid',           -- 状态 (valid, warning, critical)
    last_checked INTEGER NOT NULL,         -- 最后检查时间
    FOREIGN KEY (dataset_id) REFERENCES datasets(dataset_id)
);

-- 5. 创建海洋环境数据类型表 (基于哥白尼CMEMS分类)
CREATE TABLE ocean_data_types (
    type_id TEXT PRIMARY KEY,              -- 数据类型ID
    type_name TEXT NOT NULL,               -- 数据类型名称
    category TEXT NOT NULL,                -- 主要类别 (physical, biogeochemical, sea_ice)
    subcategory TEXT,                      -- 子类别
    description TEXT,                      -- 描述
    standard_variables TEXT,               -- 标准变量列表 (JSON)
    cmems_product_family TEXT,             -- CMEMS产品族
    temporal_resolution_types TEXT,        -- 支持的时间分辨率类型 (JSON)
    spatial_coverage TEXT,                 -- 空间覆盖范围 (global, regional, coastal)
    data_level TEXT,                       -- 数据级别 (L3, L4, analysis, forecast)
    processing_level TEXT,                 -- 处理级别 (raw, processed, reanalysis)
    quality_requirements TEXT,             -- 质量要求 (JSON)
    interpolation_suitable BOOLEAN DEFAULT TRUE, -- 是否适合插值
    created_time INTEGER NOT NULL,         -- 创建时间
    updated_time INTEGER NOT NULL          -- 更新时间
);

-- 插入哥白尼海洋数据类型定义
INSERT INTO ocean_data_types VALUES
-- 物理海洋学数据 (蓝色海洋)
('ocean_current', '海洋流场', 'physical', 'circulation', 
 '海洋表面和次表面流速数据，包括地转流和总流', 
 '["u", "v", "w", "velocity_magnitude", "velocity_direction"]',
 'GLOBAL_ANALYSIS_FORECAST_PHY', 
 '["hourly", "daily", "monthly"]', 
 'global', 'L4', 'analysis_forecast', 
 '{"min_continuity": 0.9, "max_fill_ratio": 0.1}', 
 true, strftime('%s', 'now'), strftime('%s', 'now')),

('sea_surface_height', '海面高度', 'physical', 'sea_level', 
 '海面高度异常和绝对动力地形数据', 
 '["adt", "sla", "mdt", "geostrophic_velocity"]',
 'SEALEVEL_GLO_PHY_L4', 
 '["daily", "monthly"]', 
 'global', 'L4', 'reanalysis', 
 '{"min_continuity": 0.95, "max_fill_ratio": 0.05}', 
 true, strftime('%s', 'now'), strftime('%s', 'now')),

('sea_surface_temperature', '海面温度', 'physical', 'temperature', 
 '海面温度和海面温度异常数据', 
 '["sst", "sst_anomaly", "sst_trend"]',
 'SST_GLO_PHY_L4', 
 '["daily", "monthly", "yearly"]', 
 'global', 'L4', 'reanalysis', 
 '{"min_continuity": 0.9, "max_fill_ratio": 0.1}', 
 true, strftime('%s', 'now'), strftime('%s', 'now')),

('ocean_temperature_salinity', '海洋温盐', 'physical', 'hydrography', 
 '三维海洋温度和盐度分布数据', 
 '["temperature", "salinity", "potential_temperature", "practical_salinity"]',
 'GLOBAL_MULTIYEAR_PHY', 
 '["daily", "monthly"]', 
 'global', 'L4', 'reanalysis', 
 '{"min_continuity": 0.85, "max_fill_ratio": 0.15}', 
 true, strftime('%s', 'now'), strftime('%s', 'now')),

('ocean_mixed_layer', '海洋混合层', 'physical', 'mixed_layer', 
 '混合层深度和相关物理参数', 
 '["mixed_layer_depth", "mixed_layer_temperature", "stratification"]',
 'GLOBAL_MULTIYEAR_PHY', 
 '["daily", "monthly"]', 
 'global', 'L4', 'analysis', 
 '{"min_continuity": 0.8, "max_fill_ratio": 0.2}', 
 true, strftime('%s', 'now'), strftime('%s', 'now')),

('ocean_waves', '海浪', 'physical', 'waves', 
 '海浪高度、周期、方向等参数', 
 '["significant_wave_height", "wave_period", "wave_direction", "wave_energy"]',
 'GLOBAL_ANALYSIS_FORECAST_WAV', 
 '["hourly", "3hourly", "daily"]', 
 'global', 'L4', 'analysis_forecast', 
 '{"min_continuity": 0.9, "max_fill_ratio": 0.1}', 
 true, strftime('%s', 'now'), strftime('%s', 'now')),

-- 生物地球化学数据 (绿色海洋)
('ocean_biogeochemistry', '海洋生物地球化学', 'biogeochemical', 'nutrients', 
 '海洋营养盐、溶解氧、pH等生化参数', 
 '["nitrate", "phosphate", "silicate", "oxygen", "ph", "alkalinity"]',
 'GLOBAL_ANALYSIS_FORECAST_BGC', 
 '["daily", "monthly"]', 
 'global', 'L4', 'analysis_forecast', 
 '{"min_continuity": 0.8, "max_fill_ratio": 0.2}', 
 true, strftime('%s', 'now'), strftime('%s', 'now')),

('ocean_color', '海洋颜色', 'biogeochemical', 'optics', 
 '叶绿素浓度、初级生产力、透明度等光学参数', 
 '["chlorophyll_a", "primary_production", "kd490", "turbidity"]',
 'OCEANCOLOUR_GLO_BGC_L4', 
 '["daily", "monthly"]', 
 'global', 'L4', 'satellite_obs', 
 '{"min_continuity": 0.7, "max_fill_ratio": 0.3}', 
 false, strftime('%s', 'now'), strftime('%s', 'now')),

('ocean_carbon', '海洋碳循环', 'biogeochemical', 'carbon', 
 '海洋碳通量、CO2分压、碳酸盐系统参数', 
 '["co2_flux", "pco2", "dic", "carbon_export"]',
 'GLOBAL_ANALYSIS_FORECAST_BGC', 
 '["monthly", "yearly"]', 
 'global', 'L4', 'analysis', 
 '{"min_continuity": 0.75, "max_fill_ratio": 0.25}', 
 true, strftime('%s', 'now'), strftime('%s', 'now')),

('marine_ecosystems', '海洋生态系统', 'biogeochemical', 'ecosystem', 
 '浮游植物、浮游动物、鱼类生物量等生态参数', 
 '["phytoplankton", "zooplankton", "fish_biomass", "biodiversity_index"]',
 'GLOBAL_ANALYSIS_FORECAST_BGC', 
 '["monthly", "yearly"]', 
 'global', 'L4', 'analysis', 
 '{"min_continuity": 0.7, "max_fill_ratio": 0.3}', 
 false, strftime('%s', 'now'), strftime('%s', 'now')),

-- 海冰数据 (白色海洋)
('sea_ice', '海冰', 'sea_ice', 'ice_coverage', 
 '海冰浓度、厚度、漂移等参数', 
 '["ice_concentration", "ice_thickness", "ice_drift", "ice_age"]',
 'SEAICE_GLO_PHY_L4', 
 '["daily", "monthly"]', 
 'polar', 'L4', 'analysis_forecast', 
 '{"min_continuity": 0.85, "max_fill_ratio": 0.15}', 
 true, strftime('%s', 'now'), strftime('%s', 'now')),

('sea_ice_edge', '海冰边缘', 'sea_ice', 'ice_edge', 
 '海冰边缘位置和变化趋势', 
 '["ice_edge_position", "ice_edge_velocity", "ice_extent"]',
 'SEAICE_GLO_PHY_L4', 
 '["daily", "monthly"]', 
 'polar', 'L4', 'analysis', 
 '{"min_continuity": 0.9, "max_fill_ratio": 0.1}', 
 true, strftime('%s', 'now'), strftime('%s', 'now')),

-- 区域特定数据类型
('arctic_ocean', '北极海洋', 'physical', 'regional', 
 '北极海洋物理和海冰综合数据', 
 '["u", "v", "temperature", "salinity", "ice_concentration"]',
 'ARCTIC_ANALYSIS_FORECAST_PHYS', 
 '["daily", "monthly"]', 
 'regional', 'L4', 'analysis_forecast', 
 '{"min_continuity": 0.85, "max_fill_ratio": 0.15}', 
 true, strftime('%s', 'now'), strftime('%s', 'now')),

('coastal_ocean', '近岸海洋', 'physical', 'coastal', 
 '高分辨率近岸海洋物理数据', 
 '["u", "v", "temperature", "salinity", "ssh", "waves"]',
 'COASTAL_ANALYSIS_FORECAST', 
 '["hourly", "daily"]', 
 'coastal', 'L4', 'analysis_forecast', 
 '{"min_continuity": 0.8, "max_fill_ratio": 0.2}', 
 true, strftime('%s', 'now'), strftime('%s', 'now')),

-- 极端事件和特殊现象
('ocean_eddies', '海洋涡旋', 'physical', 'mesoscale', 
 '中尺度涡旋识别和跟踪数据', 
 '["eddy_id", "eddy_type", "eddy_radius", "eddy_intensity", "vorticity"]',
 'GLOBAL_ANALYSIS_FORECAST_PHY', 
 '["daily", "weekly"]', 
 'global', 'L4', 'derived_product', 
 '{"min_continuity": 0.95, "max_fill_ratio": 0.05}', 
 false, strftime('%s', 'now'), strftime('%s', 'now')),

('ocean_sound_speed', '海洋声速', 'physical', 'acoustics', 
 '海洋中声波传播速度数据，基于温度、盐度和压力计算', 
 '["sound_speed", "sound_speed_anomaly", "acoustic_impedance"]',
 'GLOBAL_MULTIYEAR_PHY', 
 '["daily", "monthly"]', 
 'global', 'L4', 'derived_product', 
 '{"min_continuity": 0.85, "max_fill_ratio": 0.15}', 
 true, strftime('%s', 'now'), strftime('%s', 'now'));
```

#### 优先级2：索引优化
```sql
-- 时间分辨率相关索引
CREATE INDEX idx_files_temporal_resolution ON nc_files(temporal_resolution, temporal_resolution_seconds);
CREATE INDEX idx_files_time_continuity ON nc_files(dataset_id, time_start, time_end);

-- 空间分辨率相关索引
CREATE INDEX idx_files_spatial_resolution ON nc_files(spatial_resolution_lon, spatial_resolution_lat);
CREATE INDEX idx_files_grid_type ON nc_files(grid_type);

-- 数据质量相关索引
CREATE INDEX idx_files_quality ON nc_files(data_completeness, fill_value_ratio);

-- 连续性相关索引
CREATE INDEX idx_continuity_dataset ON temporal_continuity(dataset_id, temporal_resolution);
CREATE INDEX idx_continuity_ratio ON temporal_continuity(continuity_ratio, status);
```

### 1.2 元数据服务增强

#### 扩展现有MetadataService
```cpp
// core_services_impl/metadata_service/include/core_services/metadata/impl/metadata_service_impl.h
class MetadataServiceImpl : public IMetadataService {
public:
    // 新增：提取时间分辨率信息
    TemporalResolutionInfo extractTemporalResolution(const std::string& filePath);
    
    // 新增：提取空间分辨率信息
    SpatialResolutionInfo extractSpatialResolution(const std::string& filePath);
    
    // 新增：计算数据质量指标
    DataQualityMetrics calculateQualityMetrics(const std::string& filePath, 
                                              const std::vector<std::string>& variables);
    
    // 新增：检查时间连续性
    ContinuityAnalysis analyzeContinuity(const std::string& datasetId,
                                       const std::string& temporalResolution,
                                       std::time_t startTime,
                                       std::time_t endTime);

private:
    // 时间分辨率检测算法
    std::string detectTemporalResolution(const std::vector<std::time_t>& timeSteps);
    
    // 空间分辨率计算
    double calculateSpatialResolution(const std::vector<double>& coordinates);
    
    // 数据完整性评估
    double assessDataCompleteness(const std::string& filePath, const std::string& variable);
};
```

#### 数据结构定义
```cpp
// core_services_impl/metadata_service/include/core_services/metadata/impl/enhanced_metadata_types.h
struct TemporalResolutionInfo {
    std::string resolutionId;           // "hourly", "daily", "monthly", etc.
    std::string resolutionName;         // "小时", "日", "月"
    int resolutionSeconds;              // 秒数
    double resolutionHours;             // 小时数
    std::string category;               // "sub_hourly", "hourly", "daily", etc.
    bool isRegular;                     // 是否规律间隔
    double detectedInterval;            // 检测到的实际间隔
    double intervalVariance;            // 间隔方差（用于评估规律性）
};

struct SpatialResolutionInfo {
    double lonResolution;               // 经度分辨率(度)
    double latResolution;               // 纬度分辨率(度)
    double avgResolutionMeters;         // 平均分辨率(米)
    std::string resolutionLevel;        // "ultra_high", "high", "medium", "low"
    std::string gridType;               // "regular", "irregular", "curvilinear"
    bool isUniform;                     // 是否均匀网格
    BoundingBox spatialBounds;          // 空间边界
};

struct DataQualityMetrics {
    double completeness;                // 数据完整性 (0-1)
    double fillValueRatio;              // 填充值比例 (0-1)
    std::map<std::string, VariableQuality> variableQuality;
    double overallScore;                // 总体质量评分 (0-1)
    std::vector<std::string> qualityIssues;
};

struct VariableQuality {
    double validDataRatio;              // 有效数据比例
    double minValue;                    // 最小值
    double maxValue;                    // 最大值
    double meanValue;                   // 平均值
    double stdValue;                    // 标准差
    bool hasOutliers;                   // 是否有异常值
    std::string qualityLevel;           // "excellent", "good", "fair", "poor"
};

struct ContinuityAnalysis {
    std::string datasetId;
    std::string temporalResolution;
    std::time_t periodStart;
    std::time_t periodEnd;
    
    int expectedSteps;                  // 期望的时间步数
    int actualSteps;                    // 实际的时间步数
    int missingSteps;                   // 缺失的时间步数
    double continuityRatio;             // 连续性比例 (0-1)
    
    std::vector<DataGap> gaps;          // 数据缺口列表
    std::chrono::hours maxGapDuration;  // 最大缺口持续时间
    std::chrono::hours avgGapDuration;  // 平均缺口持续时间
    
    std::string status;                 // "excellent", "good", "warning", "critical"
    std::vector<std::string> recommendations;
};

struct DataGap {
    std::time_t gapStart;
    std::time_t gapEnd;
    std::chrono::hours duration;
    std::string severity;               // "minor", "moderate", "critical"
    std::string gapType;                // "missing_file", "missing_timestep", "invalid_data"
    std::vector<std::string> affectedVariables;
    std::string recommendedAction;      // "interpolate", "skip", "find_alternative"
};
```

## 第二阶段：连续性检查与质量评估算法（2-3周）

### 2.1 时间连续性检查算法

#### 核心算法实现
```cpp
// core_services_impl/metadata_service/src/impl/continuity_analyzer.cpp
class ContinuityAnalyzer {
public:
    ContinuityAnalysis analyzeContinuity(const std::string& datasetId,
                                       const std::string& temporalResolution) {
        // 1. 获取数据集中所有文件的时间信息
        auto files = getDatasetFiles(datasetId);
        
        // 2. 构建完整的时间序列
        auto timeSteps = buildTimeSequence(files, temporalResolution);
        
        // 3. 检测时间缺口
        auto gaps = detectTimeGaps(timeSteps, temporalResolution);
        
        // 4. 评估连续性
        auto continuity = evaluateContinuity(timeSteps, gaps);
        
        // 5. 生成建议
        auto recommendations = generateRecommendations(gaps, temporalResolution);
        
        return ContinuityAnalysis{
            .datasetId = datasetId,
            .temporalResolution = temporalResolution,
            .gaps = gaps,
            .continuityRatio = continuity.ratio,
            .status = continuity.status,
            .recommendations = recommendations
        };
    }

private:
    std::vector<DataGap> detectTimeGaps(const std::vector<std::time_t>& timeSteps,
                                       const std::string& temporalResolution) {
        std::vector<DataGap> gaps;
        
        // 获取期望的时间间隔
        auto expectedInterval = getExpectedInterval(temporalResolution);
        
        for (size_t i = 1; i < timeSteps.size(); ++i) {
            auto actualInterval = timeSteps[i] - timeSteps[i-1];
            
            // 如果实际间隔超过期望间隔的1.5倍，认为存在缺口
            if (actualInterval > expectedInterval * 1.5) {
                DataGap gap;
                gap.gapStart = timeSteps[i-1] + expectedInterval;
                gap.gapEnd = timeSteps[i];
                gap.duration = std::chrono::hours((actualInterval - expectedInterval) / 3600);
                gap.severity = classifyGapSeverity(gap.duration, temporalResolution);
                gap.gapType = "missing_timestep";
                gap.recommendedAction = suggestAction(gap.severity, gap.duration);
                
                gaps.push_back(gap);
            }
        }
        
        return gaps;
    }
    
    std::string classifyGapSeverity(std::chrono::hours duration, 
                                   const std::string& temporalResolution) {
        // 根据时间分辨率和缺口持续时间分类严重程度
        if (temporalResolution == "hourly") {
            if (duration <= std::chrono::hours(3)) return "minor";
            if (duration <= std::chrono::hours(12)) return "moderate";
            return "critical";
        } else if (temporalResolution == "daily") {
            if (duration <= std::chrono::hours(48)) return "minor";
            if (duration <= std::chrono::hours(168)) return "moderate";  // 1周
            return "critical";
        }
        // 其他分辨率的分类逻辑...
        return "moderate";
    }
};
```

### 2.2 数据质量评估算法

#### 质量评分算法
```cpp
// core_services_impl/metadata_service/src/impl/quality_assessor.cpp
class QualityAssessor {
public:
    DataQualityMetrics assessQuality(const std::string& filePath,
                                   const std::vector<std::string>& variables) {
        DataQualityMetrics metrics;
        
        // 1. 评估每个变量的质量
        for (const auto& variable : variables) {
            auto varQuality = assessVariableQuality(filePath, variable);
            metrics.variableQuality[variable] = varQuality;
        }
        
        // 2. 计算整体完整性
        metrics.completeness = calculateCompleteness(filePath, variables);
        
        // 3. 计算填充值比例
        metrics.fillValueRatio = calculateFillValueRatio(filePath, variables);
        
        // 4. 计算总体质量评分
        metrics.overallScore = calculateOverallScore(metrics);
        
        // 5. 识别质量问题
        metrics.qualityIssues = identifyQualityIssues(metrics);
        
        return metrics;
    }

private:
    VariableQuality assessVariableQuality(const std::string& filePath,
                                        const std::string& variable) {
        VariableQuality quality;
        
        // 使用NetCDF读取器获取变量数据统计信息
        auto reader = createNetCDFReader(filePath);
        auto stats = reader->getVariableStatistics(variable);
        
        quality.validDataRatio = stats.validDataRatio;
        quality.minValue = stats.minValue;
        quality.maxValue = stats.maxValue;
        quality.meanValue = stats.meanValue;
        quality.stdValue = stats.stdValue;
        
        // 异常值检测
        quality.hasOutliers = detectOutliers(stats);
        
        // 质量等级评估
        quality.qualityLevel = evaluateQualityLevel(quality);
        
        return quality;
    }
    
    double calculateOverallScore(const DataQualityMetrics& metrics) {
        double score = 0.0;
        double weights = 0.0;
        
        // 完整性权重：40%
        score += metrics.completeness * 0.4;
        weights += 0.4;
        
        // 填充值比例权重：30% (反向)
        score += (1.0 - metrics.fillValueRatio) * 0.3;
        weights += 0.3;
        
        // 变量质量权重：30%
        double avgVariableQuality = 0.0;
        for (const auto& [varName, varQuality] : metrics.variableQuality) {
            avgVariableQuality += varQuality.validDataRatio;
        }
        if (!metrics.variableQuality.empty()) {
            avgVariableQuality /= metrics.variableQuality.size();
            score += avgVariableQuality * 0.3;
            weights += 0.3;
        }
        
        return weights > 0 ? score / weights : 0.0;
    }
};
```

## 第三阶段：智能查询服务实现（2-3周）

### 3.1 增强的查询接口

#### 涡流分析专用查询服务
```cpp
// core_services_impl/data_access_service/include/core_services/data_access/enhanced_query_service.h
class EddyDataQueryService {
public:
    struct EddyAnalysisQuery {
        std::time_t analysisTime;
        BoundingBox analysisRegion;
        std::chrono::hours timeWindow = std::chrono::hours(24);
        
        // 时间分辨率要求
        std::string preferredTemporalResolution = "hourly";
        std::vector<std::string> acceptableTemporalResolutions = {"hourly", "3hourly", "6hourly"};
        double minContinuityRatio = 0.9;
        
        // 空间分辨率要求
        std::string preferredSpatialResolution = "high";
        double maxSpatialResolutionDegrees = 0.1;
        
        // 变量要求
        std::vector<std::string> requiredVariables = {"u", "v", "w"};
        std::vector<std::string> optionalVariables = {"temperature", "salinity"};
        
        // 质量要求
        double minDataQuality = 0.8;
        double maxFillValueRatio = 0.1;
        
        // 插值配置
        bool allowTemporalInterpolation = true;
        bool allowSpatialInterpolation = false;
        std::string interpolationMethod = "linear";
    };
    
    struct EddyDataFileSet {
        std::vector<FileInfo> primaryFiles;
        std::vector<FileInfo> supplementaryFiles;
        ContinuityReport continuityReport;
        InterpolationPlan interpolationPlan;
        QualityAssessment qualityAssessment;
        std::vector<DataGap> identifiedGaps;
        std::vector<std::string> warnings;
        std::vector<std::string> recommendations;
    };
    
    // 获取涡流分析所需的文件集合
    EddyDataFileSet getEddyAnalysisFiles(const EddyAnalysisQuery& query);
    
    // 验证数据集的时间连续性
    ContinuityValidationResult validateTimeContinuity(
        const std::vector<FileInfo>& files,
        const std::string& temporalResolution);
    
    // 生成插值建议
    InterpolationRecommendation generateInterpolationPlan(
        const EddyAnalysisQuery& query,
        const std::vector<DataGap>& gaps);

private:
    std::shared_ptr<IMetadataService> metadataService_;
    std::shared_ptr<ContinuityAnalyzer> continuityAnalyzer_;
    std::shared_ptr<QualityAssessor> qualityAssessor_;
};
```

#### 查询实现
```cpp
// core_services_impl/data_access_service/src/impl/eddy_data_query_service.cpp
EddyDataFileSet EddyDataQueryService::getEddyAnalysisFiles(const EddyAnalysisQuery& query) {
    EddyDataFileSet result;
    
    // 1. 构建基础查询条件
    SpatialTemporalQuery baseQuery;
    baseQuery.timeStart = query.analysisTime - query.timeWindow;
    baseQuery.timeEnd = query.analysisTime + query.timeWindow;
    baseQuery.spatialBounds = query.analysisRegion;
    baseQuery.requiredVariables = query.requiredVariables;
    baseQuery.requiredTemporalResolution = query.preferredTemporalResolution;
    baseQuery.maxSpatialResolution = query.maxSpatialResolutionDegrees;
    baseQuery.minDataQuality = query.minDataQuality;
    baseQuery.maxFillValueRatio = query.maxFillValueRatio;
    
    // 2. 查找匹配的文件
    auto candidateFiles = findCandidateFiles(baseQuery);
    
    // 3. 按时间分辨率分组
    auto filesByResolution = groupFilesByTemporalResolution(candidateFiles);
    
    // 4. 选择最佳时间分辨率
    auto bestResolution = selectBestTemporalResolution(filesByResolution, query);
    result.primaryFiles = filesByResolution[bestResolution];
    
    // 5. 检查时间连续性
    result.continuityReport = continuityAnalyzer_->analyzeContinuity(
        result.primaryFiles, bestResolution);
    
    // 6. 评估数据质量
    result.qualityAssessment = qualityAssessor_->assessFileSetQuality(
        result.primaryFiles, query.requiredVariables);
    
    // 7. 识别数据缺口
    result.identifiedGaps = result.continuityReport.gaps;
    
    // 8. 生成插值计划
    if (!result.identifiedGaps.empty() && query.allowTemporalInterpolation) {
        result.interpolationPlan = generateInterpolationPlan(query, result.identifiedGaps);
    }
    
    // 9. 生成警告和建议
    result.warnings = generateWarnings(result);
    result.recommendations = generateRecommendations(result, query);
    
    return result;
}

std::string EddyDataQueryService::selectBestTemporalResolution(
    const std::map<std::string, std::vector<FileInfo>>& filesByResolution,
    const EddyAnalysisQuery& query) {
    
    // 优先选择首选分辨率
    if (filesByResolution.count(query.preferredTemporalResolution) > 0) {
        auto& files = filesByResolution.at(query.preferredTemporalResolution);
        auto continuity = continuityAnalyzer_->analyzeContinuity(files, query.preferredTemporalResolution);
        if (continuity.continuityRatio >= query.minContinuityRatio) {
            return query.preferredTemporalResolution;
        }
    }
    
    // 尝试可接受的分辨率
    for (const auto& resolution : query.acceptableTemporalResolutions) {
        if (filesByResolution.count(resolution) > 0) {
            auto& files = filesByResolution.at(resolution);
            auto continuity = continuityAnalyzer_->analyzeContinuity(files, resolution);
            if (continuity.continuityRatio >= query.minContinuityRatio) {
                return resolution;
            }
        }
    }
    
    // 如果没有满足连续性要求的，选择连续性最好的
    std::string bestResolution;
    double bestContinuity = 0.0;
    
    for (const auto& [resolution, files] : filesByResolution) {
        auto continuity = continuityAnalyzer_->analyzeContinuity(files, resolution);
        if (continuity.continuityRatio > bestContinuity) {
            bestContinuity = continuity.continuityRatio;
            bestResolution = resolution;
        }
    }
    
    return bestResolution;
}
```

### 3.2 前端提示信息生成

#### 警告信息生成器
```cpp
// core_services_impl/data_access_service/src/impl/warning_generator.cpp
class WarningGenerator {
public:
    std::vector<UserWarning> generateWarnings(const EddyDataFileSet& fileSet,
                                             const EddyAnalysisQuery& query) {
        std::vector<UserWarning> warnings;
        
        // 1. 连续性警告
        if (fileSet.continuityReport.continuityRatio < query.minContinuityRatio) {
            warnings.push_back(generateContinuityWarning(fileSet.continuityReport, query));
        }
        
        // 2. 分辨率不匹配警告
        if (hasResolutionMismatch(fileSet, query)) {
            warnings.push_back(generateResolutionWarning(fileSet, query));
        }
        
        // 3. 数据质量警告
        if (fileSet.qualityAssessment.overallScore < query.minDataQuality) {
            warnings.push_back(generateQualityWarning(fileSet.qualityAssessment, query));
        }
        
        // 4. 插值需求警告
        if (fileSet.interpolationPlan.isRequired) {
            warnings.push_back(generateInterpolationWarning(fileSet.interpolationPlan));
        }
        
        return warnings;
    }

private:
    UserWarning generateContinuityWarning(const ContinuityReport& report,
                                         const EddyAnalysisQuery& query) {
        UserWarning warning;
        warning.type = "data_continuity";
        warning.severity = report.continuityRatio < 0.5 ? "critical" : "warning";
        warning.title = "检测到数据时间序列不连续";
        
        // 构建详细信息
        nlohmann::json details;
        details["dataset"] = report.datasetId;
        details["temporal_resolution"] = report.temporalResolution;
        details["continuity_ratio"] = report.continuityRatio;
        details["required_ratio"] = query.minContinuityRatio;
        details["gaps_found"] = report.gaps.size();
        details["max_gap_duration"] = report.maxGapDuration.count();
        
        if (!report.gaps.empty()) {
            auto& firstGap = report.gaps[0];
            details["first_gap_start"] = formatTime(firstGap.gapStart);
            details["first_gap_end"] = formatTime(firstGap.gapEnd);
        }
        
        warning.details = details;
        
        // 生成建议
        warning.recommendations = {
            "考虑使用线性插值填补较小的数据缺口",
            "对于关键分析，建议寻找替代数据源",
            "可以调整分析时间窗口以避开主要数据缺口"
        };
        
        // 生成可执行操作
        if (query.allowTemporalInterpolation) {
            UserAction interpolateAction;
            interpolateAction.type = "interpolate";
            interpolateAction.label = "自动插值填补";
            interpolateAction.apiEndpoint = "/api/data/interpolate";
            interpolateAction.parameters = {
                {"gaps", report.gaps},
                {"method", query.interpolationMethod}
            };
            warning.actions.push_back(interpolateAction);
        }
        
        UserAction findAlternativeAction;
        findAlternativeAction.type = "find_alternative";
        findAlternativeAction.label = "查找替代数据";
        findAlternativeAction.apiEndpoint = "/api/data/alternatives";
        findAlternativeAction.parameters = {
            {"query", query},
            {"exclude_datasets", {report.datasetId}}
        };
        warning.actions.push_back(findAlternativeAction);
        
        return warning;
    }
};

struct UserWarning {
    std::string type;                   // "data_continuity", "resolution_mismatch", "data_quality"
    std::string severity;               // "info", "warning", "critical"
    std::string title;                  // 警告标题
    std::string message;                // 详细消息
    nlohmann::json details;             // 详细信息
    std::vector<std::string> recommendations; // 建议
    std::vector<UserAction> actions;    // 可执行操作
};

struct UserAction {
    std::string type;                   // 操作类型
    std::string label;                  // 显示标签
    std::string apiEndpoint;            // API端点
    nlohmann::json parameters;          // 参数
};
```

## 第四阶段：API接口与前端集成（1-2周）

### 4.1 RESTful API实现

#### 涡流分析专用API
```cpp
// network_service/src/handlers/eddy_data_handler.cpp
class EddyDataHandler {
public:
    // 获取涡流分析数据
    crow::response handleEddyDataQuery(const crow::request& req) {
        try {
            // 解析请求
            auto query = parseEddyAnalysisQuery(req.body);
            
            // 执行查询
            auto fileSet = eddyQueryService_->getEddyAnalysisFiles(query);
            
            // 生成响应
            nlohmann::json response;
            response["status"] = "success";
            response["data"] = {
                {"primary_files", fileSet.primaryFiles},
                {"supplementary_files", fileSet.supplementaryFiles},
                {"continuity_report", fileSet.continuityReport},
                {"quality_assessment", fileSet.qualityAssessment},
                {"interpolation_plan", fileSet.interpolationPlan},
                {"warnings", fileSet.warnings},
                {"recommendations", fileSet.recommendations}
            };
            
            return crow::response(200, response.dump());
            
        } catch (const std::exception& e) {
            nlohmann::json error;
            error["status"] = "error";
            error["message"] = e.what();
            return crow::response(400, error.dump());
        }
    }
    
    // 验证数据连续性
    crow::response handleContinuityValidation(const crow::request& req) {
        try {
            auto request = nlohmann::json::parse(req.body);
            
            std::vector<std::string> filePaths = request["file_list"];
            std::string temporalResolution = request["temporal_resolution"];
            double requiredContinuity = request.value("required_continuity", 0.9);
            
            // 执行连续性验证
            auto result = eddyQueryService_->validateTimeContinuity(filePaths, temporalResolution);
            
            nlohmann::json response;
            response["status"] = "success";
            response["validation_result"] = result;
            response["meets_requirements"] = result.continuityRatio >= requiredContinuity;
            
            if (result.continuityRatio < requiredContinuity) {
                response["warnings"] = generateContinuityWarnings(result, requiredContinuity);
            }
            
            return crow::response(200, response.dump());
            
        } catch (const std::exception& e) {
            nlohmann::json error;
            error["status"] = "error";
            error["message"] = e.what();
            return crow::response(400, error.dump());
        }
    }

private:
    std::shared_ptr<EddyDataQueryService> eddyQueryService_;
};
```

### 4.2 前端集成示例

#### JavaScript前端代码示例
```javascript
// 涡流分析数据查询
class EddyDataManager {
    async queryEddyData(analysisConfig) {
        try {
            const response = await fetch('/api/eddy/data/query', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    analysis_time: analysisConfig.analysisTime,
                    analysis_region: analysisConfig.region,
                    time_window_hours: analysisConfig.timeWindow,
                    temporal_resolution: analysisConfig.temporalResolution,
                    max_spatial_resolution: analysisConfig.maxSpatialResolution,
                    min_continuity_ratio: analysisConfig.minContinuity,
                    min_data_quality: analysisConfig.minQuality,
                    required_variables: ['u', 'v', 'w'],
                    interpolation_config: {
                        allow_temporal: true,
                        allow_spatial: false,
                        method: 'linear'
                    }
                })
            });
            
            const result = await response.json();
            
            if (result.status === 'success') {
                // 处理成功响应
                this.handleSuccessfulQuery(result.data);
                
                // 显示警告信息
                if (result.data.warnings && result.data.warnings.length > 0) {
                    this.displayWarnings(result.data.warnings);
                }
                
                return result.data;
            } else {
                throw new Error(result.message);
            }
            
        } catch (error) {
            console.error('涡流数据查询失败:', error);
            this.displayError('数据查询失败: ' + error.message);
            throw error;
        }
    }
    
    displayWarnings(warnings) {
        warnings.forEach(warning => {
            switch (warning.type) {
                case 'data_continuity':
                    this.showContinuityWarning(warning);
                    break;
                case 'resolution_mismatch':
                    this.showResolutionWarning(warning);
                    break;
                case 'data_quality':
                    this.showQualityWarning(warning);
                    break;
            }
        });
    }
    
    showContinuityWarning(warning) {
        const warningDiv = document.createElement('div');
        warningDiv.className = `alert alert-${warning.severity}`;
        warningDiv.innerHTML = `
            <h5>${warning.title}</h5>
            <p>数据连续性: ${(warning.details.continuity_ratio * 100).toFixed(1)}%</p>
            <p>发现 ${warning.details.gaps_found} 个数据缺口</p>
            <p>最大缺口持续时间: ${warning.details.max_gap_duration} 小时</p>
            
            <div class="recommendations">
                <h6>建议:</h6>
                <ul>
                    ${warning.recommendations.map(rec => `<li>${rec}</li>`).join('')}
                </ul>
            </div>
            
            <div class="actions">
                ${warning.actions.map(action => 
                    `<button class="btn btn-sm btn-outline-primary" 
                             onclick="this.executeAction('${action.type}', ${JSON.stringify(action.parameters)})">
                        ${action.label}
                     </button>`
                ).join('')}
            </div>
        `;
        
        document.getElementById('warnings-container').appendChild(warningDiv);
    }
    
    async executeAction(actionType, parameters) {
        switch (actionType) {
            case 'interpolate':
                await this.executeInterpolation(parameters);
                break;
            case 'find_alternative':
                await this.findAlternativeData(parameters);
                break;
        }
    }
    
    async executeInterpolation(parameters) {
        try {
            const response = await fetch('/api/data/interpolate', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(parameters)
            });
            
            const result = await response.json();
            
            if (result.status === 'success') {
                this.displaySuccess('数据插值完成');
                // 重新查询数据
                this.refreshData();
            } else {
                this.displayError('插值失败: ' + result.message);
            }
            
        } catch (error) {
            this.displayError('插值操作失败: ' + error.message);
        }
    }
}
```

## 验收标准与测试计划

### 功能验收标准
- [ ] **时间分辨率识别准确率 > 98%**：自动识别小时、日、月等时间分辨率
- [ ] **空间分辨率分类准确率 > 95%**：正确分类高、中、低分辨率等级
- [ ] **连续性检测准确率 > 95%**：准确识别时间序列中的数据缺口
- [ ] **质量评估相关性 > 0.85**：质量评分与人工评估的相关性
- [ ] **前端警告及时性 < 2秒**：从查询到显示警告信息的响应时间

### 性能验收标准
- [ ] **连续性检查性能 < 10秒**：检查1年数据的连续性
- [ ] **质量评估性能 < 30秒**：评估单个大文件(>1GB)的数据质量
- [ ] **查询响应性能 < 3秒**：包含质量和连续性过滤的复杂查询
- [ ] **插值建议生成 < 5秒**：分析数据缺口并生成插值建议

### 准确性验收标准
- [ ] **数据缺口检测无遗漏**：不能遗漏任何实际存在的数据缺口
- [ ] **插值精度预估误差 < 15%**：插值精度预估与实际精度的误差
- [ ] **分辨率匹配准确性 > 98%**：正确匹配用户需求与可用数据分辨率

## 总结

这个实施计划重点解决了您提出的核心需求：

1. **网格精度管理**：通过空间分辨率等级表和自动分类算法，实现不同精度数据的统一管理
2. **时间分辨率统一**：通过时间分辨率定义表和智能匹配算法，确保分析中使用相同时间分辨率的数据
3. **数据连续性保证**：通过连续性检查算法和缺口检测，自动识别时间序列的不连续性
4. **前端提示信息**：通过警告生成器和用户操作建议，为用户提供清晰的数据质量和连续性信息

这个系统将为涡流识别与跟踪提供可靠的数据基础设施，确保分析结果的准确性和可靠性。 

-- 6. 增强datasets表，添加海洋数据类型关联
ALTER TABLE datasets ADD COLUMN ocean_data_type_id TEXT;
ALTER TABLE datasets ADD COLUMN cmems_product_id TEXT;
ALTER TABLE datasets ADD COLUMN data_provider TEXT DEFAULT 'CMEMS';
ALTER TABLE datasets ADD COLUMN processing_level TEXT;
ALTER TABLE datasets ADD COLUMN data_format TEXT DEFAULT 'NetCDF';
ALTER TABLE datasets ADD COLUMN update_frequency TEXT;
ALTER TABLE datasets ADD COLUMN geographic_coverage TEXT;

-- 添加外键约束
ALTER TABLE datasets ADD CONSTRAINT fk_datasets_ocean_data_type 
    FOREIGN KEY (ocean_data_type_id) REFERENCES ocean_data_types(type_id);

-- 7. 创建数据类型兼容性表
CREATE TABLE data_type_compatibility (
    compatibility_id TEXT PRIMARY KEY,     -- 兼容性ID
    source_type_id TEXT NOT NULL,          -- 源数据类型
    target_type_id TEXT NOT NULL,          -- 目标数据类型
    compatibility_score REAL NOT NULL,     -- 兼容性评分 (0-1)
    interpolation_method TEXT,             -- 推荐插值方法
    interpolation_quality TEXT,            -- 插值质量 (excellent, good, fair, poor)
    processing_cost INTEGER DEFAULT 1,     -- 处理成本 (1-10)
    notes TEXT,                            -- 备注
    
    FOREIGN KEY (source_type_id) REFERENCES ocean_data_types(type_id),
    FOREIGN KEY (target_type_id) REFERENCES ocean_data_types(type_id)
);

-- 插入数据类型兼容性定义
INSERT INTO data_type_compatibility VALUES
-- 海洋流场内部兼容性
('ocean_current_self', 'ocean_current', 'ocean_current', 1.0, 'bilinear', 'excellent', 1, '同类型数据完全兼容'),

-- 海洋流场与其他物理数据的兼容性
('ocean_current_to_ssh', 'ocean_current', 'sea_surface_height', 0.9, 'geostrophic', 'excellent', 3, '可通过地转关系相互转换'),
('ssh_to_ocean_current', 'sea_surface_height', 'ocean_current', 0.9, 'geostrophic', 'excellent', 3, '可通过地转关系计算流场'),

-- 温度数据兼容性
('sst_to_temp_sal', 'sea_surface_temperature', 'ocean_temperature_salinity', 0.8, 'vertical_extrapolation', 'good', 4, '表面温度可用于约束三维温度场'),
('temp_sal_to_sst', 'ocean_temperature_salinity', 'sea_surface_temperature', 1.0, 'surface_extraction', 'excellent', 1, '三维温盐场可直接提取表面温度'),

-- 海冰数据兼容性
('sea_ice_self', 'sea_ice', 'sea_ice', 1.0, 'bilinear', 'excellent', 1, '海冰数据内部完全兼容'),
('sea_ice_to_edge', 'sea_ice', 'sea_ice_edge', 0.95, 'edge_detection', 'excellent', 2, '可从海冰浓度计算边缘位置'),

-- 生物地球化学数据兼容性
('bgc_to_color', 'ocean_biogeochemistry', 'ocean_color', 0.7, 'bio_optical', 'good', 5, '营养盐可影响海洋颜色，但关系复杂'),
('color_to_bgc', 'ocean_color', 'ocean_biogeochemistry', 0.6, 'empirical', 'fair', 6, '海洋颜色可估算部分生化参数'),

-- 区域数据兼容性
('global_to_arctic', 'ocean_current', 'arctic_ocean', 0.7, 'polar_adapted', 'fair', 5, '全球数据在极地区域精度较低'),
('global_to_coastal', 'ocean_current', 'coastal_ocean', 0.6, 'coastal_adapted', 'fair', 6, '全球数据在近岸区域需要特殊处理'),

-- 海洋声速兼容性
('temp_sal_to_sound_speed', 'ocean_temperature_salinity', 'ocean_sound_speed', 0.95, 'acoustic_formula', 'excellent', 2, '温盐数据可通过声学公式计算声速'),
('sound_speed_self', 'ocean_sound_speed', 'ocean_sound_speed', 1.0, 'bilinear', 'excellent', 1, '声速数据内部完全兼容'),

-- 涡旋识别兼容性
('current_to_eddies', 'ocean_current', 'ocean_eddies', 0.95, 'eddy_detection', 'excellent', 3, '流场数据可用于涡旋识别');

-- 8. 创建相关索引以优化查询性能
CREATE INDEX idx_ocean_data_types_category ON ocean_data_types(category);
CREATE INDEX idx_ocean_data_types_subcategory ON ocean_data_types(subcategory);
CREATE INDEX idx_ocean_data_types_cmems_family ON ocean_data_types(cmems_product_family);
CREATE INDEX idx_ocean_data_types_spatial_coverage ON ocean_data_types(spatial_coverage);
CREATE INDEX idx_ocean_data_types_data_level ON ocean_data_types(data_level);

CREATE INDEX idx_datasets_ocean_data_type ON datasets(ocean_data_type_id);
CREATE INDEX idx_datasets_cmems_product ON datasets(cmems_product_id);
CREATE INDEX idx_datasets_provider ON datasets(data_provider);
CREATE INDEX idx_datasets_coverage ON datasets(geographic_coverage);

CREATE INDEX idx_compatibility_source ON data_type_compatibility(source_type_id);
CREATE INDEX idx_compatibility_target ON data_type_compatibility(target_type_id);
CREATE INDEX idx_compatibility_score ON data_type_compatibility(compatibility_score);

-- 9. 创建数据类型查询视图
CREATE VIEW v_ocean_data_summary AS
SELECT 
    odt.type_id,
    odt.type_name,
    odt.category,
    odt.subcategory,
    odt.cmems_product_family,
    odt.spatial_coverage,
    odt.data_level,
    COUNT(d.dataset_id) as dataset_count,
    MIN(d.time_start) as earliest_data,
    MAX(d.time_end) as latest_data,
    AVG(d.file_count) as avg_files_per_dataset,
    SUM(d.total_size_mb) as total_size_mb
FROM ocean_data_types odt
LEFT JOIN datasets d ON odt.type_id = d.ocean_data_type_id
GROUP BY odt.type_id, odt.type_name, odt.category, odt.subcategory, 
         odt.cmems_product_family, odt.spatial_coverage, odt.data_level;

-- 10. 创建数据兼容性查询视图
CREATE VIEW v_data_compatibility_matrix AS
SELECT 
    s.type_name as source_type,
    s.category as source_category,
    t.type_name as target_type,
    t.category as target_category,
    c.compatibility_score,
    c.interpolation_method,
    c.interpolation_quality,
    c.processing_cost,
    c.notes
FROM data_type_compatibility c
JOIN ocean_data_types s ON c.source_type_id = s.type_id
JOIN ocean_data_types t ON c.target_type_id = t.type_id
ORDER BY c.compatibility_score DESC;

-- 11. 示例查询：查找特定类别的数据类型
-- 查询所有物理海洋学数据类型
SELECT type_id, type_name, subcategory, cmems_product_family
FROM ocean_data_types 
WHERE category = 'physical'
ORDER BY type_name;

-- 查询全球覆盖的L4级数据
SELECT type_id, type_name, category, cmems_product_family
FROM ocean_data_types 
WHERE spatial_coverage = 'global' AND data_level = 'L4'
ORDER BY category, type_name;

-- 查询适合插值的数据类型
SELECT type_id, type_name, category, interpolation_suitable
FROM ocean_data_types 
WHERE interpolation_suitable = true
ORDER BY category, type_name;

-- 12. 示例查询：数据兼容性分析
-- 查找与海洋流场兼容的数据类型
SELECT 
    target_type,
    compatibility_score,
    interpolation_method,
    interpolation_quality
FROM v_data_compatibility_matrix 
WHERE source_type = '海洋流场'
ORDER BY compatibility_score DESC;

-- 查找高兼容性的数据类型对
SELECT 
    source_type,
    target_type,
    compatibility_score,
    interpolation_quality
FROM v_data_compatibility_matrix 
WHERE compatibility_score >= 0.8
ORDER BY compatibility_score DESC;

-- 13. 示例查询：数据集统计
-- 按数据类型统计数据集数量
SELECT 
    type_name,
    category,
    dataset_count,
    total_size_mb,
    earliest_data,
    latest_data
FROM v_ocean_data_summary
WHERE dataset_count > 0
ORDER BY dataset_count DESC;

-- 查找缺少数据的数据类型
SELECT 
    type_name,
    category,
    cmems_product_family
FROM v_ocean_data_summary
WHERE dataset_count = 0 OR dataset_count IS NULL
ORDER BY category, type_name; 