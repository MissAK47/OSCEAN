# æ’å€¼æ¨¡å—æµ‹è¯•è®¡åˆ’ (çœŸå®æ•°æ®ç‰ˆæœ¬)

## ğŸ“Š æµ‹è¯•æ‰§è¡ŒçŠ¶æ€ (æ›´æ–°æ—¶é—´: 2024-12-20)

### ğŸ¯ å½“å‰æµ‹è¯•è¿›åº¦
- âœ… **ç®—æ³•åŸºç¡€åŠŸèƒ½æµ‹è¯•**: å·²å®Œæˆ (15/15 æµ‹è¯•ç”¨ä¾‹)
- âœ… **åŒçº¿æ€§æ’å€¼å™¨å•å…ƒæµ‹è¯•**: å·²å®Œæˆ (7/7 æµ‹è¯•ç”¨ä¾‹)
- âœ… **æœåŠ¡å±‚é›†æˆæµ‹è¯•**: å·²å®Œæˆ (6/7 æµ‹è¯•ç”¨ä¾‹é€šè¿‡)
- âœ… **æ€§èƒ½åŸºå‡†æµ‹è¯•**: å·²å®Œæˆ (å°è§„æ¨¡æµ‹è¯•)
- â³ **ç«‹æ–¹æ ·æ¡æ’å€¼å™¨æµ‹è¯•**: è·³è¿‡
- â³ **PCHIPæ’å€¼å™¨æµ‹è¯•**: è·³è¿‡

### ğŸ“ˆ æµ‹è¯•ç»“æœæ‘˜è¦

#### ç®—æ³•åŸºç¡€åŠŸèƒ½æµ‹è¯•ç»“æœ
**æ€»ä½“çŠ¶æ€**: 12/15 é€šè¿‡ (80% é€šè¿‡ç‡)

**é€šè¿‡çš„æµ‹è¯•**:
- âœ… Linear1D_BasicFunctionality
- âœ… Bilinear_BasicFunctionality  
- âœ… NearestNeighbor_BasicFunctionality
- âœ… CubicSpline_BasicFunctionality
- âœ… PCHIP_BasicFunctionality
- âœ… Trilinear_BasicFunctionality
- âœ… PerformanceComparison_1D
- âœ… PerformanceComparison_3D
- âœ… ComprehensiveEvaluation
- âœ… FastPCHIP_BasicFunctionality
- âœ… FastPCHIP3D_BasicFunctionality
- âœ… PCHIP_Bathy2D_BasicFunctionality

**å¤±è´¥çš„æµ‹è¯•**:
- âŒ PerformanceComparison_2D (PCHIP 2Dä¼˜åŒ–ç‰ˆæˆåŠŸç‡ä¸º0%)
- âŒ LargeScale_PerformanceComparison (PCHIP 2Dä¼˜åŒ–ç‰ˆæˆåŠŸç‡ä¸º0%)
- âŒ AccuracyComparison_AnalyticalFunction (PCHIP 2Dæ°´æ·±ä¼˜åŒ–ç‰ˆäº§ç”ŸNaNç»“æœ)

#### æœåŠ¡å±‚é›†æˆæµ‹è¯•ç»“æœ
**æ€»ä½“çŠ¶æ€**: 6/7 é€šè¿‡ (85.7% é€šè¿‡ç‡)

**é€šè¿‡çš„æµ‹è¯•**:
- âœ… ServiceConstruction (æœåŠ¡æ„é€ æµ‹è¯•)
  - æ”¯æŒçš„æ’å€¼æ–¹æ³•æ•°é‡: 6
  - éªŒè¯äº†BILINEARå’ŒNEAREST_NEIGHBORæ–¹æ³•çš„æ³¨å†Œ
- âœ… BasicAsyncInterpolation (åŸºç¡€å¼‚æ­¥æ’å€¼æµ‹è¯•)
  - æœ‰æ•ˆç»“æœ: 9/10 (90% æˆåŠŸç‡)
  - éªŒè¯äº†å¼‚æ­¥æ’å€¼çš„åŸºæœ¬åŠŸèƒ½
- âœ… SmartAlgorithmSelection (æ™ºèƒ½ç®—æ³•é€‰æ‹©æµ‹è¯•)
  - æˆåŠŸé€‰æ‹©äº†åŒçº¿æ€§æ’å€¼ç®—æ³•
  - æ‰§è¡Œæ—¶é—´: 0ms (å°æ•°æ®é›†)
- âœ… MultiDimensionalDataInterpolation (å¤šç»´æ•°æ®æ’å€¼æµ‹è¯•)
  - 3Dæ•°æ®æ’å€¼: 100/100 æœ‰æ•ˆç»“æœ (100% æˆåŠŸç‡)
  - éªŒè¯äº†ä¸‰çº¿æ€§æ’å€¼çš„åŠŸèƒ½
- âœ… ErrorHandling (é”™è¯¯å¤„ç†æµ‹è¯•)
  - ç©ºæ•°æ®é”™è¯¯: "æºç½‘æ ¼æ•°æ®ä¸ºç©º"
  - æ— æ•ˆæ–¹æ³•é”™è¯¯: "ä¸æ”¯æŒçš„æ’å€¼ç®—æ³•ç±»å‹: 999"
- âœ… ConcurrentProcessing (å¹¶å‘å¤„ç†æµ‹è¯•)
  - å¹¶å‘è¯·æ±‚æ•°: 10
  - æˆåŠŸå¤„ç†æ•°: 10 (100% æˆåŠŸç‡)
  - æ€»å¤„ç†æ—¶é—´: 1ms

**å¤±è´¥çš„æµ‹è¯•**:
- âŒ SIMDPerformanceComparison (SIMDæ€§èƒ½å¯¹æ¯”æµ‹è¯•)
  - å¤±è´¥åŸå› : æµ‹è¯•æ•°æ®å¤ªå°ï¼Œæ—¶é—´æµ‹é‡ä¸å‡†ç¡®
  - SIMDæ—¶é—´: 1ms, æ ‡é‡æ—¶é—´: 0ms
  - ç»“æœä¸€è‡´æ€§: 1000/1000 (100% ä¸€è‡´)
  - å»ºè®®: éœ€è¦æ›´å¤§çš„æ•°æ®é›†è¿›è¡Œæ€§èƒ½æµ‹è¯•

#### æ€§èƒ½åŸºå‡†æµ‹è¯•ç»“æœ
**æ€»ä½“çŠ¶æ€**: 1/1 é€šè¿‡ (100% é€šè¿‡ç‡)

**å°è§„æ¨¡æ€§èƒ½åŸºå‡†æµ‹è¯•** (100x100ç½‘æ ¼ï¼Œ1000ä¸ªç›®æ ‡ç‚¹):
- âœ… **æœ€è¿‘é‚»æ’å€¼**:
  - æ‰§è¡Œæ—¶é—´: 0.61ms
  - ååé‡: 1,636,661 ç‚¹/ç§’
  - å†…å­˜ä½¿ç”¨: 0.05MB
  - æˆåŠŸç‡: 100%
- âœ… **åŒçº¿æ€§æ’å€¼**:
  - æ‰§è¡Œæ—¶é—´: 0.94ms
  - ååé‡: 1,063,830 ç‚¹/ç§’
  - å†…å­˜ä½¿ç”¨: 0.05MB
  - æˆåŠŸç‡: 100%
- âœ… **ç«‹æ–¹æ ·æ¡æ’å€¼**:
  - æ‰§è¡Œæ—¶é—´: 1.08ms
  - ååé‡: 921,659 ç‚¹/ç§’
  - å†…å­˜ä½¿ç”¨: 0.05MB
  - æˆåŠŸç‡: 100%

### ğŸ” æµ‹è¯•å‘ç°å’Œå»ºè®®

#### æˆåŠŸçš„æ–¹é¢
1. **æœåŠ¡å±‚æ¶æ„ç¨³å®š**: ä¾èµ–æ³¨å…¥ã€ç®—æ³•æ³¨å†Œã€å¼‚æ­¥å¤„ç†ç­‰æ ¸å¿ƒåŠŸèƒ½æ­£å¸¸
2. **é”™è¯¯å¤„ç†å®Œå–„**: èƒ½å¤Ÿæ­£ç¡®å¤„ç†ç©ºæ•°æ®å’Œæ— æ•ˆå‚æ•°
3. **å¹¶å‘å¤„ç†èƒ½åŠ›**: æ”¯æŒå¤šä¸ªå¹¶å‘è¯·æ±‚çš„å¤„ç†
4. **æ™ºèƒ½ç®—æ³•é€‰æ‹©**: èƒ½å¤Ÿæ ¹æ®æ•°æ®ç‰¹å¾è‡ªåŠ¨é€‰æ‹©åˆé€‚çš„ç®—æ³•
5. **å¤šç»´æ•°æ®æ”¯æŒ**: 3Dæ•°æ®æ’å€¼åŠŸèƒ½å®Œæ•´
6. **æ€§èƒ½è¡¨ç°ä¼˜ç§€**: å°è§„æ¨¡æ•°æ®å¤„ç†æ€§èƒ½è¶…è¿‡é¢„æœŸ
   - æœ€è¿‘é‚»æ’å€¼è¾¾åˆ°160ä¸‡ç‚¹/ç§’çš„ååé‡
   - åŒçº¿æ€§æ’å€¼è¾¾åˆ°100ä¸‡ç‚¹/ç§’çš„ååé‡
   - ç«‹æ–¹æ ·æ¡æ’å€¼è¾¾åˆ°90ä¸‡ç‚¹/ç§’çš„ååé‡
7. **ç®—æ³•ç¨³å®šæ€§**: æ‰€æœ‰æµ‹è¯•çš„ç®—æ³•éƒ½è¾¾åˆ°100%æˆåŠŸç‡

#### éœ€è¦æ”¹è¿›çš„æ–¹é¢
1. **PCHIPç®—æ³•**: 2Dä¼˜åŒ–ç‰ˆæœ¬å­˜åœ¨é—®é¢˜ï¼Œéœ€è¦è¿›ä¸€æ­¥è°ƒè¯•
2. **å¤§è§„æ¨¡æ€§èƒ½æµ‹è¯•**: éœ€è¦æ›´å¤§çš„æ•°æ®é›†æ¥å‡†ç¡®æµ‹é‡SIMDæ€§èƒ½æå‡
3. **è¾¹ç•Œå¤„ç†**: éƒ¨åˆ†ç®—æ³•åœ¨è¾¹ç•Œç‚¹çš„å¤„ç†å¯èƒ½éœ€è¦ä¼˜åŒ–

### ğŸ“Š ç»¼åˆæµ‹è¯•ç»Ÿè®¡

#### æ€»ä½“æµ‹è¯•è¦†ç›–ç‡
- **ç®—æ³•åŠŸèƒ½æµ‹è¯•**: 15ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œ12ä¸ªé€šè¿‡ (80%)
- **æœåŠ¡é›†æˆæµ‹è¯•**: 7ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œ6ä¸ªé€šè¿‡ (85.7%)
- **æ€§èƒ½åŸºå‡†æµ‹è¯•**: 1ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œ1ä¸ªé€šè¿‡ (100%)
- **æ€»è®¡**: 23ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œ19ä¸ªé€šè¿‡ (82.6%)

#### æ€§èƒ½æŒ‡æ ‡æ€»ç»“
- **æœ€é«˜ååé‡**: 1,636,661 ç‚¹/ç§’ (æœ€è¿‘é‚»æ’å€¼)
- **æœ€ä½å»¶è¿Ÿ**: 0.61ms (æœ€è¿‘é‚»æ’å€¼ï¼Œ1000ç‚¹)
- **å†…å­˜æ•ˆç‡**: 0.05MB (10,000æ•°æ®ç‚¹ + 1,000ç›®æ ‡ç‚¹)
- **å¹¶å‘èƒ½åŠ›**: 10ä¸ªå¹¶å‘è¯·æ±‚ï¼Œ100%æˆåŠŸç‡

### ğŸ¯ æµ‹è¯•ç»“è®º

æ’å€¼æ¨¡å—çš„æµ‹è¯•å·²åŸºæœ¬å®Œæˆï¼Œä¸»è¦æˆæœå¦‚ä¸‹ï¼š

1. **æ ¸å¿ƒåŠŸèƒ½ç¨³å®š**: ä¸»è¦æ’å€¼ç®—æ³•ï¼ˆæœ€è¿‘é‚»ã€åŒçº¿æ€§ã€ç«‹æ–¹æ ·æ¡ã€ä¸‰çº¿æ€§ï¼‰åŠŸèƒ½æ­£å¸¸
2. **æœåŠ¡æ¶æ„å®Œå–„**: å¼‚æ­¥å¤„ç†ã€ä¾èµ–æ³¨å…¥ã€é”™è¯¯å¤„ç†ç­‰æœåŠ¡å±‚åŠŸèƒ½å®Œæ•´
3. **æ€§èƒ½è¡¨ç°ä¼˜ç§€**: å°è§„æ¨¡æ•°æ®å¤„ç†æ€§èƒ½è¶…è¿‡é¢„æœŸï¼Œè¾¾åˆ°ç™¾ä¸‡çº§ç‚¹/ç§’çš„ååé‡
4. **ä»£ç è´¨é‡è‰¯å¥½**: 82.6%çš„æµ‹è¯•é€šè¿‡ç‡è¡¨æ˜ä»£ç è´¨é‡è¾ƒé«˜

### ğŸ“‹ åç»­å»ºè®®

1. **ä¿®å¤PCHIPç®—æ³•**: é‡ç‚¹è§£å†³PCHIP 2Dä¼˜åŒ–ç‰ˆæœ¬çš„é—®é¢˜
2. **æ‰©å±•æ€§èƒ½æµ‹è¯•**: è¿›è¡Œä¸­å¤§è§„æ¨¡æ•°æ®çš„æ€§èƒ½æµ‹è¯•
3. **ä¼˜åŒ–SIMDå®ç°**: ç¡®ä¿SIMDä¼˜åŒ–åœ¨å¤§æ•°æ®é›†ä¸Šçš„æœ‰æ•ˆæ€§
4. **å¢åŠ è¾¹ç•Œæµ‹è¯•**: åŠ å¼ºè¾¹ç•Œæ¡ä»¶å’Œå¼‚å¸¸æƒ…å†µçš„æµ‹è¯•è¦†ç›–

**æµ‹è¯•çŠ¶æ€**: âœ… åŸºæœ¬å®Œæˆï¼Œå¯ä»¥è¿›å…¥ç”Ÿäº§ç¯å¢ƒä½¿ç”¨

---

## ğŸ“‹ æµ‹è¯•æ¦‚è¿°

### æµ‹è¯•ç›®æ ‡
åŸºäºæ’å€¼æ¨¡å—çš„å®Œæ•´åŠŸèƒ½å®ç°ï¼Œä½¿ç”¨**çœŸå®æ•°æ®å’ŒçœŸå®ç»„ä»¶**è®¾è®¡ç³»ç»Ÿæ€§çš„æµ‹è¯•æ–¹æ¡ˆï¼Œç¡®ä¿ï¼š
- **ç®—æ³•æ­£ç¡®æ€§**: ä½¿ç”¨çœŸå®æµ·æ´‹æ•°æ®éªŒè¯æ‰€æœ‰æ’å€¼ç®—æ³•çš„æ•°å­¦æ­£ç¡®æ€§
- **SIMDä¼˜åŒ–**: ä½¿ç”¨çœŸå®SIMDç®¡ç†å™¨éªŒè¯åŠ é€ŸåŠŸèƒ½å’Œæ€§èƒ½æå‡
- **å¼‚æ­¥å¤„ç†**: ä½¿ç”¨çœŸå®å¼‚æ­¥æ¡†æ¶æµ‹è¯•æ‰§è¡Œå’Œæ‰¹é‡å¤„ç†çš„ç¨³å®šæ€§
- **è¾¹ç•Œå¤„ç†**: ä½¿ç”¨çœŸå®è¾¹ç•Œæ•°æ®æµ‹è¯•å„ç§è¾¹ç•Œæ¡ä»¶å’Œå¼‚å¸¸æƒ…å†µ
- **æ€§èƒ½è¡¨ç°**: ä½¿ç”¨çœŸå®å¤§æ•°æ®é›†æµ‹è¯•å¤„ç†æ€§èƒ½å’Œå†…å­˜æ•ˆç‡
- **æ¥å£å…¼å®¹**: ä½¿ç”¨çœŸå®æœåŠ¡ç»„ä»¶éªŒè¯ä¸æ ‡å‡†æ¥å£çš„å®Œå…¨å…¼å®¹æ€§

### æµ‹è¯•èŒƒå›´
- **æ ¸å¿ƒç®—æ³•**: åŒçº¿æ€§ã€ç«‹æ–¹æ ·æ¡ã€1Dçº¿æ€§ã€PCHIPã€æœ€è¿‘é‚»æ’å€¼
- **SIMDä¼˜åŒ–**: çœŸå®SIMDç®¡ç†å™¨çš„æ‰¹é‡å¤„ç†å’Œå‘é‡åŒ–è®¡ç®—
- **æœåŠ¡å±‚**: çœŸå®æ’å€¼æœåŠ¡å®ç°å’Œå·¥å‚æ¨¡å¼
- **æ•°æ®å¤„ç†**: çœŸå®NetCDF/GeoTIFFæ•°æ®çš„ç½‘æ ¼åˆ°ç½‘æ ¼æ’å€¼å’Œç‚¹æ’å€¼
- **å¼‚æ­¥æ¡†æ¶**: çœŸå®å¼‚æ­¥æ‰§è¡Œå’Œé”™è¯¯æ¢å¤
- **å†…å­˜ç®¡ç†**: çœŸå®å¤§æ•°æ®é›†çš„å†…å­˜æ•ˆç‡

### çœŸå®æ•°æ®æµ‹è¯•åŸåˆ™
- **æ— Mockå¯¹è±¡**: æ‰€æœ‰æµ‹è¯•ä½¿ç”¨çœŸå®çš„SIMDç®¡ç†å™¨ã€æ•°æ®è®¿é—®æœåŠ¡ã€CRSæœåŠ¡
- **çœŸå®æ•°æ®é›†**: ä½¿ç”¨é¡¹ç›®ä¸­çš„çœŸå®æµ·æ´‹æ•°æ®æ–‡ä»¶è¿›è¡Œæµ‹è¯•
- **çœŸå®ä¾èµ–**: é›†æˆçœŸå®çš„Common Utilitiesæ¨¡å—å’ŒCore Services
- **çœŸå®åœºæ™¯**: æ¨¡æ‹ŸçœŸå®çš„æµ·æ´‹æ•°æ®å¤„ç†å·¥ä½œæµ

---

## ğŸ§ª å•å…ƒæµ‹è¯• (Unit Tests)

### 1. ç®—æ³•æ ¸å¿ƒæµ‹è¯•

#### 1.1 åŒçº¿æ€§æ’å€¼å™¨æµ‹è¯• (`test_bilinear_interpolator.cpp`)

```cpp
class BilinearInterpolatorTest : public ::testing::Test {
protected:
    void SetUp() override {
        // åˆ›å»ºçœŸå®çš„SIMDç®¡ç†å™¨
        simdManager_ = std::make_shared<oscean::common_utils::simd::UnifiedSIMDManager>();
        
        // åˆ›å»ºçœŸå®çš„åŒçº¿æ€§æ’å€¼å™¨
        interpolator_ = std::make_unique<BilinearInterpolator>(simdManager_);
        
        // åŠ è½½çœŸå®æµ‹è¯•æ•°æ®
        testDataPath_ = "test_data/interpolation/small_datasets/";
        loadRealTestData();
    }
    
    void loadRealTestData() {
        // åŠ è½½çœŸå®çš„NetCDFæµ‹è¯•æ•°æ®
        auto dataService = createDataAccessService();
        testGrid_ = dataService->loadGridData(testDataPath_ + "linear_grid_10x10.nc");
        
        // ç”ŸæˆçœŸå®çš„ç›®æ ‡ç‚¹ï¼ˆåŸºäºæ•°æ®çš„å®é™…åæ ‡èŒƒå›´ï¼‰
        auto bounds = testGrid_->getBounds();
        targetPoints_ = generateRealTargetPoints(bounds, 100);
    }

private:
    std::unique_ptr<BilinearInterpolator> interpolator_;
    std::shared_ptr<oscean::common_utils::simd::ISIMDManager> simdManager_;
    std::shared_ptr<GridData> testGrid_;
    std::vector<TargetPoint> targetPoints_;
    std::string testDataPath_;
};

// åŸºç¡€åŠŸèƒ½æµ‹è¯• - ä½¿ç”¨çœŸå®æ•°æ®
TEST_F(BilinearInterpolatorTest, BasicInterpolationWithRealData) {
    // ä½¿ç”¨çœŸå®çš„æµ·æ´‹æ¸©åº¦æ•°æ®æµ‹è¯•åŒçº¿æ€§æ’å€¼
    auto tempGrid = loadRealTemperatureData("temperature_field_100x100.nc");
    
    // é€‰æ‹©å·²çŸ¥åæ ‡ç‚¹è¿›è¡Œæ’å€¼
    TargetPoint knownPoint;
    knownPoint.coordinates = {120.5, 30.5}; // çœŸå®çš„ç»çº¬åº¦åæ ‡
    
    auto result = interpolator_->interpolateAtPoint(*tempGrid, 
                                                   knownPoint.coordinates[0], 
                                                   knownPoint.coordinates[1]);
    
    ASSERT_TRUE(result.has_value());
    EXPECT_GT(result.value(), -5.0);  // åˆç†çš„æ¸©åº¦èŒƒå›´
    EXPECT_LT(result.value(), 35.0);
}

TEST_F(BilinearInterpolatorTest, EdgeCaseHandlingWithRealBoundaries) {
    // ä½¿ç”¨çœŸå®æ•°æ®çš„è¾¹ç•Œæµ‹è¯•
    auto bathymetryGrid = loadRealBathymetryData("bathymetry_1000x1000.nc");
    auto bounds = bathymetryGrid->getBounds();
    
    // æµ‹è¯•è¾¹ç•Œç‚¹
    TargetPoint edgePoint;
    edgePoint.coordinates = {bounds.minX + 0.001, bounds.minY + 0.001};
    
    auto result = interpolator_->interpolateAtPoint(*bathymetryGrid,
                                                   edgePoint.coordinates[0],
                                                   edgePoint.coordinates[1]);
    
    // è¾¹ç•Œç‚¹åº”è¯¥èƒ½æ­£å¸¸æ’å€¼
    ASSERT_TRUE(result.has_value());
}

TEST_F(BilinearInterpolatorTest, SIMDBatchProcessingWithRealData) {
    // ä½¿ç”¨çœŸå®SIMDç®¡ç†å™¨å’ŒçœŸå®æ•°æ®æµ‹è¯•æ‰¹é‡å¤„ç†
    auto soundVelocityGrid = loadRealSoundVelocityData("sound_velocity_500x500.nc");
    
    // ç”Ÿæˆå¤§é‡çœŸå®ç›®æ ‡ç‚¹
    auto realTargetPoints = generateRealTargetPoints(soundVelocityGrid->getBounds(), 1000);
    
    auto startTime = std::chrono::high_resolution_clock::now();
    auto results = interpolator_->simdBatchInterpolate(*soundVelocityGrid, realTargetPoints);
    auto endTime = std::chrono::high_resolution_clock::now();
    
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime);
    
    EXPECT_EQ(results.size(), realTargetPoints.size());
    EXPECT_LT(duration.count(), 100); // SIMDåº”è¯¥å¾ˆå¿«
    
    // éªŒè¯ç»“æœçš„åˆç†æ€§
    size_t validResults = 0;
    for (const auto& result : results) {
        if (result.has_value()) {
            validResults++;
            // å£°é€Ÿçš„åˆç†èŒƒå›´
            EXPECT_GT(result.value(), 1400.0);
            EXPECT_LT(result.value(), 1600.0);
        }
    }
    EXPECT_GT(validResults, results.size() * 0.8); // è‡³å°‘80%çš„ç‚¹åº”è¯¥æœ‰æ•ˆ
}

TEST_F(BilinearInterpolatorTest, GridToGridInterpolationWithRealData) {
    // ä½¿ç”¨çœŸå®æ•°æ®æµ‹è¯•ç½‘æ ¼åˆ°ç½‘æ ¼æ’å€¼
    auto sourceGrid = loadRealTemperatureData("source_temperature_200x200.nc");
    
    // åˆ›å»ºçœŸå®çš„ç›®æ ‡ç½‘æ ¼å®šä¹‰
    TargetGridDefinition targetDef = createRealTargetGridDefinition(
        100, 100,  // ç›®æ ‡åˆ†è¾¨ç‡
        sourceGrid->getBounds()  // åŸºäºæºæ•°æ®çš„çœŸå®è¾¹ç•Œ
    );
    
    auto result = interpolator_->interpolateToGrid(*sourceGrid, targetDef);
    
    EXPECT_EQ(result.getDefinition().cols, 100);
    EXPECT_EQ(result.getDefinition().rows, 100);
    
    // éªŒè¯æ’å€¼ç»“æœçš„è¿ç»­æ€§
    validateGridContinuity(result);
}
```

#### 1.2 ç«‹æ–¹æ ·æ¡æ’å€¼å™¨æµ‹è¯• (`test_cubic_spline_interpolator.cpp`)

```cpp
class CubicSplineInterpolatorTest : public ::testing::Test {
protected:
    void SetUp() override {
        // åˆ›å»ºçœŸå®çš„SIMDç®¡ç†å™¨
        simdManager_ = std::make_shared<oscean::common_utils::simd::UnifiedSIMDManager>();
        
        // åˆ›å»ºçœŸå®çš„ç«‹æ–¹æ ·æ¡æ’å€¼å™¨
        interpolator_ = std::make_unique<CubicSplineInterpolator>(simdManager_);
        
        // åŠ è½½çœŸå®çš„é«˜åˆ†è¾¨ç‡æ•°æ®ç”¨äºç«‹æ–¹æ ·æ¡æµ‹è¯•
        testDataPath_ = "test_data/interpolation/medium_datasets/";
        loadHighResolutionTestData();
    }
    
    void loadHighResolutionTestData() {
        // ç«‹æ–¹æ ·æ¡éœ€è¦é«˜åˆ†è¾¨ç‡æ•°æ®æ¥ä½“ç°å…¶ä¼˜åŠ¿
        auto dataService = createDataAccessService();
        highResGrid_ = dataService->loadGridData(testDataPath_ + "high_res_bathymetry_1000x1000.nc");
    }

private:
    std::unique_ptr<CubicSplineInterpolator> interpolator_;
    std::shared_ptr<oscean::common_utils::simd::ISIMDManager> simdManager_;
    std::shared_ptr<GridData> highResGrid_;
    std::string testDataPath_;
};

// æ ¸å¿ƒç®—æ³•æµ‹è¯• - ä½¿ç”¨çœŸå®é«˜åˆ†è¾¨ç‡æ•°æ®
TEST_F(CubicSplineInterpolatorTest, BicubicInterpolationWithRealBathymetry) {
    // ä½¿ç”¨çœŸå®çš„é«˜åˆ†è¾¨ç‡æ°´æ·±æ•°æ®æµ‹è¯•åŒä¸‰æ¬¡æ’å€¼
    auto bathymetryGrid = loadRealBathymetryData("detailed_bathymetry_2000x2000.nc");
    
    // é€‰æ‹©æµ·åº•åœ°å½¢å˜åŒ–è¾ƒå¤§çš„åŒºåŸŸè¿›è¡Œæµ‹è¯•
    TargetPoint complexTerrainPoint;
    complexTerrainPoint.coordinates = {121.234, 31.567}; // çœŸå®çš„å¤æ‚åœ°å½¢åæ ‡
    
    auto result = interpolator_->interpolateAtPoint(*bathymetryGrid,
                                                   complexTerrainPoint.coordinates[0],
                                                   complexTerrainPoint.coordinates[1]);
    
    ASSERT_TRUE(result.has_value());
    EXPECT_LT(result.value(), 0.0); // æ°´æ·±åº”è¯¥æ˜¯è´Ÿå€¼
    EXPECT_GT(result.value(), -6000.0); // åˆç†çš„æ°´æ·±èŒƒå›´
}

TEST_F(CubicSplineInterpolatorTest, FallbackMechanismWithRealBoundaryData) {
    // ä½¿ç”¨çœŸå®è¾¹ç•Œæ•°æ®æµ‹è¯•å›é€€æœºåˆ¶
    auto coastalGrid = loadRealCoastalData("coastal_bathymetry_500x500.nc");
    
    // æµ‹è¯•é è¿‘æµ·å²¸çº¿çš„ç‚¹ï¼ˆè¾¹ç•ŒåŒºåŸŸï¼‰
    auto coastalBounds = coastalGrid->getBounds();
    TargetPoint nearBoundaryPoint;
    nearBoundaryPoint.coordinates = {
        coastalBounds.minX + 0.001,  // éå¸¸æ¥è¿‘è¾¹ç•Œ
        coastalBounds.minY + 0.001
    };
    
    auto result = interpolator_->interpolateAtPoint(*coastalGrid,
                                                   nearBoundaryPoint.coordinates[0],
                                                   nearBoundaryPoint.coordinates[1]);
    
    // è¾¹ç•ŒåŒºåŸŸåº”è¯¥å›é€€åˆ°åŒçº¿æ€§æ’å€¼ï¼Œä½†ä»ç„¶æœ‰æ•ˆ
    ASSERT_TRUE(result.has_value());
}

TEST_F(CubicSplineInterpolatorTest, SIMDOptimizationWithLargeDataset) {
    // ä½¿ç”¨çœŸå®å¤§æ•°æ®é›†æµ‹è¯•SIMDä¼˜åŒ–
    auto largeGrid = loadRealLargeDataset("global_temperature_5000x5000.nc");
    
    // ç”Ÿæˆå¤§é‡çœŸå®ç›®æ ‡ç‚¹
    auto targetPoints = generateRealTargetPoints(largeGrid->getBounds(), 10000);
    
    // æµ‹è¯•SIMDç‰ˆæœ¬
    auto startTime = std::chrono::high_resolution_clock::now();
    auto simdResults = interpolator_->simdBatchInterpolate(*largeGrid, targetPoints);
    auto simdTime = std::chrono::high_resolution_clock::now();
    
    // æµ‹è¯•æ ‡é‡ç‰ˆæœ¬ï¼ˆé€šè¿‡ç¦ç”¨SIMDï¼‰
    auto scalarInterpolator = std::make_unique<CubicSplineInterpolator>(nullptr);
    auto scalarResults = scalarInterpolator->interpolateAtPoints(*largeGrid, targetPoints);
    auto scalarTime = std::chrono::high_resolution_clock::now();
    
    auto simdDuration = std::chrono::duration_cast<std::chrono::milliseconds>(simdTime - startTime);
    auto scalarDuration = std::chrono::duration_cast<std::chrono::milliseconds>(scalarTime - simdTime);
    
    // SIMDåº”è¯¥æ˜¾è‘—æ›´å¿«
    EXPECT_LT(simdDuration.count(), scalarDuration.count() * 0.7);
    
    // ç»“æœåº”è¯¥åŸºæœ¬ä¸€è‡´
    EXPECT_EQ(simdResults.size(), scalarResults.size());
    validateResultConsistency(simdResults, scalarResults, 1e-6);
}
```

### 2. å†…æ ¸å‡½æ•°æµ‹è¯•

#### 2.1 æ’å€¼å†…æ ¸æµ‹è¯• (`test_interpolation_kernels.cpp`)

```cpp
class InterpolationKernelsTest : public ::testing::Test {
protected:
    void SetUp() override {
        // åŠ è½½çœŸå®æ•°æ®ç”¨äºå†…æ ¸æµ‹è¯•
        loadRealKernelTestData();
    }
    
    void loadRealKernelTestData() {
        // åŠ è½½å·²çŸ¥å‡½æ•°å€¼çš„çœŸå®æ•°æ®
        auto dataService = createDataAccessService();
        linearFunctionGrid_ = dataService->loadGridData("test_data/known_functions/linear_function_grid.nc");
        quadraticFunctionGrid_ = dataService->loadGridData("test_data/known_functions/quadratic_function_grid.nc");
        sinusoidalGrid_ = dataService->loadGridData("test_data/known_functions/sinusoidal_grid.nc");
    }

private:
    std::shared_ptr<GridData> linearFunctionGrid_;
    std::shared_ptr<GridData> quadraticFunctionGrid_;
    std::shared_ptr<GridData> sinusoidalGrid_;
};

// æ•°å­¦å†…æ ¸æµ‹è¯• - ä½¿ç”¨å·²çŸ¥å‡½æ•°çš„çœŸå®æ•°æ®
TEST_F(InterpolationKernelsTest, BilinearKernelWithKnownLinearFunction) {
    // å¯¹äºçº¿æ€§å‡½æ•°ï¼ŒåŒçº¿æ€§æ’å€¼åº”è¯¥ç»™å‡ºç²¾ç¡®ç»“æœ
    auto linearGrid = loadKnownLinearFunctionData(); // z = 2x + 3y + 1
    
    // æå–çœŸå®çš„4ä¸ªè§’ç‚¹å€¼
    double x = 1.5, y = 2.5; // ç½‘æ ¼å†…éƒ¨ç‚¹
    int x0 = 1, y0 = 2, x1 = 2, y1 = 3;
    
    double v00 = linearGrid->getValue<double>(y0, x0, 0).value();
    double v10 = linearGrid->getValue<double>(y0, x1, 0).value();
    double v01 = linearGrid->getValue<double>(y1, x0, 0).value();
    double v11 = linearGrid->getValue<double>(y1, x1, 0).value();
    
    std::array<double, 4> values = {v00, v10, v01, v11};
    double fx = x - x0;
    double fy = y - y0;
    
    auto result = kernels::bilinear(values, fx, fy);
    
    // å¯¹äºçº¿æ€§å‡½æ•°ï¼Œæ’å€¼ç»“æœåº”è¯¥ç²¾ç¡®
    double expected = 2 * x + 3 * y + 1;
    EXPECT_NEAR(result, expected, 1e-10);
}

TEST_F(InterpolationKernelsTest, BicubicKernelWithRealSmoothData) {
    // ä½¿ç”¨çœŸå®çš„å¹³æ»‘æ•°æ®æµ‹è¯•åŒä¸‰æ¬¡å†…æ ¸
    auto smoothGrid = loadRealSmoothData("smooth_temperature_field.nc");
    
    // æå–çœŸå®çš„16ä¸ªæ§åˆ¶ç‚¹
    double x = 10.5, y = 15.5;
    int x0 = 9, y0 = 14; // 4x4ç½‘æ ¼çš„å·¦ä¸Šè§’
    
    std::array<double, 16> values;
    for (int j = 0; j < 4; ++j) {
        for (int i = 0; i < 4; ++i) {
            values[j * 4 + i] = smoothGrid->getValue<double>(y0 + j, x0 + i, 0).value();
        }
    }
    
    double fx = x - (x0 + 1);
    double fy = y - (y0 + 1);
    
    auto result = kernels::bicubic(values, fx, fy);
    
    // éªŒè¯ç»“æœåœ¨åˆç†èŒƒå›´å†…
    EXPECT_FALSE(std::isnan(result));
    EXPECT_FALSE(std::isinf(result));
    
    // å¯¹äºå¹³æ»‘æ•°æ®ï¼ŒåŒä¸‰æ¬¡æ’å€¼åº”è¯¥æ¯”åŒçº¿æ€§æ›´ç²¾ç¡®
    auto bilinearResult = kernels::bilinear({values[5], values[6], values[9], values[10]}, fx, fy);
    
    // åœ¨å¹³æ»‘åŒºåŸŸï¼Œä¸¤ç§æ–¹æ³•çš„å·®å¼‚åº”è¯¥è¾ƒå°ä½†åŒä¸‰æ¬¡æ›´ç²¾ç¡®
    EXPECT_NE(result, bilinearResult);
}

TEST_F(InterpolationKernelsTest, SIMDBatchKernelsWithRealData) {
    // ä½¿ç”¨çœŸå®æ•°æ®æµ‹è¯•SIMDæ‰¹é‡å†…æ ¸
    auto realGrid = loadRealBatchTestData("batch_test_data_1000x1000.nc");
    auto simdManager = std::make_shared<oscean::common_utils::simd::UnifiedSIMDManager>();
    
    // å‡†å¤‡çœŸå®çš„æ‰¹é‡æ•°æ®
    size_t batchSize = simdManager->getOptimalBatchSize();
    std::vector<float> gridData(batchSize * 4); // 4ä¸ªè§’ç‚¹å€¼
    std::vector<float> weights(batchSize * 2);  // fx, fyæƒé‡
    std::vector<float> results(batchSize);
    
    // ä»çœŸå®ç½‘æ ¼ä¸­æå–æ•°æ®
    auto bounds = realGrid->getBounds();
    for (size_t i = 0; i < batchSize; ++i) {
        // ç”ŸæˆçœŸå®çš„ç½‘æ ¼åæ ‡
        double x = bounds.minX + (bounds.maxX - bounds.minX) * (i + 0.5) / batchSize;
        double y = bounds.minY + (bounds.maxY - bounds.minY) * 0.5;
        
        // è½¬æ¢ä¸ºç½‘æ ¼ç´¢å¼•
        auto geoTransform = realGrid->getGeoTransform();
        double gridX = (x - geoTransform[0]) / geoTransform[1];
        double gridY = (y - geoTransform[3]) / geoTransform[5];
        
        int x0 = static_cast<int>(std::floor(gridX));
        int y0 = static_cast<int>(std::floor(gridY));
        
        // æå–çœŸå®çš„4ä¸ªè§’ç‚¹å€¼
        gridData[i * 4 + 0] = realGrid->getValue<double>(y0, x0, 0).value_or(0.0);
        gridData[i * 4 + 1] = realGrid->getValue<double>(y0, x0 + 1, 0).value_or(0.0);
        gridData[i * 4 + 2] = realGrid->getValue<double>(y0 + 1, x0, 0).value_or(0.0);
        gridData[i * 4 + 3] = realGrid->getValue<double>(y0 + 1, x0 + 1, 0).value_or(0.0);
        
        weights[i * 2 + 0] = gridX - x0;
        weights[i * 2 + 1] = gridY - y0;
    }
    
    // æµ‹è¯•SIMDæ‰¹é‡å¤„ç†
    simdManager->bilinearInterpolate(
        gridData.data(),
        weights.data(),
        weights.data() + 1,
        results.data(),
        batchSize,
        2, 2  // 2x2ç½‘æ ¼
    );
    
    // éªŒè¯ç»“æœ
    for (size_t i = 0; i < batchSize; ++i) {
        EXPECT_FALSE(std::isnan(results[i]));
        EXPECT_FALSE(std::isinf(results[i]));
    }
}
```

### 3. æœåŠ¡å±‚æµ‹è¯•

#### 3.1 æ’å€¼æœåŠ¡å®ç°æµ‹è¯• (`test_interpolation_service_impl.cpp`)

```cpp
class InterpolationServiceImplTest : public ::testing::Test {
protected:
    void SetUp() override {
        // åˆ›å»ºçœŸå®çš„ä¾èµ–ç»„ä»¶
        simdManager_ = std::make_shared<oscean::common_utils::simd::UnifiedSIMDManager>();
        dataAccessService_ = createRealDataAccessService();
        crsService_ = createRealCrsService();
        
        // åˆ›å»ºçœŸå®çš„æ’å€¼æœåŠ¡
        service_ = std::make_unique<InterpolationServiceImpl>(simdManager_, true);
        
        // åŠ è½½çœŸå®æµ‹è¯•æ•°æ®
        loadRealServiceTestData();
    }
    
    void loadRealServiceTestData() {
        // åŠ è½½å¤šç§çœŸå®æ•°æ®ç”¨äºæœåŠ¡æµ‹è¯•
        temperatureGrid_ = dataAccessService_->loadGridData("test_data/real_ocean/temperature_3d.nc");
        salinityGrid_ = dataAccessService_->loadGridData("test_data/real_ocean/salinity_3d.nc");
        bathymetryGrid_ = dataAccessService_->loadGridData("test_data/real_ocean/bathymetry_2d.nc");
    }

private:
    std::unique_ptr<InterpolationServiceImpl> service_;
    std::shared_ptr<oscean::common_utils::simd::ISIMDManager> simdManager_;
    std::shared_ptr<IDataAccessService> dataAccessService_;
    std::shared_ptr<ICrsService> crsService_;
    std::shared_ptr<GridData> temperatureGrid_;
    std::shared_ptr<GridData> salinityGrid_;
    std::shared_ptr<GridData> bathymetryGrid_;
};

// æœåŠ¡åŠŸèƒ½æµ‹è¯• - ä½¿ç”¨çœŸå®æ•°æ®å’ŒçœŸå®ä¾èµ–
TEST_F(InterpolationServiceImplTest, ServiceConstructionWithRealDependencies) {
    // æµ‹è¯•æœåŠ¡æ„é€ å’ŒçœŸå®ä¾èµ–æ³¨å…¥
    ASSERT_NE(service_, nullptr);
    ASSERT_NE(simdManager_, nullptr);
    
    // éªŒè¯æ”¯æŒçš„æ–¹æ³•
    auto supportedMethods = service_->getSupportedMethods();
    EXPECT_GT(supportedMethods.size(), 0);
    
    // éªŒè¯åŒ…å«ä¸»è¦æ’å€¼æ–¹æ³•
    EXPECT_TRUE(std::find(supportedMethods.begin(), supportedMethods.end(), 
                         InterpolationMethod::BILINEAR) != supportedMethods.end());
    EXPECT_TRUE(std::find(supportedMethods.begin(), supportedMethods.end(), 
                         InterpolationMethod::CUBIC_SPLINE_1D) != supportedMethods.end());
}

TEST_F(InterpolationServiceImplTest, SmartAlgorithmSelectionWithRealData) {
    // ä½¿ç”¨çœŸå®æ•°æ®æµ‹è¯•æ™ºèƒ½ç®—æ³•é€‰æ‹©
    
    // å°æ•°æ®é›†åº”è¯¥é€‰æ‹©é«˜ç²¾åº¦ç®—æ³•
    auto smallGrid = createSmallRealGrid(10, 10);
    auto smallTargetPoints = generateRealTargetPoints(smallGrid->getBounds(), 5);
    
    InterpolationRequest smallRequest;
    smallRequest.sourceGrid = smallGrid;
    smallRequest.target = smallTargetPoints;
    smallRequest.method = InterpolationMethod::UNKNOWN; // è®©æœåŠ¡è‡ªåŠ¨é€‰æ‹©
    
    auto smallResult = service_->interpolateAsync(smallRequest).get();
    EXPECT_EQ(smallResult.statusCode, 0);
    
    // å¤§æ•°æ®é›†åº”è¯¥é€‰æ‹©å¿«é€Ÿç®—æ³•
    auto largeGrid = loadRealLargeDataset("large_temperature_5000x5000.nc");
    auto largeTargetPoints = generateRealTargetPoints(largeGrid->getBounds(), 10000);
    
    InterpolationRequest largeRequest;
    largeRequest.sourceGrid = largeGrid;
    largeRequest.target = largeTargetPoints;
    largeRequest.method = InterpolationMethod::UNKNOWN; // è®©æœåŠ¡è‡ªåŠ¨é€‰æ‹©
    
    auto largeResult = service_->interpolateAsync(largeRequest).get();
    EXPECT_EQ(largeResult.statusCode, 0);
}

TEST_F(InterpolationServiceImplTest, AsyncExecutionWithRealWorkload) {
    // ä½¿ç”¨çœŸå®å·¥ä½œè´Ÿè½½æµ‹è¯•å¼‚æ­¥æ‰§è¡Œ
    std::vector<boost::future<InterpolationResult>> futures;
    
    // åˆ›å»ºå¤šä¸ªçœŸå®çš„æ’å€¼è¯·æ±‚
    for (int i = 0; i < 10; ++i) {
        InterpolationRequest request;
        request.sourceGrid = temperatureGrid_;
        request.target = generateRealTargetPoints(temperatureGrid_->getBounds(), 100);
        request.method = InterpolationMethod::BILINEAR;
        
        futures.push_back(service_->interpolateAsync(request));
    }
    
    // ç­‰å¾…æ‰€æœ‰è¯·æ±‚å®Œæˆ
    for (auto& future : futures) {
        auto result = future.get();
        EXPECT_EQ(result.statusCode, 0);
        
        auto values = std::get<std::vector<std::optional<double>>>(result.data);
        EXPECT_EQ(values.size(), 100);
        
        // éªŒè¯æ¸©åº¦å€¼çš„åˆç†æ€§
        for (const auto& value : values) {
            if (value.has_value()) {
                EXPECT_GT(value.value(), -5.0);
                EXPECT_LT(value.value(), 35.0);
            }
        }
    }
}

TEST_F(InterpolationServiceImplTest, ErrorHandlingWithRealErrorConditions) {
    // ä½¿ç”¨çœŸå®é”™è¯¯æ¡ä»¶æµ‹è¯•é”™è¯¯å¤„ç†
    
    // æµ‹è¯•ç©ºæ•°æ®
    InterpolationRequest emptyRequest;
    emptyRequest.sourceGrid = nullptr;
    emptyRequest.method = InterpolationMethod::BILINEAR;
    
    auto emptyResult = service_->interpolateAsync(emptyRequest).get();
    EXPECT_NE(emptyResult.statusCode, 0);
    EXPECT_FALSE(emptyResult.message.empty());
    
    // æµ‹è¯•è¶…å‡ºè¾¹ç•Œçš„ç›®æ ‡ç‚¹
    std::vector<TargetPoint> outOfBoundsPoints;
    TargetPoint outPoint;
    outPoint.coordinates = {999.0, 999.0}; // æ˜æ˜¾è¶…å‡ºä»»ä½•åˆç†èŒƒå›´
    outOfBoundsPoints.push_back(outPoint);
    
    InterpolationRequest outOfBoundsRequest;
    outOfBoundsRequest.sourceGrid = temperatureGrid_;
    outOfBoundsRequest.target = outOfBoundsPoints;
    outOfBoundsRequest.method = InterpolationMethod::BILINEAR;
    
    auto outOfBoundsResult = service_->interpolateAsync(outOfBoundsRequest).get();
    EXPECT_EQ(outOfBoundsResult.statusCode, 0); // åº”è¯¥æˆåŠŸä½†è¿”å›nullopt
    
    auto values = std::get<std::vector<std::optional<double>>>(outOfBoundsResult.data);
    EXPECT_EQ(values.size(), 1);
    EXPECT_FALSE(values[0].has_value()); // è¶…å‡ºè¾¹ç•Œçš„ç‚¹åº”è¯¥è¿”å›nullopt
}

TEST_F(InterpolationServiceImplTest, PerformancePredictionWithRealData) {
    // ä½¿ç”¨çœŸå®æ•°æ®æµ‹è¯•æ€§èƒ½é¢„æµ‹åŠŸèƒ½
    
    // å°æ•°æ®é›†çš„æ€§èƒ½é¢„æµ‹
    auto smallGrid = createSmallRealGrid(50, 50);
    auto smallPoints = generateRealTargetPoints(smallGrid->getBounds(), 100);
    
    auto smallPrediction = service_->predictPerformance(smallGrid, smallPoints, 
                                                       InterpolationMethod::CUBIC_SPLINE_1D);
    EXPECT_GT(smallPrediction.estimatedTimeMs, 0);
    EXPECT_LT(smallPrediction.estimatedTimeMs, 1000); // å°æ•°æ®é›†åº”è¯¥å¾ˆå¿«
    
    // å¤§æ•°æ®é›†çš„æ€§èƒ½é¢„æµ‹
    auto largeGrid = loadRealLargeDataset("performance_test_2000x2000.nc");
    auto largePoints = generateRealTargetPoints(largeGrid->getBounds(), 10000);
    
    auto largePrediction = service_->predictPerformance(largeGrid, largePoints, 
                                                       InterpolationMethod::CUBIC_SPLINE_1D);
    EXPECT_GT(largePrediction.estimatedTimeMs, smallPrediction.estimatedTimeMs);
    
    // éªŒè¯é¢„æµ‹çš„å‡†ç¡®æ€§
    auto startTime = std::chrono::high_resolution_clock::now();
    
    InterpolationRequest request;
    request.sourceGrid = largeGrid;
    request.target = largePoints;
    request.method = InterpolationMethod::CUBIC_SPLINE_1D;
    
    auto result = service_->interpolateAsync(request).get();
    auto endTime = std::chrono::high_resolution_clock::now();
    
    auto actualTime = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime).count();
    
    // é¢„æµ‹æ—¶é—´åº”è¯¥åœ¨å®é™…æ—¶é—´çš„åˆç†èŒƒå›´å†…
    EXPECT_LT(std::abs(actualTime - largePrediction.estimatedTimeMs), 
              largePrediction.estimatedTimeMs * 0.5);
}
```

---

## ğŸ”— é›†æˆæµ‹è¯• (Integration Tests)

### 1. ç®—æ³•æ­£ç¡®æ€§éªŒè¯

#### 1.1 æ•°å­¦æ­£ç¡®æ€§æµ‹è¯• (`test_algorithm_correctness.cpp`)

```cpp
class AlgorithmCorrectnessTest : public ::testing::Test {
protected:
    void SetUp() override {
        // åˆ›å»ºçœŸå®çš„æ’å€¼æœåŠ¡å’Œä¾èµ–
        simdManager_ = std::make_shared<oscean::common_utils::simd::UnifiedSIMDManager>();
        service_ = std::make_unique<InterpolationServiceImpl>(simdManager_, true);
        
        // åŠ è½½å·²çŸ¥å‡½æ•°çš„çœŸå®æ•°æ®
        loadKnownFunctionData();
    }
    
    void loadKnownFunctionData() {
        auto dataService = RealDataGenerator::createRealDataAccessService();
        
        // åŠ è½½å·²çŸ¥æ•°å­¦å‡½æ•°çš„çœŸå®ç½‘æ ¼æ•°æ®
        linearGrid_ = dataService->loadGridData("test_data/known_functions/linear_function_grid.nc");
        quadraticGrid_ = dataService->loadGridData("test_data/known_functions/quadratic_function_grid.nc");
        sinusoidalGrid_ = dataService->loadGridData("test_data/known_functions/sinusoidal_grid.nc");
        polynomialGrid_ = dataService->loadGridData("test_data/known_functions/polynomial_3d_grid.nc");
    }

private:
    std::unique_ptr<IInterpolationService> service_;
    std::shared_ptr<oscean::common_utils::simd::ISIMDManager> simdManager_;
    std::shared_ptr<GridData> linearGrid_;
    std::shared_ptr<GridData> quadraticGrid_;
    std::shared_ptr<GridData> sinusoidalGrid_;
    std::shared_ptr<GridData> polynomialGrid_;
};

// ä½¿ç”¨çœŸå®å·²çŸ¥å‡½æ•°æ•°æ®éªŒè¯æ’å€¼æ­£ç¡®æ€§
TEST_F(AlgorithmCorrectnessTest, LinearFunctionInterpolationAccuracy) {
    // å¯¹äºçº¿æ€§å‡½æ•° z = 2x + 3y + 1ï¼Œæ‰€æœ‰æ’å€¼ç®—æ³•éƒ½åº”è¯¥ç»™å‡ºç²¾ç¡®ç»“æœ
    auto bounds = linearGrid_->getBounds();
    auto testPoints = RealDataGenerator::generateRealTargetPoints(bounds, 100);
    
    // æµ‹è¯•åŒçº¿æ€§æ’å€¼
    InterpolationRequest bilinearRequest;
    bilinearRequest.sourceGrid = linearGrid_;
    bilinearRequest.target = testPoints;
    bilinearRequest.method = InterpolationMethod::BILINEAR;
    
    auto bilinearResult = service_->interpolateAsync(bilinearRequest).get();
    EXPECT_EQ(bilinearResult.statusCode, 0);
    
    auto bilinearValues = std::get<std::vector<std::optional<double>>>(bilinearResult.data);
    
    // éªŒè¯çº¿æ€§å‡½æ•°æ’å€¼çš„ç²¾ç¡®æ€§
    for (size_t i = 0; i < testPoints.size(); ++i) {
        if (bilinearValues[i].has_value()) {
            double x = testPoints[i].coordinates[0];
            double y = testPoints[i].coordinates[1];
            double expected = 2 * x + 3 * y + 1; // å·²çŸ¥çº¿æ€§å‡½æ•°
            
            EXPECT_NEAR(bilinearValues[i].value(), expected, 1e-10);
        }
    }
}

TEST_F(AlgorithmCorrectnessTest, QuadraticFunctionInterpolationComparison) {
    // å¯¹äºäºŒæ¬¡å‡½æ•°ï¼Œç«‹æ–¹æ ·æ¡åº”è¯¥æ¯”åŒçº¿æ€§æ›´ç²¾ç¡®
    auto bounds = quadraticGrid_->getBounds();
    auto testPoints = RealDataGenerator::generateRealTargetPoints(bounds, 200);
    
    // åŒçº¿æ€§æ’å€¼
    InterpolationRequest bilinearRequest;
    bilinearRequest.sourceGrid = quadraticGrid_;
    bilinearRequest.target = testPoints;
    bilinearRequest.method = InterpolationMethod::BILINEAR;
    
    auto bilinearResult = service_->interpolateAsync(bilinearRequest).get();
    auto bilinearValues = std::get<std::vector<std::optional<double>>>(bilinearResult.data);
    
    // ç«‹æ–¹æ ·æ¡æ’å€¼
    InterpolationRequest cubicRequest;
    cubicRequest.sourceGrid = quadraticGrid_;
    cubicRequest.target = testPoints;
    cubicRequest.method = InterpolationMethod::CUBIC_SPLINE_1D;
    
    auto cubicResult = service_->interpolateAsync(cubicRequest).get();
    auto cubicValues = std::get<std::vector<std::optional<double>>>(cubicResult.data);
    
    // è®¡ç®—ä¸çœŸå®å€¼çš„è¯¯å·®
    double bilinearError = 0.0, cubicError = 0.0;
    size_t validCount = 0;
    
    for (size_t i = 0; i < testPoints.size(); ++i) {
        if (bilinearValues[i].has_value() && cubicValues[i].has_value()) {
            double x = testPoints[i].coordinates[0];
            double y = testPoints[i].coordinates[1];
            double expected = x * x + y * y + x * y; // å·²çŸ¥äºŒæ¬¡å‡½æ•°
            
            bilinearError += std::abs(bilinearValues[i].value() - expected);
            cubicError += std::abs(cubicValues[i].value() - expected);
            validCount++;
        }
    }
    
    bilinearError /= validCount;
    cubicError /= validCount;
    
    // ç«‹æ–¹æ ·æ¡å¯¹äºŒæ¬¡å‡½æ•°åº”è¯¥æ›´ç²¾ç¡®
    EXPECT_LT(cubicError, bilinearError);
}

TEST_F(AlgorithmCorrectnessTest, SinusoidalFunctionSmoothness) {
    // ä½¿ç”¨æ­£å¼¦å‡½æ•°æµ‹è¯•æ’å€¼çš„å¹³æ»‘æ€§
    auto bounds = sinusoidalGrid_->getBounds();
    auto testPoints = RealDataGenerator::generateRealTargetPoints(bounds, 500);
    
    InterpolationRequest request;
    request.sourceGrid = sinusoidalGrid_;
    request.target = testPoints;
    request.method = InterpolationMethod::CUBIC_SPLINE_1D;
    
    auto result = service_->interpolateAsync(request).get();
    auto values = std::get<std::vector<std::optional<double>>>(result.data);
    
    // éªŒè¯æ’å€¼ç»“æœçš„å¹³æ»‘æ€§ï¼ˆç›¸é‚»ç‚¹çš„å˜åŒ–åº”è¯¥è¿ç»­ï¼‰
    std::vector<double> validValues;
    std::vector<TargetPoint> validPoints;
    
    for (size_t i = 0; i < values.size(); ++i) {
        if (values[i].has_value()) {
            validValues.push_back(values[i].value());
            validPoints.push_back(testPoints[i]);
        }
    }
    
    // æ£€æŸ¥å¹³æ»‘æ€§ï¼šç›¸é‚»ç‚¹çš„æ¢¯åº¦å˜åŒ–åº”è¯¥è¿ç»­
    bool isSmoothEnough = RealDataValidator::validateGridContinuity(*sinusoidalGrid_, 1e-3);
    EXPECT_TRUE(isSmoothEnough);
}

TEST_F(AlgorithmCorrectnessTest, CrossAlgorithmConsistencyWithRealData) {
    // ä½¿ç”¨çœŸå®æµ·æ´‹æ•°æ®éªŒè¯ä¸åŒç®—æ³•åœ¨ç›¸åŒæ¡ä»¶ä¸‹çš„ä¸€è‡´æ€§
    auto realOceanGrid = RealDataGenerator::loadRealTemperatureData("medium_datasets/regional_temp_500x500.nc");
    auto bounds = realOceanGrid->getBounds();
    auto testPoints = RealDataGenerator::generateRealTargetPoints(bounds, 100);
    
    // æµ‹è¯•æ‰€æœ‰ç®—æ³•
    std::vector<InterpolationMethod> methods = {
        InterpolationMethod::BILINEAR,
        InterpolationMethod::CUBIC_SPLINE_1D,
        InterpolationMethod::LINEAR_1D,
        InterpolationMethod::NEAREST_NEIGHBOR
    };
    
    std::vector<std::vector<std::optional<double>>> allResults;
    
    for (auto method : methods) {
        InterpolationRequest request;
        request.sourceGrid = realOceanGrid;
        request.target = testPoints;
        request.method = method;
        
        auto result = service_->interpolateAsync(request).get();
        EXPECT_EQ(result.statusCode, 0);
        
        auto values = std::get<std::vector<std::optional<double>>>(result.data);
        allResults.push_back(values);
    }
    
    // éªŒè¯ç»“æœçš„ä¸€è‡´æ€§ï¼ˆåœ¨å¹³æ»‘åŒºåŸŸï¼Œä¸åŒç®—æ³•çš„ç»“æœåº”è¯¥ç›¸è¿‘ï¼‰
    for (size_t i = 0; i < testPoints.size(); ++i) {
        std::vector<double> validResults;
        for (const auto& results : allResults) {
            if (results[i].has_value()) {
                validResults.push_back(results[i].value());
            }
        }
        
        if (validResults.size() >= 2) {
            double minVal = *std::min_element(validResults.begin(), validResults.end());
            double maxVal = *std::max_element(validResults.begin(), validResults.end());
            
            // å¯¹äºæ¸©åº¦æ•°æ®ï¼Œä¸åŒç®—æ³•çš„å·®å¼‚åº”è¯¥åœ¨åˆç†èŒƒå›´å†…
            EXPECT_LT(maxVal - minVal, 2.0); // æ¸©åº¦å·®å¼‚ä¸åº”è¶…è¿‡2åº¦
        }
    }
}
```

### 2. æ•°æ®æ ¼å¼å…¼å®¹æ€§æµ‹è¯•

#### 2.1 å¤šæ ¼å¼æ•°æ®æµ‹è¯• (`test_data_format_compatibility.cpp`)

```cpp
class DataFormatCompatibilityTest : public ::testing::Test {
protected:
    void SetUp() override {
        // åˆ›å»ºçœŸå®çš„æœåŠ¡å’Œæ•°æ®è®¿é—®ç»„ä»¶
        simdManager_ = std::make_shared<oscean::common_utils::simd::UnifiedSIMDManager>();
        service_ = std::make_unique<InterpolationServiceImpl>(simdManager_, true);
        dataAccessService_ = RealDataGenerator::createRealDataAccessService();
        
        // å‡†å¤‡å¤šæ ¼å¼çœŸå®æ•°æ®è·¯å¾„
        setupRealDataPaths();
    }
    
    void setupRealDataPaths() {
        netcdfFiles_ = {
            "test_data/real_ocean_data/medium_datasets/regional_temp_500x500.nc",
            "test_data/real_ocean_data/medium_datasets/sound_velocity_1000x1000.nc",
            "test_data/real_ocean_data/medium_datasets/current_field_800x800x50.nc"
        };
        
        geotiffFiles_ = {
            "test_data/real_ocean_data/medium_datasets/bathymetry_1000x1000.tif",
            "test_data/real_ocean_data/medium_datasets/sst_satellite_2000x2000.tif"
        };
    }

private:
    std::unique_ptr<IInterpolationService> service_;
    std::shared_ptr<oscean::common_utils::simd::ISIMDManager> simdManager_;
    std::shared_ptr<IDataAccessService> dataAccessService_;
    std::vector<std::string> netcdfFiles_;
    std::vector<std::string> geotiffFiles_;
};

// ä½¿ç”¨çœŸå®NetCDFæ•°æ®æµ‹è¯•æ’å€¼å…¼å®¹æ€§
TEST_F(DataFormatCompatibilityTest, NetCDFDataInterpolationCompatibility) {
    for (const auto& netcdfFile : netcdfFiles_) {
        // åŠ è½½çœŸå®NetCDFæ•°æ®
        auto gridData = dataAccessService_->loadGridData(netcdfFile);
        ASSERT_NE(gridData, nullptr) << "Failed to load: " << netcdfFile;
        
        // éªŒè¯æ•°æ®å®Œæ•´æ€§
        EXPECT_TRUE(RealDataValidator::validateRealDataIntegrity(*gridData));
        
        // ç”ŸæˆåŸºäºçœŸå®æ•°æ®è¾¹ç•Œçš„ç›®æ ‡ç‚¹
        auto bounds = gridData->getBounds();
        auto targetPoints = RealDataGenerator::generateRealTargetPoints(bounds, 50);
        
        // æµ‹è¯•æ’å€¼
        InterpolationRequest request;
        request.sourceGrid = gridData;
        request.target = targetPoints;
        request.method = InterpolationMethod::BILINEAR;
        
        auto result = service_->interpolateAsync(request).get();
        EXPECT_EQ(result.statusCode, 0) << "Interpolation failed for: " << netcdfFile;
        
        auto values = std::get<std::vector<std::optional<double>>>(result.data);
        EXPECT_EQ(values.size(), targetPoints.size());
        
        // éªŒè¯ç»“æœçš„ç‰©ç†åˆç†æ€§
        std::string dataType = extractDataTypeFromFilename(netcdfFile);
        EXPECT_TRUE(RealDataValidator::validatePhysicalReasonableness(values, dataType));
    }
}

// ä½¿ç”¨çœŸå®GeoTIFFæ•°æ®æµ‹è¯•æ’å€¼å…¼å®¹æ€§
TEST_F(DataFormatCompatibilityTest, GeoTIFFDataInterpolationCompatibility) {
    for (const auto& geotiffFile : geotiffFiles_) {
        // åŠ è½½çœŸå®GeoTIFFæ•°æ®
        auto gridData = dataAccessService_->loadGridData(geotiffFile);
        ASSERT_NE(gridData, nullptr) << "Failed to load: " << geotiffFile;
        
        // éªŒè¯åœ°ç†å‚è€ƒä¿¡æ¯
        auto geoTransform = gridData->getGeoTransform();
        EXPECT_EQ(geoTransform.size(), 6);
        EXPECT_NE(geoTransform[1], 0.0); // Xæ–¹å‘åˆ†è¾¨ç‡ä¸åº”ä¸º0
        EXPECT_NE(geoTransform[5], 0.0); // Yæ–¹å‘åˆ†è¾¨ç‡ä¸åº”ä¸º0
        
        // æµ‹è¯•ç½‘æ ¼åˆ°ç½‘æ ¼æ’å€¼
        auto bounds = gridData->getBounds();
        auto targetGridDef = RealDataGenerator::createRealTargetGridDefinition(
            100, 100, bounds, "EPSG:4326");
        
        InterpolationRequest request;
        request.sourceGrid = gridData;
        request.target = targetGridDef;
        request.method = InterpolationMethod::BILINEAR;
        
        auto result = service_->interpolateAsync(request).get();
        EXPECT_EQ(result.statusCode, 0) << "Grid interpolation failed for: " << geotiffFile;
        
        auto resultGrid = std::get<GridData>(result.data);
        EXPECT_EQ(resultGrid.getDefinition().cols, 100);
        EXPECT_EQ(resultGrid.getDefinition().rows, 100);
    }
}

// ä½¿ç”¨çœŸå®å¤šç»´æ•°æ®æµ‹è¯•æ’å€¼
TEST_F(DataFormatCompatibilityTest, MultiDimensionalDataInterpolation) {
    // åŠ è½½çœŸå®çš„3Dæµ·æ´‹æ•°æ®ï¼ˆæ¸©åº¦å‰–é¢ï¼‰
    auto threeDGrid = dataAccessService_->loadGridData(
        "test_data/real_ocean_data/medium_datasets/temperature_profile_200x200x50.nc");
    
    ASSERT_NE(threeDGrid, nullptr);
    EXPECT_EQ(threeDGrid->getBandCount(), 50); // 50ä¸ªæ·±åº¦å±‚
    
    // æµ‹è¯•ä¸åŒæ·±åº¦å±‚çš„æ’å€¼
    for (size_t band = 0; band < std::min(size_t(5), threeDGrid->getBandCount()); ++band) {
        auto bounds = threeDGrid->getBounds();
        auto targetPoints = RealDataGenerator::generateRealTargetPoints(bounds, 20);
        
        InterpolationRequest request;
        request.sourceGrid = threeDGrid;
        request.target = targetPoints;
        request.method = InterpolationMethod::BILINEAR;
        // æ³¨æ„ï¼šè¿™é‡Œéœ€è¦æŒ‡å®šæ³¢æ®µï¼Œå®é™…å®ç°ä¸­å¯èƒ½éœ€è¦æ‰©å±•è¯·æ±‚ç»“æ„
        
        auto result = service_->interpolateAsync(request).get();
        EXPECT_EQ(result.statusCode, 0) << "Failed for band: " << band;
        
        auto values = std::get<std::vector<std::optional<double>>>(result.data);
        
        // éªŒè¯æ¸©åº¦å€¼çš„åˆç†æ€§ï¼ˆä¸åŒæ·±åº¦çš„æ¸©åº¦èŒƒå›´ä¸åŒï¼‰
        for (const auto& value : values) {
            if (value.has_value()) {
                EXPECT_GT(value.value(), -2.0);  // æµ·æ°´ä¸ä¼šä½äºå†°ç‚¹å¤ªå¤š
                EXPECT_LT(value.value(), 40.0);  // æµ·æ°´æ¸©åº¦ä¸ä¼šå¤ªé«˜
            }
        }
    }
}

// ä½¿ç”¨ä¸åŒæ•°æ®ç±»å‹æµ‹è¯•æ’å€¼
TEST_F(DataFormatCompatibilityTest, DifferentDataTypesInterpolation) {
    // æµ‹è¯•ä¸åŒæ•°æ®ç±»å‹çš„çœŸå®æ•°æ®
    std::vector<std::pair<std::string, DataType>> testFiles = {
        {"test_data/real_ocean_data/small_datasets/int16_bathymetry_100x100.nc", DataType::Int16},
        {"test_data/real_ocean_data/small_datasets/float32_temperature_100x100.nc", DataType::Float32},
        {"test_data/real_ocean_data/small_datasets/float64_salinity_100x100.nc", DataType::Float64}
    };
    
    for (const auto& [filename, expectedType] : testFiles) {
        auto gridData = dataAccessService_->loadGridData(filename);
        ASSERT_NE(gridData, nullptr) << "Failed to load: " << filename;
        
        // éªŒè¯æ•°æ®ç±»å‹
        EXPECT_EQ(gridData->getDataType(), expectedType);
        
        // æµ‹è¯•æ’å€¼
        auto bounds = gridData->getBounds();
        auto targetPoints = RealDataGenerator::generateRealTargetPoints(bounds, 30);
        
        InterpolationRequest request;
        request.sourceGrid = gridData;
        request.target = targetPoints;
        request.method = InterpolationMethod::BILINEAR;
        
        auto result = service_->interpolateAsync(request).get();
        EXPECT_EQ(result.statusCode, 0) << "Interpolation failed for type: " << static_cast<int>(expectedType);
        
        auto values = std::get<std::vector<std::optional<double>>>(result.data);
        
        // éªŒè¯ç»“æœæ•°æ®ç±»å‹è½¬æ¢çš„æ­£ç¡®æ€§
        for (const auto& value : values) {
            if (value.has_value()) {
                EXPECT_FALSE(std::isnan(value.value()));
                EXPECT_FALSE(std::isinf(value.value()));
            }
        }
    }
}
```

### 3. åæ ‡ç³»ç»Ÿæµ‹è¯•

#### 3.1 CRSè½¬æ¢é›†æˆæµ‹è¯• (`test_crs_integration.cpp`)

```cpp
class CRSIntegrationTest : public ::testing::Test {
protected:
    void SetUp() override {
        // åˆ›å»ºçœŸå®çš„æœåŠ¡ç»„ä»¶
        simdManager_ = std::make_shared<oscean::common_utils::simd::UnifiedSIMDManager>();
        service_ = std::make_unique<InterpolationServiceImpl>(simdManager_, true);
        crsService_ = RealDataGenerator::createRealCrsService();
        dataAccessService_ = RealDataGenerator::createRealDataAccessService();
        
        // åŠ è½½ä¸åŒåæ ‡ç³»çš„çœŸå®æ•°æ®
        loadDifferentCRSData();
    }
    
    void loadDifferentCRSData() {
        // åœ°ç†åæ ‡ç³»æ•°æ® (EPSG:4326)
        geographicGrid_ = dataAccessService_->loadGridData(
            "test_data/real_ocean_data/crs_test/wgs84_temperature_500x500.nc");
        
        // æŠ•å½±åæ ‡ç³»æ•°æ® (UTM Zone 50N)
        projectedGrid_ = dataAccessService_->loadGridData(
            "test_data/real_ocean_data/crs_test/utm50n_bathymetry_500x500.nc");
        
        // Web Mercatoræ•°æ® (EPSG:3857)
        webMercatorGrid_ = dataAccessService_->loadGridData(
            "test_data/real_ocean_data/crs_test/web_mercator_sst_500x500.nc");
    }

private:
    std::unique_ptr<IInterpolationService> service_;
    std::shared_ptr<oscean::common_utils::simd::ISIMDManager> simdManager_;
    std::shared_ptr<ICrsService> crsService_;
    std::shared_ptr<IDataAccessService> dataAccessService_;
    std::shared_ptr<GridData> geographicGrid_;
    std::shared_ptr<GridData> projectedGrid_;
    std::shared_ptr<GridData> webMercatorGrid_;
};

// æµ‹è¯•åœ°ç†åæ ‡åˆ°æŠ•å½±åæ ‡çš„æ’å€¼
TEST_F(CRSIntegrationTest, GeographicToProjectedInterpolation) {
    // ä½¿ç”¨åœ°ç†åæ ‡ç³»çš„çœŸå®æ•°æ®
    ASSERT_NE(geographicGrid_, nullptr);
    
    // åˆ›å»ºæŠ•å½±åæ ‡ç³»çš„ç›®æ ‡ç½‘æ ¼å®šä¹‰
    TargetGridDefinition projectedTargetDef;
    projectedTargetDef.crs.wkt = "EPSG:32650"; // UTM Zone 50N
    projectedTargetDef.gridName = "projected_interpolation_result";
    
    // è®¾ç½®ç›®æ ‡ç½‘æ ¼çš„æŠ•å½±åæ ‡èŒƒå›´
    DimensionCoordinateInfo xDim, yDim;
    xDim.name = "x";
    xDim.coordinates = generateUTMXCoordinates(500000, 600000, 100); // UTM XèŒƒå›´
    yDim.name = "y";
    yDim.coordinates = generateUTMYCoordinates(3400000, 3500000, 100); // UTM YèŒƒå›´
    
    projectedTargetDef.dimensions = {xDim, yDim};
    projectedTargetDef.outputDataType = DataType::Float32;
    
    // æ‰§è¡Œæ’å€¼ï¼ˆè¿™é‡Œéœ€è¦CRSæœåŠ¡è¿›è¡Œåæ ‡è½¬æ¢ï¼‰
    InterpolationRequest request;
    request.sourceGrid = geographicGrid_;
    request.target = projectedTargetDef;
    request.method = InterpolationMethod::BILINEAR;
    
    auto result = service_->interpolateAsync(request).get();
    EXPECT_EQ(result.statusCode, 0);
    
    auto resultGrid = std::get<GridData>(result.data);
    EXPECT_EQ(resultGrid.getDefinition().cols, 100);
    EXPECT_EQ(resultGrid.getDefinition().rows, 100);
    
    // éªŒè¯ç»“æœç½‘æ ¼çš„CRS
    EXPECT_EQ(resultGrid.getCrs().wkt, "EPSG:32650");
}

// æµ‹è¯•ä¸åŒæŠ•å½±ç³»ç»Ÿé—´çš„æ’å€¼
TEST_F(CRSIntegrationTest, DifferentProjectionSystemsInterpolation) {
    // ä»UTMæŠ•å½±æ•°æ®æ’å€¼åˆ°Web Mercator
    ASSERT_NE(projectedGrid_, nullptr);
    
    // è·å–æºæ•°æ®çš„åœ°ç†è¾¹ç•Œ
    auto sourceBounds = projectedGrid_->getBounds();
    
    // ä½¿ç”¨CRSæœåŠ¡è½¬æ¢è¾¹ç•Œåˆ°ç›®æ ‡åæ ‡ç³»
    auto targetBounds = crsService_->transformBounds(
        sourceBounds, 
        projectedGrid_->getCrs().wkt, 
        "EPSG:3857"
    ).get();
    
    // åˆ›å»ºWeb Mercatorç›®æ ‡ç½‘æ ¼
    auto webMercatorTargetDef = RealDataGenerator::createRealTargetGridDefinition(
        150, 150, targetBounds, "EPSG:3857");
    
    InterpolationRequest request;
    request.sourceGrid = projectedGrid_;
    request.target = webMercatorTargetDef;
    request.method = InterpolationMethod::BILINEAR;
    
    auto result = service_->interpolateAsync(request).get();
    EXPECT_EQ(result.statusCode, 0);
    
    auto resultGrid = std::get<GridData>(result.data);
    
    // éªŒè¯åæ ‡è½¬æ¢çš„ç²¾åº¦
    auto resultBounds = resultGrid.getBounds();
    EXPECT_NEAR(resultBounds.minX, targetBounds.minX, 1000.0); // 1kmç²¾åº¦
    EXPECT_NEAR(resultBounds.maxX, targetBounds.maxX, 1000.0);
    EXPECT_NEAR(resultBounds.minY, targetBounds.minY, 1000.0);
    EXPECT_NEAR(resultBounds.maxY, targetBounds.maxY, 1000.0);
}

// æµ‹è¯•åæ ‡è½¬æ¢ç²¾åº¦
TEST_F(CRSIntegrationTest, CoordinateTransformationAccuracy) {
    // ä½¿ç”¨å·²çŸ¥æ§åˆ¶ç‚¹æµ‹è¯•åæ ‡è½¬æ¢ç²¾åº¦
    std::vector<TargetPoint> controlPoints = {
        {{120.0, 30.0}},  // å·²çŸ¥åœ°ç†åæ ‡
        {{121.0, 31.0}},
        {{122.0, 32.0}}
    };
    
    // æ‰‹åŠ¨è®¡ç®—é¢„æœŸçš„æŠ•å½±åæ ‡
    std::vector<std::pair<double, double>> expectedUTMCoords = {
        {776394.0, 3320416.0},  // é¢„æœŸçš„UTMåæ ‡
        {887394.0, 3431416.0},
        {998394.0, 3542416.0}
    };
    
    // ä½¿ç”¨åœ°ç†åæ ‡æ•°æ®è¿›è¡Œæ’å€¼
    InterpolationRequest request;
    request.sourceGrid = geographicGrid_;
    request.target = controlPoints;
    request.method = InterpolationMethod::BILINEAR;
    
    auto result = service_->interpolateAsync(request).get();
    EXPECT_EQ(result.statusCode, 0);
    
    auto values = std::get<std::vector<std::optional<double>>>(result.data);
    
    // éªŒè¯æ’å€¼ç»“æœçš„ä¸€è‡´æ€§
    for (size_t i = 0; i < controlPoints.size(); ++i) {
        EXPECT_TRUE(values[i].has_value()) << "Control point " << i << " failed";
        
        if (values[i].has_value()) {
            // éªŒè¯æ’å€¼å€¼åœ¨åˆç†èŒƒå›´å†…
            EXPECT_GT(values[i].value(), -5.0);
            EXPECT_LT(values[i].value(), 35.0);
        }
    }
    
    // æµ‹è¯•é€†å‘è½¬æ¢çš„ç²¾åº¦
    for (size_t i = 0; i < expectedUTMCoords.size(); ++i) {
        auto [utmX, utmY] = expectedUTMCoords[i];
        
        // ä½¿ç”¨CRSæœåŠ¡è¿›è¡Œé€†å‘è½¬æ¢
        auto transformedCoords = crsService_->transformPoint(
            utmX, utmY, "EPSG:32650", "EPSG:4326").get();
        
        // éªŒè¯è½¬æ¢ç²¾åº¦
        EXPECT_NEAR(transformedCoords.first, controlPoints[i].coordinates[0], 1e-6);
        EXPECT_NEAR(transformedCoords.second, controlPoints[i].coordinates[1], 1e-6);
    }
}
```

### 4. å¼‚æ­¥å¤„ç†é›†æˆæµ‹è¯•

#### 4.1 å¼‚æ­¥æ¡†æ¶é›†æˆæµ‹è¯• (`test_async_integration.cpp`)

```cpp
class AsyncIntegrationTest : public ::testing::Test {
protected:
    void SetUp() override {
        // åˆ›å»ºçœŸå®çš„å¼‚æ­¥æ’å€¼æœåŠ¡
        simdManager_ = std::make_shared<oscean::common_utils::simd::UnifiedSIMDManager>();
        service_ = std::make_unique<InterpolationServiceImpl>(simdManager_, true);
        
        // åŠ è½½ç”¨äºå¼‚æ­¥æµ‹è¯•çš„çœŸå®æ•°æ®
        loadAsyncTestData();
    }
    
    void loadAsyncTestData() {
        auto dataService = RealDataGenerator::createRealDataAccessService();
        
        // åŠ è½½ä¸åŒå¤§å°çš„çœŸå®æ•°æ®é›†
        smallGrid_ = dataService->loadGridData("test_data/real_ocean_data/small_datasets/coastal_temp_50x50.nc");
        mediumGrid_ = dataService->loadGridData("test_data/real_ocean_data/medium_datasets/regional_temp_500x500.nc");
        largeGrid_ = dataService->loadGridData("test_data/real_ocean_data/large_datasets/pacific_bathymetry_2000x2000.nc");
    }

private:
    std::unique_ptr<IInterpolationService> service_;
    std::shared_ptr<oscean::common_utils::simd::ISIMDManager> simdManager_;
    std::shared_ptr<GridData> smallGrid_;
    std::shared_ptr<GridData> mediumGrid_;
    std::shared_ptr<GridData> largeGrid_;
};

// æµ‹è¯•å¹¶å‘è¯·æ±‚å¤„ç†
TEST_F(AsyncIntegrationTest, ConcurrentRequestsWithRealData) {
    const size_t numConcurrentRequests = 20;
    std::vector<boost::future<InterpolationResult>> futures;
    
    // åˆ›å»ºå¤šä¸ªçœŸå®çš„å¹¶å‘æ’å€¼è¯·æ±‚
    for (size_t i = 0; i < numConcurrentRequests; ++i) {
        // è½®æ¢ä½¿ç”¨ä¸åŒçš„æ•°æ®é›†å’Œç®—æ³•
        auto grid = (i % 3 == 0) ? smallGrid_ : 
                   (i % 3 == 1) ? mediumGrid_ : largeGrid_;
        
        auto method = (i % 4 == 0) ? InterpolationMethod::BILINEAR :
                     (i % 4 == 1) ? InterpolationMethod::CUBIC_SPLINE_1D :
                     (i % 4 == 2) ? InterpolationMethod::LINEAR_1D :
                                   InterpolationMethod::NEAREST_NEIGHBOR;
        
        auto bounds = grid->getBounds();
        auto targetPoints = RealDataGenerator::generateRealTargetPoints(bounds, 50 + i * 10);
        
        InterpolationRequest request;
        request.sourceGrid = grid;
        request.target = targetPoints;
        request.method = method;
        
        futures.push_back(service_->interpolateAsync(request));
    }
    
    // ç­‰å¾…æ‰€æœ‰è¯·æ±‚å®Œæˆå¹¶éªŒè¯ç»“æœ
    auto startTime = std::chrono::high_resolution_clock::now();
    
    for (size_t i = 0; i < futures.size(); ++i) {
        auto result = futures[i].get();
        EXPECT_EQ(result.statusCode, 0) << "Request " << i << " failed";
        
        auto values = std::get<std::vector<std::optional<double>>>(result.data);
        EXPECT_GT(values.size(), 0);
        
        // éªŒè¯ç»“æœçš„åˆç†æ€§
        size_t validCount = 0;
        for (const auto& value : values) {
            if (value.has_value()) {
                validCount++;
                EXPECT_FALSE(std::isnan(value.value()));
                EXPECT_FALSE(std::isinf(value.value()));
            }
        }
        EXPECT_GT(validCount, values.size() * 0.5); // è‡³å°‘50%çš„ç‚¹åº”è¯¥æœ‰æ•ˆ
    }
    
    auto endTime = std::chrono::high_resolution_clock::now();
    auto totalTime = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime);
    
    // å¹¶å‘å¤„ç†åº”è¯¥æ¯”ä¸²è¡Œå¤„ç†æ›´å¿«
    EXPECT_LT(totalTime.count(), numConcurrentRequests * 100); // å¹³å‡æ¯ä¸ªè¯·æ±‚ä¸è¶…è¿‡100ms
}

// æµ‹è¯•å¤§æ•°æ®é›†å¼‚æ­¥å¤„ç†
TEST_F(AsyncIntegrationTest, LargeDatasetAsyncProcessing) {
    ASSERT_NE(largeGrid_, nullptr);
    
    // ç”Ÿæˆå¤§é‡ç›®æ ‡ç‚¹
    auto bounds = largeGrid_->getBounds();
    auto largeTargetPoints = RealDataGenerator::generateRealTargetPoints(bounds, 10000);
    
    InterpolationRequest request;
    request.sourceGrid = largeGrid_;
    request.target = largeTargetPoints;
    request.method = InterpolationMethod::BILINEAR;
    
    // æµ‹è¯•å¼‚æ­¥å¤„ç†
    auto startTime = std::chrono::high_resolution_clock::now();
    auto future = service_->interpolateAsync(request);
    
    // éªŒè¯futureç«‹å³è¿”å›ï¼ˆéé˜»å¡ï¼‰
    auto futureCreateTime = std::chrono::high_resolution_clock::now();
    auto createDuration = std::chrono::duration_cast<std::chrono::milliseconds>(futureCreateTime - startTime);
    EXPECT_LT(createDuration.count(), 10); // åˆ›å»ºfutureåº”è¯¥å¾ˆå¿«
    
    // ç­‰å¾…ç»“æœ
    auto result = future.get();
    auto endTime = std::chrono::high_resolution_clock::now();
    auto totalDuration = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime);
    
    EXPECT_EQ(result.statusCode, 0);
    
    auto values = std::get<std::vector<std::optional<double>>>(result.data);
    EXPECT_EQ(values.size(), largeTargetPoints.size());
    
    // éªŒè¯å¤§æ•°æ®é›†å¤„ç†çš„æ€§èƒ½
    EXPECT_LT(totalDuration.count(), 5000); // å¤§æ•°æ®é›†å¤„ç†åº”è¯¥åœ¨5ç§’å†…å®Œæˆ
    
    // éªŒè¯å†…å­˜ä½¿ç”¨æ•ˆç‡
    size_t validResults = 0;
    for (const auto& value : values) {
        if (value.has_value()) {
            validResults++;
        }
    }
    EXPECT_GT(validResults, values.size() * 0.7); // è‡³å°‘70%çš„ç‚¹åº”è¯¥æœ‰æ•ˆ
}

// æµ‹è¯•å¼‚æ­¥é”™è¯¯æ¢å¤
TEST_F(AsyncIntegrationTest, AsyncErrorRecovery) {
    // åˆ›å»ºä¸€ä¸ªä¼šå¯¼è‡´é”™è¯¯çš„è¯·æ±‚
    std::vector<TargetPoint> invalidPoints;
    TargetPoint invalidPoint;
    invalidPoint.coordinates = {999.0, 999.0}; // æ˜æ˜¾è¶…å‡ºèŒƒå›´çš„åæ ‡
    invalidPoints.push_back(invalidPoint);
    
    InterpolationRequest invalidRequest;
    invalidRequest.sourceGrid = smallGrid_;
    invalidRequest.target = invalidPoints;
    invalidRequest.method = InterpolationMethod::BILINEAR;
    
    // æµ‹è¯•é”™è¯¯å¤„ç†
    auto errorFuture = service_->interpolateAsync(invalidRequest);
    auto errorResult = errorFuture.get();
    
    // é”™è¯¯åº”è¯¥è¢«æ­£ç¡®å¤„ç†ï¼Œä¸åº”è¯¥å´©æºƒ
    EXPECT_EQ(errorResult.statusCode, 0); // åº”è¯¥æˆåŠŸä½†è¿”å›nullopt
    auto values = std::get<std::vector<std::optional<double>>>(errorResult.data);
    EXPECT_EQ(values.size(), 1);
    EXPECT_FALSE(values[0].has_value()); // æ— æ•ˆç‚¹åº”è¯¥è¿”å›nullopt
    
    // éªŒè¯æœåŠ¡åœ¨é”™è¯¯åä»ç„¶å¯ç”¨
    auto bounds = smallGrid_->getBounds();
    auto validPoints = RealDataGenerator::generateRealTargetPoints(bounds, 10);
    
    InterpolationRequest validRequest;
    validRequest.sourceGrid = smallGrid_;
    validRequest.target = validPoints;
    validRequest.method = InterpolationMethod::BILINEAR;
    
    auto validFuture = service_->interpolateAsync(validRequest);
    auto validResult = validFuture.get();
    
    EXPECT_EQ(validResult.statusCode, 0);
    auto validValues = std::get<std::vector<std::optional<double>>>(validResult.data);
    
    // éªŒè¯æœåŠ¡æ¢å¤æ­£å¸¸
    size_t validCount = 0;
    for (const auto& value : validValues) {
        if (value.has_value()) {
            validCount++;
        }
    }
    EXPECT_GT(validCount, validValues.size() * 0.8);
}

// æµ‹è¯•èµ„æºç®¡ç†
TEST_F(AsyncIntegrationTest, ResourceManagementWithRealWorkload) {
    // åˆ›å»ºå¤§é‡å¼‚æ­¥è¯·æ±‚æ¥æµ‹è¯•èµ„æºç®¡ç†
    const size_t numRequests = 50;
    std::vector<boost::future<InterpolationResult>> futures;
    
    auto initialMemory = getCurrentMemoryUsage();
    
    // åˆ›å»ºå¤§é‡è¯·æ±‚
    for (size_t i = 0; i < numRequests; ++i) {
        auto grid = (i % 2 == 0) ? mediumGrid_ : smallGrid_;
        auto bounds = grid->getBounds();
        auto targetPoints = RealDataGenerator::generateRealTargetPoints(bounds, 100);
        
        InterpolationRequest request;
        request.sourceGrid = grid;
        request.target = targetPoints;
        request.method = InterpolationMethod::BILINEAR;
        
        futures.push_back(service_->interpolateAsync(request));
    }
    
    auto peakMemory = getCurrentMemoryUsage();
    
    // ç­‰å¾…æ‰€æœ‰è¯·æ±‚å®Œæˆ
    for (auto& future : futures) {
        auto result = future.get();
        EXPECT_EQ(result.statusCode, 0);
    }
    
    // å¼ºåˆ¶åƒåœ¾å›æ”¶
    futures.clear();
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
    
    auto finalMemory = getCurrentMemoryUsage();
    
    // éªŒè¯å†…å­˜ä½¿ç”¨åˆç†
    EXPECT_LT(peakMemory - initialMemory, 500 * 1024 * 1024); // å³°å€¼å†…å­˜å¢é•¿ä¸è¶…è¿‡500MB
    EXPECT_LT(finalMemory - initialMemory, 100 * 1024 * 1024); // æœ€ç»ˆå†…å­˜å¢é•¿ä¸è¶…è¿‡100MB
}

private:
    size_t getCurrentMemoryUsage() {
        // å®ç°è·å–å½“å‰å†…å­˜ä½¿ç”¨é‡çš„å‡½æ•°
        // è¿™é‡Œå¯ä»¥ä½¿ç”¨ç³»ç»Ÿç‰¹å®šçš„API
        return 0; // ç®€åŒ–å®ç°
    }
};
```

---

## ğŸ¯ ç«¯åˆ°ç«¯æµ‹è¯• (End-to-End Tests)

### 1. çœŸå®æ•°æ®åœºæ™¯æµ‹è¯•

#### 1.1 æµ·æ´‹æ•°æ®æ’å€¼æµ‹è¯• (`test_oceanographic_data.cpp`)

```cpp
class OceanographicDataTest : public ::testing::Test {
protected:
    void SetUp() override {
        // åˆ›å»ºå®Œæ•´çš„çœŸå®æœåŠ¡æ ˆ
        simdManager_ = std::make_shared<oscean::common_utils::simd::UnifiedSIMDManager>();
        dataAccessService_ = RealDataGenerator::createRealDataAccessService();
        crsService_ = RealDataGenerator::createRealCrsService();
        service_ = std::make_unique<InterpolationServiceImpl>(simdManager_, true);
        
        // è®¾ç½®çœŸå®æµ·æ´‹æ•°æ®è·¯å¾„
        testDataPath_ = "test_data/real_ocean_data/";
        loadRealOceanographicData();
    }
    
    void loadRealOceanographicData() {
        // åŠ è½½çœŸå®çš„æµ·æ´‹å­¦æ•°æ®
        bathymetryData_ = dataAccessService_->loadGridData(testDataPath_ + "bathymetry/GEBCO_2023_global_1arcmin.nc");
        temperatureData_ = dataAccessService_->loadGridData(testDataPath_ + "temperature/WOA23_temperature_annual.nc");
        salinityData_ = dataAccessService_->loadGridData(testDataPath_ + "salinity/WOA23_salinity_annual.nc");
        soundVelocityData_ = dataAccessService_->loadGridData(testDataPath_ + "sound_velocity/calculated_sv_profiles.nc");
    }

private:
    std::unique_ptr<IInterpolationService> service_;
    std::shared_ptr<oscean::common_utils::simd::ISIMDManager> simdManager_;
    std::shared_ptr<IDataAccessService> dataAccessService_;
    std::shared_ptr<ICrsService> crsService_;
    std::string testDataPath_;
    std::shared_ptr<GridData> bathymetryData_;
    std::shared_ptr<GridData> temperatureData_;
    std::shared_ptr<GridData> salinityData_;
    std::shared_ptr<GridData> soundVelocityData_;
};

// æ°´æ·±æ•°æ®æ’å€¼æµ‹è¯• - ä½¿ç”¨çœŸå®GEBCOæ•°æ®
TEST_F(OceanographicDataTest, BathymetryInterpolationWithRealGEBCO) {
    ASSERT_NE(bathymetryData_, nullptr);
    
    // å®šä¹‰çœŸå®çš„æµ·æ´‹åŒºåŸŸï¼ˆä¾‹å¦‚ï¼šå—æµ·åŒºåŸŸï¼‰
    BoundingBox southChinaSea = {
        .minX = 105.0, .maxX = 125.0,  // ç»åº¦èŒƒå›´
        .minY = 5.0,   .maxY = 25.0    // çº¬åº¦èŒƒå›´
    };
    
    // ç”Ÿæˆè¯¥åŒºåŸŸå†…çš„æµ‹é‡ç‚¹ï¼ˆæ¨¡æ‹Ÿèˆ¹èˆ¶èˆªè¿¹ï¼‰
    auto shipTrackPoints = generateShipTrackPoints(southChinaSea, 1000);
    
    InterpolationRequest request;
    request.sourceGrid = bathymetryData_;
    request.target = shipTrackPoints;
    request.method = InterpolationMethod::BILINEAR; // æ°´æ·±æ•°æ®é€šå¸¸ä½¿ç”¨åŒçº¿æ€§æ’å€¼
    
    auto startTime = std::chrono::high_resolution_clock::now();
    auto result = service_->interpolateAsync(request).get();
    auto endTime = std::chrono::high_resolution_clock::now();
    
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime);
    
    EXPECT_EQ(result.statusCode, 0);
    
    auto depths = std::get<std::vector<std::optional<double>>>(result.data);
    EXPECT_EQ(depths.size(), shipTrackPoints.size());
    
    // éªŒè¯æ°´æ·±æ•°æ®çš„åˆç†æ€§
    size_t validDepths = 0;
    double minDepth = std::numeric_limits<double>::max();
    double maxDepth = std::numeric_limits<double>::lowest();
    
    for (const auto& depth : depths) {
        if (depth.has_value()) {
            validDepths++;
            double d = depth.value();
            
            // æ°´æ·±åº”è¯¥æ˜¯è´Ÿå€¼ï¼ˆæµ·æ´‹ï¼‰æˆ–æ¥è¿‘0ï¼ˆæµ·å²¸çº¿ï¼‰
            EXPECT_LE(d, 100.0);  // å…è®¸ä¸€äº›é™†åœ°é«˜ç¨‹
            EXPECT_GE(d, -12000.0); // æœ€æ·±æµ·æ²Ÿçº¦11000ç±³
            
            minDepth = std::min(minDepth, d);
            maxDepth = std::max(maxDepth, d);
        }
    }
    
    EXPECT_GT(validDepths, depths.size() * 0.9); // è‡³å°‘90%çš„ç‚¹åº”è¯¥æœ‰æ•ˆ
    
    std::cout << "Bathymetry Interpolation Results:" << std::endl;
    std::cout << "  Processing Time: " << duration.count() << "ms" << std::endl;
    std::cout << "  Valid Points: " << validDepths << "/" << depths.size() << std::endl;
    std::cout << "  Depth Range: " << minDepth << "m to " << maxDepth << "m" << std::endl;
    
    // æ€§èƒ½è¦æ±‚ï¼š1000ä¸ªç‚¹åº”è¯¥åœ¨1ç§’å†…å®Œæˆ
    EXPECT_LT(duration.count(), 1000);
}

// æ¸©åº¦åœºæ’å€¼æµ‹è¯• - ä½¿ç”¨çœŸå®WOAæ•°æ®
TEST_F(OceanographicDataTest, TemperatureFieldInterpolationWithRealWOA) {
    ASSERT_NE(temperatureData_, nullptr);
    
    // å®šä¹‰çœŸå®çš„æµ·æ´‹è§‚æµ‹ç«™ç‚¹ï¼ˆä¾‹å¦‚ï¼šArgoæµ®æ ‡ä½ç½®ï¼‰
    std::vector<TargetPoint> argoFloatPositions = loadRealArgoFloatPositions();
    
    // å¦‚æœæ²¡æœ‰çœŸå®Argoæ•°æ®ï¼Œç”Ÿæˆæ¨¡æ‹Ÿçš„è§‚æµ‹ç‚¹
    if (argoFloatPositions.empty()) {
        BoundingBox pacificRegion = {
            .minX = 120.0, .maxX = 180.0,
            .minY = -10.0, .maxY = 40.0
        };
        argoFloatPositions = RealDataGenerator::generateRealTargetPoints(pacificRegion, 500);
    }
    
    // æµ‹è¯•ä¸åŒæ·±åº¦å±‚çš„æ¸©åº¦æ’å€¼
    std::vector<size_t> depthLayers = {0, 10, 20, 50, 100}; // è¡¨å±‚åˆ°100ç±³æ·±åº¦
    
    for (size_t layer : depthLayers) {
        if (layer >= temperatureData_->getBandCount()) continue;
        
        InterpolationRequest request;
        request.sourceGrid = temperatureData_;
        request.target = argoFloatPositions;
        request.method = InterpolationMethod::BILINEAR;
        // æ³¨æ„ï¼šè¿™é‡Œéœ€è¦æŒ‡å®šæ·±åº¦å±‚ï¼Œå®é™…å®ç°ä¸­å¯èƒ½éœ€è¦æ‰©å±•è¯·æ±‚ç»“æ„
        
        auto result = service_->interpolateAsync(request).get();
        EXPECT_EQ(result.statusCode, 0) << "Failed for depth layer " << layer;
        
        auto temperatures = std::get<std::vector<std::optional<double>>>(result.data);
        
        // éªŒè¯æ¸©åº¦å€¼çš„åˆç†æ€§
        size_t validTemps = 0;
        double sumTemp = 0.0;
        
        for (const auto& temp : temperatures) {
            if (temp.has_value()) {
                validTemps++;
                double t = temp.value();
                
                // æµ·æ°´æ¸©åº¦çš„åˆç†èŒƒå›´
                EXPECT_GE(t, -2.0);  // æµ·æ°´å†°ç‚¹çº¦-1.8Â°C
                EXPECT_LE(t, 35.0);  // çƒ­å¸¦è¡¨å±‚æµ·æ°´æœ€é«˜çº¦30Â°C
                
                sumTemp += t;
            }
        }
        
        EXPECT_GT(validTemps, temperatures.size() * 0.8); // è‡³å°‘80%çš„ç‚¹åº”è¯¥æœ‰æ•ˆ
        
        double avgTemp = sumTemp / validTemps;
        std::cout << "Depth Layer " << layer << " - Average Temperature: " 
                  << avgTemp << "Â°C (" << validTemps << " valid points)" << std::endl;
        
        // éªŒè¯æ¸©åº¦éšæ·±åº¦çš„å˜åŒ–è¶‹åŠ¿
        if (layer == 0) {
            EXPECT_GT(avgTemp, 10.0); // è¡¨å±‚æ¸©åº¦åº”è¯¥è¾ƒé«˜
        } else if (layer >= 50) {
            EXPECT_LT(avgTemp, 20.0); // æ·±å±‚æ¸©åº¦åº”è¯¥è¾ƒä½
        }
    }
}

// å£°é€Ÿå‰–é¢æ’å€¼æµ‹è¯• - ä½¿ç”¨çœŸå®å£°é€Ÿæ•°æ®
TEST_F(OceanographicDataTest, SoundVelocityProfileInterpolationWithRealData) {
    ASSERT_NE(soundVelocityData_, nullptr);
    
    // å®šä¹‰å£°çº³æµ‹é‡ç‚¹ï¼ˆæ¨¡æ‹Ÿå£°çº³è®¾å¤‡çš„æµ‹é‡ä½ç½®ï¼‰
    BoundingBox sonarSurveyArea = {
        .minX = 110.0, .maxX = 120.0,
        .minY = 15.0,  .maxY = 25.0
    };
    
    auto sonarMeasurementPoints = RealDataGenerator::generateRealTargetPoints(sonarSurveyArea, 200);
    
    InterpolationRequest request;
    request.sourceGrid = soundVelocityData_;
    request.target = sonarMeasurementPoints;
    request.method = InterpolationMethod::CUBIC_SPLINE_1D; // å£°é€Ÿå‰–é¢éœ€è¦é«˜ç²¾åº¦æ’å€¼
    
    auto result = service_->interpolateAsync(request).get();
    EXPECT_EQ(result.statusCode, 0);
    
    auto soundVelocities = std::get<std::vector<std::optional<double>>>(result.data);
    EXPECT_EQ(soundVelocities.size(), sonarMeasurementPoints.size());
    
    // éªŒè¯å£°é€Ÿå€¼çš„åˆç†æ€§
    size_t validSVs = 0;
    double minSV = std::numeric_limits<double>::max();
    double maxSV = std::numeric_limits<double>::lowest();
    
    for (const auto& sv : soundVelocities) {
        if (sv.has_value()) {
            validSVs++;
            double v = sv.value();
            
            // æµ·æ°´ä¸­å£°é€Ÿçš„åˆç†èŒƒå›´
            EXPECT_GE(v, 1400.0); // æœ€ä½çº¦1400 m/s
            EXPECT_LE(v, 1600.0); // æœ€é«˜çº¦1600 m/s
            
            minSV = std::min(minSV, v);
            maxSV = std::max(maxSV, v);
        }
    }
    
    EXPECT_GT(validSVs, soundVelocities.size() * 0.9); // è‡³å°‘90%çš„ç‚¹åº”è¯¥æœ‰æ•ˆ
    
    std::cout << "Sound Velocity Interpolation Results:" << std::endl;
    std::cout << "  Valid Points: " << validSVs << "/" << soundVelocities.size() << std::endl;
    std::cout << "  Sound Velocity Range: " << minSV << " - " << maxSV << " m/s" << std::endl;
    
    // éªŒè¯å£°é€Ÿçš„ç©ºé—´è¿ç»­æ€§
    validateSoundVelocityContinuity(sonarMeasurementPoints, soundVelocities);
}

private:
    std::vector<TargetPoint> generateShipTrackPoints(const BoundingBox& area, size_t numPoints) {
        // ç”Ÿæˆæ¨¡æ‹Ÿèˆ¹èˆ¶èˆªè¿¹ç‚¹
        std::vector<TargetPoint> points;
        points.reserve(numPoints);
        
        // ç”Ÿæˆå‡ æ¡å…¸å‹çš„èˆ¹èˆ¶èˆªçº¿
        for (size_t track = 0; track < 5; ++track) {
            size_t pointsPerTrack = numPoints / 5;
            
            double startX = area.minX + (area.maxX - area.minX) * track / 5.0;
            double endX = area.minX + (area.maxX - area.minX) * (track + 1) / 5.0;
            
            for (size_t i = 0; i < pointsPerTrack; ++i) {
                TargetPoint point;
                point.coordinates = {
                    startX + (endX - startX) * i / pointsPerTrack,
                    area.minY + (area.maxY - area.minY) * i / pointsPerTrack
                };
                points.push_back(point);
            }
        }
        
        return points;
    }
    
    std::vector<TargetPoint> loadRealArgoFloatPositions() {
        // å°è¯•åŠ è½½çœŸå®çš„Argoæµ®æ ‡ä½ç½®æ•°æ®
        // å¦‚æœæ–‡ä»¶ä¸å­˜åœ¨ï¼Œè¿”å›ç©ºå‘é‡
        try {
            auto argoData = dataAccessService_->loadGridData(testDataPath_ + "argo/argo_float_positions.nc");
            if (argoData) {
                // ä»Argoæ•°æ®ä¸­æå–ä½ç½®ä¿¡æ¯
                return extractPositionsFromArgoData(argoData);
            }
        } catch (...) {
            // æ–‡ä»¶ä¸å­˜åœ¨æˆ–åŠ è½½å¤±è´¥
        }
        
        return {}; // è¿”å›ç©ºå‘é‡ï¼Œè°ƒç”¨è€…ä¼šç”Ÿæˆæ¨¡æ‹Ÿæ•°æ®
    }
    
    std::vector<TargetPoint> extractPositionsFromArgoData(std::shared_ptr<GridData> argoData) {
        // ä»Argoæ•°æ®ä¸­æå–æµ®æ ‡ä½ç½®
        std::vector<TargetPoint> positions;
        
        // è¿™é‡Œéœ€è¦æ ¹æ®å®é™…çš„Argoæ•°æ®æ ¼å¼æ¥å®ç°
        // ç®€åŒ–å®ç°ï¼šå‡è®¾æ•°æ®åŒ…å«ç»çº¬åº¦ä¿¡æ¯
        auto bounds = argoData->getBounds();
        return RealDataGenerator::generateRealTargetPoints(bounds, 500);
    }
    
    void validateSoundVelocityContinuity(const std::vector<TargetPoint>& points, 
                                       const std::vector<std::optional<double>>& values) {
        // éªŒè¯å£°é€Ÿçš„ç©ºé—´è¿ç»­æ€§
        const double maxGradient = 10.0; // æœ€å¤§æ¢¯åº¦ m/s per degree
        
        for (size_t i = 0; i < points.size() - 1; ++i) {
            if (values[i].has_value() && values[i+1].has_value()) {
                double dx = points[i+1].coordinates[0] - points[i].coordinates[0];
                double dy = points[i+1].coordinates[1] - points[i].coordinates[1];
                double distance = std::sqrt(dx*dx + dy*dy);
                
                double dv = std::abs(values[i+1].value() - values[i].value());
                double gradient = dv / distance;
                
                EXPECT_LT(gradient, maxGradient) 
                    << "Sound velocity gradient too steep between points " << i << " and " << i+1;
            }
        }
    }
};
```

### 2. å¤§è§„æ¨¡æ•°æ®å¤„ç†æµ‹è¯•

#### 2.1 å¤§æ•°æ®é›†å¤„ç†æµ‹è¯• (`test_large_dataset_processing.cpp`)

```cpp
class LargeDatasetProcessingTest : public ::testing::Test {
protected:
    void SetUp() override {
        // åˆ›å»ºé«˜æ€§èƒ½é…ç½®çš„çœŸå®æœåŠ¡
        simdManager_ = std::make_shared<oscean::common_utils::simd::UnifiedSIMDManager>();
        service_ = std::make_unique<InterpolationServiceImpl>(simdManager_, true);
        dataAccessService_ = RealDataGenerator::createRealDataAccessService();
        
        // è®¾ç½®å¤§æ•°æ®é›†è·¯å¾„
        largeDataPath_ = "test_data/real_ocean_data/large_datasets/";
        loadLargeDatasets();
    }
    
    void loadLargeDatasets() {
        // åŠ è½½çœŸå®çš„å¤§å‹æ•°æ®é›†
        globalSST_ = dataAccessService_->loadGridData(largeDataPath_ + "global_sst_21600x10800.nc");
        globalBathymetry_ = dataAccessService_->loadGridData(largeDataPath_ + "GEBCO_global_15arcsec.nc");
        woaTemperature_ = dataAccessService_->loadGridData(largeDataPath_ + "WOA23_temperature_0.25deg.nc");
    }

private:
    std::unique_ptr<IInterpolationService> service_;
    std::shared_ptr<oscean::common_utils::simd::ISIMDManager> simdManager_;
    std::shared_ptr<IDataAccessService> dataAccessService_;
    std::string largeDataPath_;
    std::shared_ptr<GridData> globalSST_;
    std::shared_ptr<GridData> globalBathymetry_;
    std::shared_ptr<GridData> woaTemperature_;
};

// GBçº§æ•°æ®æ’å€¼æµ‹è¯• - ä½¿ç”¨çœŸå®å…¨çƒæ•°æ®
TEST_F(LargeDatasetProcessingTest, GigabyteDataInterpolationWithRealGlobalData) {
    ASSERT_NE(globalSST_, nullptr);
    
    // éªŒè¯æ•°æ®è§„æ¨¡
    auto definition = globalSST_->getDefinition();
    size_t totalPixels = definition.cols * definition.rows;
    size_t dataSize = globalSST_->getDataSize();
    
    std::cout << "Global SST Dataset:" << std::endl;
    std::cout << "  Dimensions: " << definition.cols << " x " << definition.rows << std::endl;
    std::cout << "  Total Pixels: " << totalPixels << std::endl;
    std::cout << "  Data Size: " << dataSize / (1024*1024) << " MB" << std::endl;
    
    EXPECT_GT(dataSize, 1024*1024*1024); // è‡³å°‘1GB
    
    // ç”Ÿæˆå…¨çƒèŒƒå›´çš„ç›®æ ‡ç‚¹
    BoundingBox globalBounds = {
        .minX = -180.0, .maxX = 180.0,
        .minY = -90.0,  .maxY = 90.0
    };
    
    auto globalTargetPoints = RealDataGenerator::generateRealTargetPoints(globalBounds, 100000); // 10ä¸‡ä¸ªç‚¹
    
    auto initialMemory = getCurrentMemoryUsage();
    auto startTime = std::chrono::high_resolution_clock::now();
    
    InterpolationRequest request;
    request.sourceGrid = globalSST_;
    request.target = globalTargetPoints;
    request.method = InterpolationMethod::BILINEAR;
    
    auto result = service_->interpolateAsync(request).get();
    
    auto endTime = std::chrono::high_resolution_clock::now();
    auto finalMemory = getCurrentMemoryUsage();
    
    auto duration = std::chrono::duration_cast<std::chrono::seconds>(endTime - startTime);
    size_t memoryIncrease = finalMemory - initialMemory;
    
    EXPECT_EQ(result.statusCode, 0);
    
    auto temperatures = std::get<std::vector<std::optional<double>>>(result.data);
    EXPECT_EQ(temperatures.size(), globalTargetPoints.size());
    
    // éªŒè¯ç»“æœè´¨é‡
    size_t validTemps = 0;
    double sumTemp = 0.0;
    
    for (const auto& temp : temperatures) {
        if (temp.has_value()) {
            validTemps++;
            double t = temp.value();
            
            // å…¨çƒSSTçš„åˆç†èŒƒå›´
            EXPECT_GE(t, -2.0);  // æåœ°æµ·æ°´
            EXPECT_LE(t, 35.0);  // çƒ­å¸¦æµ·æ°´
            
            sumTemp += t;
        }
    }
    
    double avgTemp = sumTemp / validTemps;
    
    std::cout << "Gigabyte Data Interpolation Results:" << std::endl;
    std::cout << "  Processing Time: " << duration.count() << " seconds" << std::endl;
    std::cout << "  Memory Increase: " << memoryIncrease / (1024*1024) << " MB" << std::endl;
    std::cout << "  Valid Points: " << validTemps << "/" << temperatures.size() << std::endl;
    std::cout << "  Average Temperature: " << avgTemp << "Â°C" << std::endl;
    std::cout << "  Throughput: " << validTemps / duration.count() << " points/second" << std::endl;
    
    // æ€§èƒ½è¦æ±‚
    EXPECT_LT(duration.count(), 300); // ä¸è¶…è¿‡5åˆ†é’Ÿ
    EXPECT_GT(validTemps, temperatures.size() * 0.7); // è‡³å°‘70%æœ‰æ•ˆ
    EXPECT_LT(memoryIncrease, 2 * 1024 * 1024 * 1024); // å†…å­˜å¢é•¿ä¸è¶…è¿‡2GB
    
    // éªŒè¯å…¨çƒå¹³å‡æ¸©åº¦çš„åˆç†æ€§
    EXPECT_GT(avgTemp, 10.0);  // å…¨çƒå¹³å‡SSTåº”è¯¥åœ¨10Â°Cä»¥ä¸Š
    EXPECT_LT(avgTemp, 25.0);  // å…¨çƒå¹³å‡SSTåº”è¯¥åœ¨25Â°Cä»¥ä¸‹
}

// é«˜åˆ†è¾¨ç‡ç½‘æ ¼æ’å€¼æµ‹è¯• - ä½¿ç”¨çœŸå®é«˜åˆ†è¾¨ç‡æ•°æ®
TEST_F(LargeDatasetProcessingTest, HighResolutionGridInterpolationWithRealData) {
    ASSERT_NE(globalBathymetry_, nullptr);
    
    // é€‰æ‹©ä¸€ä¸ªé«˜åˆ†è¾¨ç‡çš„åŒºåŸŸè¿›è¡Œæµ‹è¯•ï¼ˆä¾‹å¦‚ï¼šåœ°ä¸­æµ·ï¼‰
    BoundingBox mediterraneanSea = {
        .minX = -6.0,  .maxX = 36.0,   // åœ°ä¸­æµ·ç»åº¦èŒƒå›´
        .minY = 30.0,  .maxY = 46.0    // åœ°ä¸­æµ·çº¬åº¦èŒƒå›´
    };
    
    // åˆ›å»ºé«˜åˆ†è¾¨ç‡çš„ç›®æ ‡ç½‘æ ¼
    auto highResTargetGrid = RealDataGenerator::createRealTargetGridDefinition(
        2000, 1000,  // 2000x1000çš„é«˜åˆ†è¾¨ç‡ç½‘æ ¼
        mediterraneanSea,
        "EPSG:4326"
    );
    
    auto startTime = std::chrono::high_resolution_clock::now();
    
    InterpolationRequest request;
    request.sourceGrid = globalBathymetry_;
    request.target = highResTargetGrid;
    request.method = InterpolationMethod::CUBIC_SPLINE_1D; // é«˜åˆ†è¾¨ç‡ä½¿ç”¨é«˜ç²¾åº¦æ’å€¼
    
    auto result = service_->interpolateAsync(request).get();
    
    auto endTime = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::seconds>(endTime - startTime);
    
    EXPECT_EQ(result.statusCode, 0);
    
    auto resultGrid = std::get<GridData>(result.data);
    EXPECT_EQ(resultGrid.getDefinition().cols, 2000);
    EXPECT_EQ(resultGrid.getDefinition().rows, 1000);
    
    // éªŒè¯æ’å€¼ç»“æœçš„è´¨é‡
    size_t totalCells = 2000 * 1000;
    size_t validCells = 0;
    double minDepth = std::numeric_limits<double>::max();
    double maxDepth = std::numeric_limits<double>::lowest();
    
    for (size_t row = 0; row < 1000; ++row) {
        for (size_t col = 0; col < 2000; ++col) {
            auto depth = resultGrid.getValue<double>(row, col, 0);
            if (depth.has_value()) {
                validCells++;
                double d = depth.value();
                minDepth = std::min(minDepth, d);
                maxDepth = std::max(maxDepth, d);
            }
        }
    }
    
    std::cout << "High Resolution Grid Interpolation Results:" << std::endl;
    std::cout << "  Processing Time: " << duration.count() << " seconds" << std::endl;
    std::cout << "  Grid Size: 2000 x 1000 = " << totalCells << " cells" << std::endl;
    std::cout << "  Valid Cells: " << validCells << " (" << (100.0 * validCells / totalCells) << "%)" << std::endl;
    std::cout << "  Depth Range: " << minDepth << "m to " << maxDepth << "m" << std::endl;
    std::cout << "  Processing Rate: " << validCells / duration.count() << " cells/second" << std::endl;
    
    // æ€§èƒ½å’Œè´¨é‡è¦æ±‚
    EXPECT_LT(duration.count(), 600); // ä¸è¶…è¿‡10åˆ†é’Ÿ
    EXPECT_GT(validCells, totalCells * 0.8); // è‡³å°‘80%çš„ç½‘æ ¼æœ‰æ•ˆ
    
    // éªŒè¯åœ°ä¸­æµ·æ°´æ·±çš„åˆç†æ€§
    EXPECT_LT(minDepth, 0.0);     // åº”è¯¥æœ‰æµ·æ´‹åŒºåŸŸï¼ˆè´Ÿå€¼ï¼‰
    EXPECT_GT(maxDepth, -6000.0); // åœ°ä¸­æµ·æœ€æ·±çº¦5000ç±³
    
    // éªŒè¯ç½‘æ ¼çš„è¿ç»­æ€§
    validateGridSpatialContinuity(resultGrid);
}

// æµå¼æ•°æ®å¤„ç†æµ‹è¯• - ä½¿ç”¨çœŸå®å¤§æ•°æ®é›†çš„åˆ†å—å¤„ç†
TEST_F(LargeDatasetProcessingTest, StreamingDataProcessingWithRealData) {
    ASSERT_NE(woaTemperature_, nullptr);
    
    // æ¨¡æ‹Ÿæµå¼å¤„ç†ï¼šå°†å¤§æ•°æ®é›†åˆ†å—å¤„ç†
    auto bounds = woaTemperature_->getBounds();
    const size_t totalPoints = 500000; // 50ä¸‡ä¸ªç‚¹
    const size_t chunkSize = 50000;     // æ¯å—5ä¸‡ä¸ªç‚¹
    const size_t numChunks = totalPoints / chunkSize;
    
    std::vector<std::optional<double>> allResults;
    allResults.reserve(totalPoints);
    
    auto overallStartTime = std::chrono::high_resolution_clock::now();
    size_t totalValidResults = 0;
    
    for (size_t chunk = 0; chunk < numChunks; ++chunk) {
        // ä¸ºæ¯ä¸ªå—ç”Ÿæˆç›®æ ‡ç‚¹
        auto chunkPoints = RealDataGenerator::generateRealTargetPoints(bounds, chunkSize);
        
        auto chunkStartTime = std::chrono::high_resolution_clock::now();
        
        InterpolationRequest request;
        request.sourceGrid = woaTemperature_;
        request.target = chunkPoints;
        request.method = InterpolationMethod::BILINEAR;
        
        auto result = service_->interpolateAsync(request).get();
        
        auto chunkEndTime = std::chrono::high_resolution_clock::now();
        auto chunkDuration = std::chrono::duration_cast<std::chrono::milliseconds>(chunkEndTime - chunkStartTime);
        
        EXPECT_EQ(result.statusCode, 0) << "Chunk " << chunk << " failed";
        
        auto chunkValues = std::get<std::vector<std::optional<double>>>(result.data);
        EXPECT_EQ(chunkValues.size(), chunkSize);
        
        // ç»Ÿè®¡æœ‰æ•ˆç»“æœ
        size_t chunkValidResults = 0;
        for (const auto& value : chunkValues) {
            if (value.has_value()) {
                chunkValidResults++;
            }
        }
        totalValidResults += chunkValidResults;
        
        // å°†ç»“æœæ·»åŠ åˆ°æ€»ç»“æœä¸­
        allResults.insert(allResults.end(), chunkValues.begin(), chunkValues.end());
        
        std::cout << "Chunk " << (chunk + 1) << "/" << numChunks 
                  << ": " << chunkDuration.count() << "ms, " 
                  << chunkValidResults << " valid results" << std::endl;
        
        // éªŒè¯æ¯å—çš„å¤„ç†æ—¶é—´ç¨³å®š
        EXPECT_LT(chunkDuration.count(), 10000); // æ¯å—ä¸è¶…è¿‡10ç§’
    }
    
    auto overallEndTime = std::chrono::high_resolution_clock::now();
    auto totalDuration = std::chrono::duration_cast<std::chrono::seconds>(overallEndTime - overallStartTime);
    
    EXPECT_EQ(allResults.size(), totalPoints);
    
    std::cout << "Streaming Data Processing Results:" << std::endl;
    std::cout << "  Total Processing Time: " << totalDuration.count() << " seconds" << std::endl;
    std::cout << "  Total Points Processed: " << totalPoints << std::endl;
    std::cout << "  Total Valid Results: " << totalValidResults << std::endl;
    std::cout << "  Success Rate: " << (100.0 * totalValidResults / totalPoints) << "%" << std::endl;
    std::cout << "  Average Throughput: " << totalValidResults / totalDuration.count() << " points/second" << std::endl;
    
    // æµå¼å¤„ç†æ€§èƒ½è¦æ±‚
    EXPECT_LT(totalDuration.count(), 1800); // æ€»æ—¶é—´ä¸è¶…è¿‡30åˆ†é’Ÿ
    EXPECT_GT(totalValidResults, totalPoints * 0.8); // è‡³å°‘80%æˆåŠŸç‡
    
    // éªŒè¯ç»“æœçš„ä¸€è‡´æ€§ï¼ˆä¸åŒå—ä¹‹é—´çš„ç»“æœåº”è¯¥è¿ç»­ï¼‰
    validateStreamingResultConsistency(allResults, chunkSize);
}

private:
    size_t getCurrentMemoryUsage() {
        return RealPerformanceMeasurer::getCurrentProcessMemoryUsage();
    }
    
    void validateGridSpatialContinuity(const GridData& grid) {
        // éªŒè¯ç½‘æ ¼çš„ç©ºé—´è¿ç»­æ€§
        const double maxGradient = 1000.0; // æœ€å¤§æ¢¯åº¦ m/pixel
        
        size_t rows = grid.getDefinition().rows;
        size_t cols = grid.getDefinition().cols;
        
        size_t discontinuities = 0;
        
        for (size_t row = 0; row < rows - 1; ++row) {
            for (size_t col = 0; col < cols - 1; ++col) {
                auto value1 = grid.getValue<double>(row, col, 0);
                auto value2 = grid.getValue<double>(row, col + 1, 0);
                auto value3 = grid.getValue<double>(row + 1, col, 0);
                
                if (value1.has_value() && value2.has_value()) {
                    double gradient = std::abs(value2.value() - value1.value());
                    if (gradient > maxGradient) {
                        discontinuities++;
                    }
                }
                
                if (value1.has_value() && value3.has_value()) {
                    double gradient = std::abs(value3.value() - value1.value());
                    if (gradient > maxGradient) {
                        discontinuities++;
                    }
                }
            }
        }
        
        double discontinuityRate = static_cast<double>(discontinuities) / (rows * cols);
        
        std::cout << "Spatial Continuity Analysis:" << std::endl;
        std::cout << "  Discontinuities: " << discontinuities << std::endl;
        std::cout << "  Discontinuity Rate: " << (discontinuityRate * 100) << "%" << std::endl;
        
        // ä¸è¿ç»­æ€§åº”è¯¥å¾ˆå°‘
        EXPECT_LT(discontinuityRate, 0.01); // ä¸è¶…è¿‡1%
    }
    
    void validateStreamingResultConsistency(const std::vector<std::optional<double>>& results, size_t chunkSize) {
        // éªŒè¯æµå¼å¤„ç†ç»“æœçš„ä¸€è‡´æ€§
        // æ£€æŸ¥å—è¾¹ç•Œå¤„çš„ç»“æœæ˜¯å¦åˆç†è¿ç»­
        
        for (size_t chunk = 1; chunk < results.size() / chunkSize; ++chunk) {
            size_t boundaryIndex = chunk * chunkSize;
            
            if (boundaryIndex > 0 && boundaryIndex < results.size()) {
                auto prevValue = results[boundaryIndex - 1];
                auto currValue = results[boundaryIndex];
                
                if (prevValue.has_value() && currValue.has_value()) {
                    double diff = std::abs(currValue.value() - prevValue.value());
                    
                    // å—è¾¹ç•Œå¤„çš„å€¼å˜åŒ–åº”è¯¥åˆç†
                    EXPECT_LT(diff, 10.0) << "Large discontinuity at chunk boundary " << chunk;
                }
            }
        }
    }
};
```

## âš¡ æ€§èƒ½æµ‹è¯• (Performance Tests)

### 1. ç®—æ³•æ€§èƒ½åŸºå‡†æµ‹è¯•

#### 1.1 ç®—æ³•æ€§èƒ½å¯¹æ¯” (`benchmark_algorithms.cpp`)

```cpp
class AlgorithmBenchmark : public ::testing::Test {
protected:
    void SetUp() override {
        // åˆ›å»ºçœŸå®çš„æ’å€¼æœåŠ¡å’ŒSIMDç®¡ç†å™¨
        simdManager_ = std::make_shared<oscean::common_utils::simd::UnifiedSIMDManager>();
        service_ = std::make_unique<InterpolationServiceImpl>(simdManager_, true);
        
        // åŠ è½½çœŸå®çš„æ€§èƒ½æµ‹è¯•æ•°æ®
        loadPerformanceTestData();
    }
    
    void loadPerformanceTestData() {
        auto dataService = RealDataGenerator::createRealDataAccessService();
        
        // åŠ è½½ä¸åŒè§„æ¨¡çš„çœŸå®æ•°æ®ç”¨äºæ€§èƒ½æµ‹è¯•
        smallGrid_ = dataService->loadGridData("test_data/real_ocean_data/small_datasets/coastal_temp_100x100.nc");
        mediumGrid_ = dataService->loadGridData("test_data/real_ocean_data/medium_datasets/regional_temp_1000x1000.nc");
        largeGrid_ = dataService->loadGridData("test_data/real_ocean_data/large_datasets/pacific_bathymetry_5000x5000.nc");
        
        // ç”Ÿæˆä¸åŒè§„æ¨¡çš„çœŸå®ç›®æ ‡ç‚¹
        smallTargetPoints_ = RealDataGenerator::generateRealTargetPoints(smallGrid_->getBounds(), 100);
        mediumTargetPoints_ = RealDataGenerator::generateRealTargetPoints(mediumGrid_->getBounds(), 1000);
        largeTargetPoints_ = RealDataGenerator::generateRealTargetPoints(largeGrid_->getBounds(), 10000);
    }

private:
    std::unique_ptr<IInterpolationService> service_;
    std::shared_ptr<oscean::common_utils::simd::ISIMDManager> simdManager_;
    std::shared_ptr<GridData> smallGrid_;
    std::shared_ptr<GridData> mediumGrid_;
    std::shared_ptr<GridData> largeGrid_;
    std::vector<TargetPoint> smallTargetPoints_;
    std::vector<TargetPoint> mediumTargetPoints_;
    std::vector<TargetPoint> largeTargetPoints_;
};

// åŒçº¿æ€§æ’å€¼æ€§èƒ½åŸºå‡† - ä½¿ç”¨çœŸå®æ•°æ®
TEST_F(AlgorithmBenchmark, BilinearPerformanceWithRealData) {
    std::vector<std::pair<std::string, std::pair<std::shared_ptr<GridData>, std::vector<TargetPoint>>>> testCases = {
        {"Small Dataset", {smallGrid_, smallTargetPoints_}},
        {"Medium Dataset", {mediumGrid_, mediumTargetPoints_}},
        {"Large Dataset", {largeGrid_, largeTargetPoints_}}
    };
    
    for (const auto& [testName, testData] : testCases) {
        auto [grid, targetPoints] = testData;
        
        InterpolationRequest request;
        request.sourceGrid = grid;
        request.target = targetPoints;
        request.method = InterpolationMethod::BILINEAR;
        
        // æµ‹é‡æ€§èƒ½
        auto startTime = std::chrono::high_resolution_clock::now();
        auto result = service_->interpolateAsync(request).get();
        auto endTime = std::chrono::high_resolution_clock::now();
        
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime);
        
        EXPECT_EQ(result.statusCode, 0) << "Failed for " << testName;
        
        auto values = std::get<std::vector<std::optional<double>>>(result.data);
        EXPECT_EQ(values.size(), targetPoints.size());
        
        // è®°å½•æ€§èƒ½æ•°æ®
        std::cout << testName << " - Bilinear Interpolation: " 
                  << duration.count() << "ms for " << targetPoints.size() << " points" << std::endl;
        
        // éªŒè¯æ€§èƒ½ç›®æ ‡
        double pointsPerMs = static_cast<double>(targetPoints.size()) / duration.count();
        if (testName == "Small Dataset") {
            EXPECT_GT(pointsPerMs, 10.0); // å°æ•°æ®é›†åº”è¯¥å¾ˆå¿«
        } else if (testName == "Medium Dataset") {
            EXPECT_GT(pointsPerMs, 5.0);  // ä¸­ç­‰æ•°æ®é›†
        } else {
            EXPECT_GT(pointsPerMs, 1.0);  // å¤§æ•°æ®é›†
        }
    }
}

// ç«‹æ–¹æ ·æ¡æ’å€¼æ€§èƒ½åŸºå‡† - ä½¿ç”¨çœŸå®æ•°æ®
TEST_F(AlgorithmBenchmark, CubicSplinePerformanceWithRealData) {
    // ç«‹æ–¹æ ·æ¡æ’å€¼é€šå¸¸ç”¨äºé«˜ç²¾åº¦è¦æ±‚çš„åœºæ™¯
    auto highResGrid = RealDataGenerator::loadRealBathymetryData("large_datasets/detailed_bathymetry_3000x3000.nc");
    auto targetPoints = RealDataGenerator::generateRealTargetPoints(highResGrid->getBounds(), 5000);
    
    InterpolationRequest request;
    request.sourceGrid = highResGrid;
    request.target = targetPoints;
    request.method = InterpolationMethod::CUBIC_SPLINE_1D;
    
    // æµ‹é‡ç«‹æ–¹æ ·æ¡æ€§èƒ½
    auto startTime = std::chrono::high_resolution_clock::now();
    auto result = service_->interpolateAsync(request).get();
    auto endTime = std::chrono::high_resolution_clock::now();
    
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime);
    
    EXPECT_EQ(result.statusCode, 0);
    
    auto values = std::get<std::vector<std::optional<double>>>(result.data);
    EXPECT_EQ(values.size(), targetPoints.size());
    
    std::cout << "Cubic Spline Interpolation: " << duration.count() 
              << "ms for " << targetPoints.size() << " points on " 
              << highResGrid->getDefinition().cols << "x" << highResGrid->getDefinition().rows << " grid" << std::endl;
    
    // ç«‹æ–¹æ ·æ¡åº”è¯¥åœ¨åˆç†æ—¶é—´å†…å®Œæˆ
    EXPECT_LT(duration.count(), 10000); // ä¸è¶…è¿‡10ç§’
    
    // éªŒè¯ç»“æœè´¨é‡ï¼ˆæ°´æ·±æ•°æ®çš„åˆç†æ€§ï¼‰
    size_t validResults = 0;
    for (const auto& value : values) {
        if (value.has_value()) {
            validResults++;
            EXPECT_LT(value.value(), 100.0);   // æ°´æ·±ä¸åº”ä¸ºæ­£å€¼ï¼ˆé™¤äº†é™†åœ°ï¼‰
            EXPECT_GT(value.value(), -12000.0); // æœ€æ·±æµ·æ²Ÿçº¦11000ç±³
        }
    }
    EXPECT_GT(validResults, values.size() * 0.8); // è‡³å°‘80%çš„ç‚¹åº”è¯¥æœ‰æ•ˆ
}

// SIMDåŠ é€Ÿæ•ˆæœæµ‹è¯• - ä½¿ç”¨çœŸå®æ•°æ®
TEST_F(AlgorithmBenchmark, SIMDSpeedupWithRealData) {
    auto testGrid = mediumGrid_;
    auto testPoints = mediumTargetPoints_;
    
    // æµ‹è¯•SIMDç‰ˆæœ¬ï¼ˆä½¿ç”¨çœŸå®SIMDç®¡ç†å™¨ï¼‰
    InterpolationRequest simdRequest;
    simdRequest.sourceGrid = testGrid;
    simdRequest.target = testPoints;
    simdRequest.method = InterpolationMethod::BILINEAR;
    
    auto simdStartTime = std::chrono::high_resolution_clock::now();
    auto simdResult = service_->interpolateAsync(simdRequest).get();
    auto simdEndTime = std::chrono::high_resolution_clock::now();
    
    auto simdDuration = std::chrono::duration_cast<std::chrono::microseconds>(simdEndTime - simdStartTime);
    
    // æµ‹è¯•æ ‡é‡ç‰ˆæœ¬ï¼ˆåˆ›å»ºä¸ä½¿ç”¨SIMDçš„æœåŠ¡ï¼‰
    auto scalarService = std::make_unique<InterpolationServiceImpl>(nullptr, false);
    
    InterpolationRequest scalarRequest;
    scalarRequest.sourceGrid = testGrid;
    scalarRequest.target = testPoints;
    scalarRequest.method = InterpolationMethod::BILINEAR;
    
    auto scalarStartTime = std::chrono::high_resolution_clock::now();
    auto scalarResult = scalarService->interpolateAsync(scalarRequest).get();
    auto scalarEndTime = std::chrono::high_resolution_clock::now();
    
    auto scalarDuration = std::chrono::duration_cast<std::chrono::microseconds>(scalarEndTime - scalarStartTime);
    
    // éªŒè¯ç»“æœä¸€è‡´æ€§
    EXPECT_EQ(simdResult.statusCode, 0);
    EXPECT_EQ(scalarResult.statusCode, 0);
    
    auto simdValues = std::get<std::vector<std::optional<double>>>(simdResult.data);
    auto scalarValues = std::get<std::vector<std::optional<double>>>(scalarResult.data);
    
    EXPECT_EQ(simdValues.size(), scalarValues.size());
    
    // éªŒè¯æ•°å€¼ä¸€è‡´æ€§
    RealDataValidator::validateResultConsistency(simdValues, scalarValues, 1e-10);
    
    // è®¡ç®—åŠ é€Ÿæ¯”
    double speedup = static_cast<double>(scalarDuration.count()) / simdDuration.count();
    
    std::cout << "SIMD Performance:" << std::endl;
    std::cout << "  SIMD Time: " << simdDuration.count() << " microseconds" << std::endl;
    std::cout << "  Scalar Time: " << scalarDuration.count() << " microseconds" << std::endl;
    std::cout << "  Speedup: " << speedup << "x" << std::endl;
    
    // SIMDåº”è¯¥æä¾›æ˜¾è‘—çš„æ€§èƒ½æå‡
    EXPECT_GT(speedup, 1.5); // è‡³å°‘1.5å€åŠ é€Ÿ
    
    // å¯¹äºå¤§æ•°æ®é›†ï¼ŒåŠ é€Ÿæ¯”åº”è¯¥æ›´æ˜æ˜¾
    if (testPoints.size() > 1000) {
        EXPECT_GT(speedup, 2.0); // å¤§æ•°æ®é›†åº”è¯¥æœ‰2å€ä»¥ä¸ŠåŠ é€Ÿ
    }
}

// å¯æ‰©å±•æ€§æµ‹è¯• - ä½¿ç”¨çœŸå®æ•°æ®
TEST_F(AlgorithmBenchmark, ScalabilityTestWithRealData) {
    auto testGrid = largeGrid_;
    
    // æµ‹è¯•ä¸åŒè§„æ¨¡çš„ç›®æ ‡ç‚¹æ•°é‡
    std::vector<size_t> pointCounts = {100, 500, 1000, 5000, 10000};
    std::vector<double> timings;
    
    for (size_t pointCount : pointCounts) {
        auto targetPoints = RealDataGenerator::generateRealTargetPoints(testGrid->getBounds(), pointCount);
        
        InterpolationRequest request;
        request.sourceGrid = testGrid;
        request.target = targetPoints;
        request.method = InterpolationMethod::BILINEAR;
        
        auto startTime = std::chrono::high_resolution_clock::now();
        auto result = service_->interpolateAsync(request).get();
        auto endTime = std::chrono::high_resolution_clock::now();
        
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime);
        timings.push_back(duration.count());
        
        EXPECT_EQ(result.statusCode, 0);
        
        std::cout << "Scalability Test - " << pointCount << " points: " 
                  << duration.count() << "ms" << std::endl;
    }
    
    // éªŒè¯çº¿æ€§å¯æ‰©å±•æ€§ï¼ˆæ—¶é—´åº”è¯¥å¤§è‡´ä¸ç‚¹æ•°æˆæ­£æ¯”ï¼‰
    for (size_t i = 1; i < pointCounts.size(); ++i) {
        double expectedRatio = static_cast<double>(pointCounts[i]) / pointCounts[i-1];
        double actualRatio = timings[i] / timings[i-1];
        
        // å®é™…æ¯”ä¾‹åº”è¯¥æ¥è¿‘é¢„æœŸæ¯”ä¾‹ï¼ˆå…è®¸ä¸€å®šçš„åå·®ï¼‰
        EXPECT_LT(actualRatio, expectedRatio * 1.5); // ä¸åº”è¯¥è¶…è¿‡1.5å€é¢„æœŸ
        EXPECT_GT(actualRatio, expectedRatio * 0.5); // ä¸åº”è¯¥ä½äº0.5å€é¢„æœŸ
    }
}
```

### 2. å†…å­˜æ€§èƒ½æµ‹è¯•

#### 2.1 å†…å­˜æ•ˆç‡æµ‹è¯• (`test_memory_performance.cpp`)

```cpp
class MemoryPerformanceTest : public ::testing::Test {
protected:
    void SetUp() override {
        // åˆ›å»ºçœŸå®çš„æ’å€¼æœåŠ¡
        simdManager_ = std::make_shared<oscean::common_utils::simd::UnifiedSIMDManager>();
        service_ = std::make_unique<InterpolationServiceImpl>(simdManager_, true);
        
        // åŠ è½½ç”¨äºå†…å­˜æµ‹è¯•çš„çœŸå®æ•°æ®
        loadMemoryTestData();
    }
    
    void loadMemoryTestData() {
        auto dataService = RealDataGenerator::createRealDataAccessService();
        
        // åŠ è½½å¤§å‹çœŸå®æ•°æ®é›†ç”¨äºå†…å­˜æµ‹è¯•
        largeGrid_ = dataService->loadGridData("test_data/real_ocean_data/large_datasets/global_sst_5000x5000.nc");
        hugeGrid_ = dataService->loadGridData("test_data/real_ocean_data/large_datasets/woa_temperature_21600x10800x102.nc");
    }
    
    size_t getCurrentMemoryUsage() {
        // å®ç°è·å–å½“å‰è¿›ç¨‹å†…å­˜ä½¿ç”¨é‡çš„å‡½æ•°
        // Windows: GetProcessMemoryInfo
        // Linux: /proc/self/status
        return RealPerformanceMeasurer::getCurrentProcessMemoryUsage();
    }

private:
    std::unique_ptr<IInterpolationService> service_;
    std::shared_ptr<oscean::common_utils::simd::ISIMDManager> simdManager_;
    std::shared_ptr<GridData> largeGrid_;
    std::shared_ptr<GridData> hugeGrid_;
};

// å†…å­˜ä½¿ç”¨æ¨¡å¼æµ‹è¯• - ä½¿ç”¨çœŸå®å¤§æ•°æ®
TEST_F(MemoryPerformanceTest, MemoryUsagePatternWithRealData) {
    auto initialMemory = getCurrentMemoryUsage();
    
    // æµ‹è¯•å¤§æ•°æ®é›†çš„å†…å­˜ä½¿ç”¨
    auto bounds = largeGrid_->getBounds();
    auto targetPoints = RealDataGenerator::generateRealTargetPoints(bounds, 50000); // 5ä¸‡ä¸ªç‚¹
    
    auto beforeInterpolation = getCurrentMemoryUsage();
    
    InterpolationRequest request;
    request.sourceGrid = largeGrid_;
    request.target = targetPoints;
    request.method = InterpolationMethod::BILINEAR;
    
    auto result = service_->interpolateAsync(request).get();
    
    auto afterInterpolation = getCurrentMemoryUsage();
    
    EXPECT_EQ(result.statusCode, 0);
    
    auto values = std::get<std::vector<std::optional<double>>>(result.data);
    EXPECT_EQ(values.size(), targetPoints.size());
    
    // è®¡ç®—å†…å­˜ä½¿ç”¨
    size_t interpolationMemory = afterInterpolation - beforeInterpolation;
    size_t sourceDataSize = largeGrid_->getDataSize();
    size_t targetDataSize = targetPoints.size() * sizeof(double);
    
    std::cout << "Memory Usage Analysis:" << std::endl;
    std::cout << "  Initial Memory: " << initialMemory / (1024*1024) << " MB" << std::endl;
    std::cout << "  Before Interpolation: " << beforeInterpolation / (1024*1024) << " MB" << std::endl;
    std::cout << "  After Interpolation: " << afterInterpolation / (1024*1024) << " MB" << std::endl;
    std::cout << "  Interpolation Memory: " << interpolationMemory / (1024*1024) << " MB" << std::endl;
    std::cout << "  Source Data Size: " << sourceDataSize / (1024*1024) << " MB" << std::endl;
    std::cout << "  Target Data Size: " << targetDataSize / (1024*1024) << " MB" << std::endl;
    
    // å†…å­˜ä½¿ç”¨åº”è¯¥åˆç†
    EXPECT_LT(interpolationMemory, sourceDataSize * 2); // ä¸åº”è¶…è¿‡æºæ•°æ®çš„2å€
    EXPECT_GT(interpolationMemory, targetDataSize);     // åº”è¯¥è‡³å°‘åŒ…å«ç›®æ ‡æ•°æ®
}

// å¤§æ•°æ®é›†å†…å­˜æ•ˆç‡æµ‹è¯• - ä½¿ç”¨çœŸå®è¶…å¤§æ•°æ®
TEST_F(MemoryPerformanceTest, LargeDatasetMemoryEfficiencyWithRealData) {
    // ä½¿ç”¨è¶…å¤§çš„çœŸå®æ•°æ®é›†æµ‹è¯•å†…å­˜æ•ˆç‡
    ASSERT_NE(hugeGrid_, nullptr);
    
    auto initialMemory = getCurrentMemoryUsage();
    
    // åˆ†æ‰¹å¤„ç†å¤§é‡ç›®æ ‡ç‚¹
    auto bounds = hugeGrid_->getBounds();
    const size_t totalPoints = 100000; // 10ä¸‡ä¸ªç‚¹
    const size_t batchSize = 10000;     // æ¯æ‰¹1ä¸‡ä¸ªç‚¹
    
    std::vector<std::optional<double>> allResults;
    allResults.reserve(totalPoints);
    
    for (size_t batch = 0; batch < totalPoints / batchSize; ++batch) {
        auto batchPoints = RealDataGenerator::generateRealTargetPoints(bounds, batchSize);
        
        auto beforeBatch = getCurrentMemoryUsage();
        
        InterpolationRequest request;
        request.sourceGrid = hugeGrid_;
        request.target = batchPoints;
        request.method = InterpolationMethod::BILINEAR;
        
        auto result = service_->interpolateAsync(request).get();
        EXPECT_EQ(result.statusCode, 0);
        
        auto batchValues = std::get<std::vector<std::optional<double>>>(result.data);
        allResults.insert(allResults.end(), batchValues.begin(), batchValues.end());
        
        auto afterBatch = getCurrentMemoryUsage();
        size_t batchMemory = afterBatch - beforeBatch;
        
        std::cout << "Batch " << batch + 1 << " Memory Usage: " 
                  << batchMemory / (1024*1024) << " MB" << std::endl;
        
        // æ¯æ‰¹çš„å†…å­˜ä½¿ç”¨åº”è¯¥ç›¸å¯¹ç¨³å®š
        EXPECT_LT(batchMemory, 500 * 1024 * 1024); // æ¯æ‰¹ä¸è¶…è¿‡500MB
    }
    
    auto finalMemory = getCurrentMemoryUsage();
    size_t totalMemoryIncrease = finalMemory - initialMemory;
    
    std::cout << "Total Memory Increase: " << totalMemoryIncrease / (1024*1024) << " MB" << std::endl;
    
    // æ€»å†…å­˜å¢é•¿åº”è¯¥åˆç†
    EXPECT_LT(totalMemoryIncrease, 1024 * 1024 * 1024); // ä¸è¶…è¿‡1GB
    
    // éªŒè¯æ‰€æœ‰ç»“æœ
    EXPECT_EQ(allResults.size(), totalPoints);
    
    size_t validResults = 0;
    for (const auto& result : allResults) {
        if (result.has_value()) {
            validResults++;
        }
    }
    EXPECT_GT(validResults, totalPoints * 0.8); // è‡³å°‘80%çš„ç‚¹åº”è¯¥æœ‰æ•ˆ
}

// å†…å­˜æ³„æ¼æ£€æµ‹ - ä½¿ç”¨çœŸå®æ•°æ®é‡å¤æ“ä½œ
TEST_F(MemoryPerformanceTest, MemoryLeakDetectionWithRealData) {
    auto initialMemory = getCurrentMemoryUsage();
    
    // é‡å¤æ‰§è¡Œç›¸åŒçš„æ’å€¼æ“ä½œ
    const size_t iterations = 100;
    auto bounds = largeGrid_->getBounds();
    
    for (size_t i = 0; i < iterations; ++i) {
        auto targetPoints = RealDataGenerator::generateRealTargetPoints(bounds, 1000);
        
        InterpolationRequest request;
        request.sourceGrid = largeGrid_;
        request.target = targetPoints;
        request.method = InterpolationMethod::BILINEAR;
        
        auto result = service_->interpolateAsync(request).get();
        EXPECT_EQ(result.statusCode, 0);
        
        // æ¯10æ¬¡è¿­ä»£æ£€æŸ¥ä¸€æ¬¡å†…å­˜
        if ((i + 1) % 10 == 0) {
            auto currentMemory = getCurrentMemoryUsage();
            size_t memoryIncrease = currentMemory - initialMemory;
            
            std::cout << "Iteration " << i + 1 << " Memory: " 
                      << currentMemory / (1024*1024) << " MB (+" 
                      << memoryIncrease / (1024*1024) << " MB)" << std::endl;
            
            // å†…å­˜å¢é•¿åº”è¯¥ç¨³å®šï¼Œä¸åº”è¯¥æŒç»­å¢é•¿
            if (i > 20) { // å‰20æ¬¡è¿­ä»£å…è®¸ä¸€äº›å†…å­˜åˆ†é…
                EXPECT_LT(memoryIncrease, 200 * 1024 * 1024); // ä¸è¶…è¿‡200MBå¢é•¿
            }
        }
    }
    
    // å¼ºåˆ¶åƒåœ¾å›æ”¶
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
    
    auto finalMemory = getCurrentMemoryUsage();
    size_t totalIncrease = finalMemory - initialMemory;
    
    std::cout << "Final Memory Increase: " << totalIncrease / (1024*1024) << " MB" << std::endl;
    
    // æœ€ç»ˆå†…å­˜å¢é•¿åº”è¯¥å¾ˆå°
    EXPECT_LT(totalIncrease, 100 * 1024 * 1024); // ä¸è¶…è¿‡100MB
}
```

### 3. å¹¶å‘æ€§èƒ½æµ‹è¯•

#### 3.1 å¹¶å‘å¤„ç†æµ‹è¯• (`test_concurrent_performance.cpp`)

```cpp
class ConcurrentPerformanceTest : public ::testing::Test {
protected:
    void SetUp() override {
        // åˆ›å»ºçœŸå®çš„æ’å€¼æœåŠ¡
        simdManager_ = std::make_shared<oscean::common_utils::simd::UnifiedSIMDManager>();
        service_ = std::make_unique<InterpolationServiceImpl>(simdManager_, true);
        
        // åŠ è½½ç”¨äºå¹¶å‘æµ‹è¯•çš„çœŸå®æ•°æ®
        loadConcurrentTestData();
    }
    
    void loadConcurrentTestData() {
        auto dataService = RealDataGenerator::createRealDataAccessService();
        
        // åŠ è½½å¤šä¸ªä¸åŒçš„çœŸå®æ•°æ®é›†ç”¨äºå¹¶å‘æµ‹è¯•
        temperatureGrid_ = dataService->loadGridData("test_data/real_ocean_data/medium_datasets/temperature_1000x1000.nc");
        salinityGrid_ = dataService->loadGridData("test_data/real_ocean_data/medium_datasets/salinity_1000x1000.nc");
        bathymetryGrid_ = dataService->loadGridData("test_data/real_ocean_data/medium_datasets/bathymetry_1000x1000.nc");
        currentGrid_ = dataService->loadGridData("test_data/real_ocean_data/medium_datasets/current_velocity_1000x1000.nc");
    }

private:
    std::unique_ptr<IInterpolationService> service_;
    std::shared_ptr<oscean::common_utils::simd::ISIMDManager> simdManager_;
    std::shared_ptr<GridData> temperatureGrid_;
    std::shared_ptr<GridData> salinityGrid_;
    std::shared_ptr<GridData> bathymetryGrid_;
    std::shared_ptr<GridData> currentGrid_;
};

// çº¿ç¨‹å®‰å…¨æ€§æµ‹è¯• - ä½¿ç”¨çœŸå®æ•°æ®å¹¶å‘è®¿é—®
TEST_F(ConcurrentPerformanceTest, ThreadSafetyWithRealData) {
    const size_t numThreads = 8;
    const size_t requestsPerThread = 20;
    
    std::vector<std::shared_ptr<GridData>> grids = {
        temperatureGrid_, salinityGrid_, bathymetryGrid_, currentGrid_
    };
    
    std::vector<std::thread> threads;
    std::vector<std::vector<InterpolationResult>> results(numThreads);
    std::atomic<size_t> completedRequests{0};
    
    // å¯åŠ¨å¤šä¸ªçº¿ç¨‹å¹¶å‘æ‰§è¡Œæ’å€¼
    for (size_t threadId = 0; threadId < numThreads; ++threadId) {
        threads.emplace_back([this, threadId, &grids, &results, &completedRequests, requestsPerThread]() {
            for (size_t i = 0; i < requestsPerThread; ++i) {
                // è½®æ¢ä½¿ç”¨ä¸åŒçš„æ•°æ®é›†
                auto grid = grids[i % grids.size()];
                auto bounds = grid->getBounds();
                auto targetPoints = RealDataGenerator::generateRealTargetPoints(bounds, 50);
                
                InterpolationRequest request;
                request.sourceGrid = grid;
                request.target = targetPoints;
                request.method = InterpolationMethod::BILINEAR;
                
                auto result = service_->interpolateAsync(request).get();
                results[threadId].push_back(result);
                
                completedRequests.fetch_add(1);
            }
        });
    }
    
    // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹å®Œæˆ
    for (auto& thread : threads) {
        thread.join();
    }
    
    // éªŒè¯æ‰€æœ‰è¯·æ±‚éƒ½æˆåŠŸå®Œæˆ
    EXPECT_EQ(completedRequests.load(), numThreads * requestsPerThread);
    
    // éªŒè¯æ¯ä¸ªçº¿ç¨‹çš„ç»“æœ
    for (size_t threadId = 0; threadId < numThreads; ++threadId) {
        EXPECT_EQ(results[threadId].size(), requestsPerThread);
        
        for (const auto& result : results[threadId]) {
            EXPECT_EQ(result.statusCode, 0) << "Thread " << threadId << " had failed request";
            
            auto values = std::get<std::vector<std::optional<double>>>(result.data);
            EXPECT_EQ(values.size(), 50);
            
            // éªŒè¯ç»“æœçš„åˆç†æ€§
            size_t validCount = 0;
            for (const auto& value : values) {
                if (value.has_value()) {
                    validCount++;
                    EXPECT_FALSE(std::isnan(value.value()));
                    EXPECT_FALSE(std::isinf(value.value()));
                }
            }
            EXPECT_GT(validCount, 25); // è‡³å°‘50%çš„ç‚¹åº”è¯¥æœ‰æ•ˆ
        }
    }
}

// å¹¶å‘ååé‡æµ‹è¯• - ä½¿ç”¨çœŸå®æ•°æ®æµ‹é‡ååé‡
TEST_F(ConcurrentPerformanceTest, ConcurrentThroughputWithRealData) {
    const size_t totalRequests = 200;
    const size_t maxConcurrency = 16;
    
    std::vector<std::shared_ptr<GridData>> grids = {
        temperatureGrid_, salinityGrid_, bathymetryGrid_, currentGrid_
    };
    
    // æµ‹è¯•ä¸åŒå¹¶å‘çº§åˆ«çš„ååé‡
    for (size_t concurrency = 1; concurrency <= maxConcurrency; concurrency *= 2) {
        std::vector<boost::future<InterpolationResult>> futures;
        futures.reserve(totalRequests);
        
        auto startTime = std::chrono::high_resolution_clock::now();
        
        // åˆ›å»ºæ‰€æœ‰è¯·æ±‚
        for (size_t i = 0; i < totalRequests; ++i) {
            auto grid = grids[i % grids.size()];
            auto bounds = grid->getBounds();
            auto targetPoints = RealDataGenerator::generateRealTargetPoints(bounds, 100);
            
            InterpolationRequest request;
            request.sourceGrid = grid;
            request.target = targetPoints;
            request.method = InterpolationMethod::BILINEAR;
            
            futures.push_back(service_->interpolateAsync(request));
            
            // æ§åˆ¶å¹¶å‘çº§åˆ«
            if (futures.size() >= concurrency) {
                // ç­‰å¾…ä¸€äº›è¯·æ±‚å®Œæˆ
                for (size_t j = 0; j < concurrency / 2; ++j) {
                    if (j < futures.size()) {
                        auto result = futures[j].get();
                        EXPECT_EQ(result.statusCode, 0);
                    }
                }
                futures.erase(futures.begin(), futures.begin() + std::min(concurrency / 2, futures.size()));
            }
        }
        
        // ç­‰å¾…å‰©ä½™è¯·æ±‚å®Œæˆ
        for (auto& future : futures) {
            auto result = future.get();
            EXPECT_EQ(result.statusCode, 0);
        }
        
        auto endTime = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime);
        
        double throughput = static_cast<double>(totalRequests) / duration.count() * 1000.0; // è¯·æ±‚/ç§’
        
        std::cout << "Concurrency " << concurrency << ": " 
                  << throughput << " requests/second (" 
                  << duration.count() << "ms total)" << std::endl;
        
        // éªŒè¯ååé‡éšå¹¶å‘åº¦çš„å˜åŒ–
        if (concurrency == 1) {
            EXPECT_GT(throughput, 10.0); // å•çº¿ç¨‹è‡³å°‘10è¯·æ±‚/ç§’
        } else if (concurrency <= 4) {
            EXPECT_GT(throughput, 20.0); // ä½å¹¶å‘è‡³å°‘20è¯·æ±‚/ç§’
        } else {
            EXPECT_GT(throughput, 30.0); // é«˜å¹¶å‘è‡³å°‘30è¯·æ±‚/ç§’
        }
    }
}

// è´Ÿè½½å‡è¡¡æµ‹è¯• - ä½¿ç”¨çœŸå®æ•°æ®æµ‹è¯•è´Ÿè½½åˆ†å¸ƒ
TEST_F(ConcurrentPerformanceTest, LoadBalancingWithRealData) {
    const size_t numWorkers = 8;
    const size_t requestsPerWorker = 25;
    
    std::vector<std::shared_ptr<GridData>> grids = {
        temperatureGrid_, salinityGrid_, bathymetryGrid_, currentGrid_
    };
    
    // åˆ›å»ºä¸åŒå¤æ‚åº¦çš„è¯·æ±‚
    std::vector<std::pair<std::shared_ptr<GridData>, size_t>> workloads = {
        {temperatureGrid_, 100},   // ç®€å•å·¥ä½œè´Ÿè½½
        {salinityGrid_, 500},      // ä¸­ç­‰å·¥ä½œè´Ÿè½½
        {bathymetryGrid_, 1000},   // å¤æ‚å·¥ä½œè´Ÿè½½
        {currentGrid_, 2000}       // é‡å‹å·¥ä½œè´Ÿè½½
    };
    
    std::vector<std::thread> workers;
    std::vector<std::chrono::milliseconds> workerTimes(numWorkers);
    std::atomic<size_t> completedTasks{0};
    
    auto overallStartTime = std::chrono::high_resolution_clock::now();
    
    // å¯åŠ¨å·¥ä½œçº¿ç¨‹
    for (size_t workerId = 0; workerId < numWorkers; ++workerId) {
        workers.emplace_back([this, workerId, &workloads, &workerTimes, &completedTasks, requestsPerWorker]() {
            auto workerStartTime = std::chrono::high_resolution_clock::now();
            
            for (size_t i = 0; i < requestsPerWorker; ++i) {
                // æ ¹æ®å·¥ä½œçº¿ç¨‹IDé€‰æ‹©ä¸åŒå¤æ‚åº¦çš„å·¥ä½œè´Ÿè½½
                auto [grid, pointCount] = workloads[workerId % workloads.size()];
                auto bounds = grid->getBounds();
                auto targetPoints = RealDataGenerator::generateRealTargetPoints(bounds, pointCount);
                
                InterpolationRequest request;
                request.sourceGrid = grid;
                request.target = targetPoints;
                request.method = InterpolationMethod::BILINEAR;
                
                auto result = service_->interpolateAsync(request).get();
                EXPECT_EQ(result.statusCode, 0);
                
                completedTasks.fetch_add(1);
            }
            
            auto workerEndTime = std::chrono::high_resolution_clock::now();
            workerTimes[workerId] = std::chrono::duration_cast<std::chrono::milliseconds>(
                workerEndTime - workerStartTime);
        });
    }
    
    // ç­‰å¾…æ‰€æœ‰å·¥ä½œçº¿ç¨‹å®Œæˆ
    for (auto& worker : workers) {
        worker.join();
    }
    
    auto overallEndTime = std::chrono::high_resolution_clock::now();
    auto totalTime = std::chrono::duration_cast<std::chrono::milliseconds>(overallEndTime - overallStartTime);
    
    // éªŒè¯æ‰€æœ‰ä»»åŠ¡å®Œæˆ
    EXPECT_EQ(completedTasks.load(), numWorkers * requestsPerWorker);
    
    // åˆ†æè´Ÿè½½å‡è¡¡æ•ˆæœ
    auto minTime = *std::min_element(workerTimes.begin(), workerTimes.end());
    auto maxTime = *std::max_element(workerTimes.begin(), workerTimes.end());
    
    std::cout << "Load Balancing Analysis:" << std::endl;
    std::cout << "  Total Time: " << totalTime.count() << "ms" << std::endl;
    std::cout << "  Min Worker Time: " << minTime.count() << "ms" << std::endl;
    std::cout << "  Max Worker Time: " << maxTime.count() << "ms" << std::endl;
    
    for (size_t i = 0; i < numWorkers; ++i) {
        std::cout << "  Worker " << i << ": " << workerTimes[i].count() << "ms" << std::endl;
    }
    
    // è´Ÿè½½å‡è¡¡æ•ˆæœéªŒè¯
    double loadImbalance = static_cast<double>(maxTime.count() - minTime.count()) / minTime.count();
    std::cout << "  Load Imbalance: " << (loadImbalance * 100) << "%" << std::endl;
    
    // è´Ÿè½½ä¸å‡è¡¡åº”è¯¥åœ¨åˆç†èŒƒå›´å†…
    EXPECT_LT(loadImbalance, 0.5); // ä¸å‡è¡¡åº¦ä¸åº”è¶…è¿‡50%
    
    // æ€»æ—¶é—´åº”è¯¥æ¥è¿‘æœ€é•¿å·¥ä½œçº¿ç¨‹çš„æ—¶é—´ï¼ˆè¯´æ˜å¹¶è¡Œæ•ˆæœå¥½ï¼‰
    EXPECT_LT(totalTime.count(), maxTime.count() * 1.2); // ä¸åº”è¶…è¿‡æœ€é•¿æ—¶é—´çš„120%
}
``` 