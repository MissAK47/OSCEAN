# æ•°æ®å·¥ä½œæµé«˜çº§ä¼˜åŒ–æ–¹æ¡ˆ

## 1. æ¦‚è¿°

æœ¬æ–¹æ¡ˆè®¾è®¡äº†ä¸€ä¸ªæ™ºèƒ½åŒ–çš„æ•°æ®å·¥ä½œæµç³»ç»Ÿï¼Œæ”¯æŒç‚¹ã€çº¿ã€é¢ã€ä½“ç­‰å¤šç§ç©ºé—´æ•°æ®è¯»å–éœ€æ±‚ï¼Œå…·å¤‡æ™ºèƒ½æ’å€¼ã€åæ ‡è½¬æ¢ã€å¤šç»´åº¦æ•°æ®å¤„ç†ç­‰é«˜çº§åŠŸèƒ½ã€‚ç³»ç»Ÿé€šè¿‡ç»Ÿä¸€çš„å·¥ä½œæµå¼•æ“ç®¡ç†æœåŠ¡ç”Ÿå‘½å‘¨æœŸï¼Œæ”¯æŒç›´æ¥æ–‡ä»¶å’Œæ•°æ®åº“æŸ¥è¯¢ä¸¤ç§æ•°æ®æºæ¨¡å¼ã€‚

## 2. æ ¸å¿ƒè®¾è®¡ç†å¿µ

### 2.1 æ™ºèƒ½å†³ç­–é©±åŠ¨
- **æ™ºèƒ½æ’å€¼å†³ç­–**ï¼šåŸºäºç”¨æˆ·ç²¾åº¦éœ€æ±‚å’Œæ•°æ®åŸç”Ÿç²¾åº¦è‡ªåŠ¨å†³å®šæ˜¯å¦å¯ç”¨æ’å€¼
- **æ™ºèƒ½CRSè½¬æ¢**ï¼šä¼˜å…ˆè½¬æ¢è½»é‡æŸ¥è¯¢å‡ ä½•ï¼Œé¿å…è½¬æ¢åºå¤§æ•°æ®
- **æ™ºèƒ½è¯»å–ç­–ç•¥**ï¼šæ ¹æ®æ•°æ®ç‰¹å¾é€‰æ‹©æœ€ä¼˜çš„è¯»å–æ–¹æ³•

### 2.2 å¤šç»´åº¦ç²¾åº¦æ§åˆ¶
- **æ°´å¹³ç²¾åº¦**ï¼šæ”¯æŒåŸå§‹ç²¾åº¦å’ŒæŒ‡å®šç²¾åº¦ï¼ˆç±³ä¸ºå•ä½ï¼‰
- **å‚ç›´ç²¾åº¦**ï¼šæ”¯æŒåŸå§‹ç²¾åº¦å’ŒæŒ‡å®šç²¾åº¦ï¼ˆç±³ä¸ºå•ä½ï¼‰
- **æ—¶é—´ç²¾åº¦**ï¼šæ”¯æŒåŸå§‹æ—¶é—´æ­¥é•¿å’ŒæŒ‡å®šæ—¶é—´åˆ†è¾¨ç‡

### 2.3 ç»Ÿä¸€å·¥ä½œæµå¼•æ“
- é›†æˆåˆ°workflow_engineç»Ÿä¸€æ¡†æ¶
- æ”¯æŒç”Ÿå‘½å‘¨æœŸç®¡ç†å’ŒçŠ¶æ€ç›‘æ§
- æä¾›å¼‚æ­¥å¤„ç†å’Œé”™è¯¯æ¢å¤æœºåˆ¶

## 3. è¯¦ç»†å‚æ•°è®¾è®¡

### 3.1 å¢å¼ºçš„ç©ºé—´ç²¾åº¦é…ç½®

```cpp
/**
 * @brief ç©ºé—´ç²¾åº¦é…ç½® - æ”¯æŒæ°´å¹³å’Œå‚ç›´ç²¾åº¦çš„ç‹¬ç«‹æ§åˆ¶
 */
struct SpatialResolutionConfig {
    // ğŸ¯ æ°´å¹³ç²¾åº¦æ§åˆ¶
    struct HorizontalResolution {
        enum class Mode {
            ORIGINAL,           // ä½¿ç”¨æ•°æ®åŸå§‹ç²¾åº¦
            SPECIFIED           // ä½¿ç”¨æŒ‡å®šç²¾åº¦
        } mode = Mode::ORIGINAL;
        
        std::optional<double> targetResolutionMeters;  // ç›®æ ‡æ°´å¹³ç²¾åº¦ï¼ˆç±³ï¼‰
        bool enableAnisotropicHandling = false;        // å¯ç”¨å„å‘å¼‚æ€§å¤„ç†
        std::optional<double> targetResolutionX;       // Xæ–¹å‘ç²¾åº¦ï¼ˆç±³ï¼‰
        std::optional<double> targetResolutionY;       // Yæ–¹å‘ç²¾åº¦ï¼ˆç±³ï¼‰
    } horizontalResolution;
    
    // ğŸ¯ å‚ç›´ç²¾åº¦æ§åˆ¶
    struct VerticalResolution {
        enum class Mode {
            ORIGINAL,           // ä½¿ç”¨æ•°æ®åŸå§‹ç²¾åº¦
            SPECIFIED,          // ä½¿ç”¨æŒ‡å®šç²¾åº¦
            ADAPTIVE            // è‡ªé€‚åº”ç²¾åº¦ï¼ˆåŸºäºæ·±åº¦èŒƒå›´ï¼‰
        } mode = Mode::ORIGINAL;
        
        std::optional<double> targetResolutionMeters;  // ç›®æ ‡å‚ç›´ç²¾åº¦ï¼ˆç±³ï¼‰
        std::optional<double> minResolutionMeters;     // æœ€å°ç²¾åº¦é™åˆ¶
        std::optional<double> maxResolutionMeters;     // æœ€å¤§ç²¾åº¦é™åˆ¶
        std::string depthUnit = "meters";              // æ·±åº¦å•ä½
        std::string depthPositive = "down";            // æ·±åº¦æ­£æ–¹å‘
    } verticalResolution;
    
    // ğŸ¯ æ’å€¼ç®—æ³•é€‰æ‹©
    enum class InterpolationAlgorithm {
        AUTO,               // è‡ªåŠ¨é€‰æ‹©
        NEAREST,            // æœ€è¿‘é‚»
        BILINEAR,           // åŒçº¿æ€§
        BICUBIC,            // åŒä¸‰æ¬¡
        LANCZOS            // Lanczos
    } interpolationAlgorithm = InterpolationAlgorithm::AUTO;
    
    // ğŸ¯ ç²¾åº¦é˜ˆå€¼è®¾ç½®
    struct ResolutionThresholds {
        double horizontalImprovementThreshold = 0.5;   // æ°´å¹³ç²¾åº¦æå‡é˜ˆå€¼
        double verticalImprovementThreshold = 0.5;     // å‚ç›´ç²¾åº¦æå‡é˜ˆå€¼
        double maxInterpolationRatio = 10.0;           // æœ€å¤§æ’å€¼æ¯”ä¾‹
    } thresholds;
};
```

### 3.2 å®Œæ•´çš„å·¥ä½œæµè¯·æ±‚å‚æ•°

```cpp
/**
 * @brief æ•°æ®å·¥ä½œæµè¯·æ±‚ - å®Œæ•´ç‰ˆæœ¬
 */
struct DataWorkflowRequest {
    // =============================================================================
    // ğŸ¯ ç©ºé—´æŸ¥è¯¢è¯·æ±‚ï¼ˆå¿…éœ€ï¼‰
    // =============================================================================
    using SpatialRequest = std::variant<
        Point,                  // ç‚¹æŸ¥è¯¢
        LineString,             // çº¿æŸ¥è¯¢  
        Polygon,                // é¢æŸ¥è¯¢
        BoundingBox,            // ä½“æŸ¥è¯¢
        struct {                // æ–¹ä½è§’è·ç¦»æŸ¥è¯¢
            Point startPoint;
            double bearing;     // æ–¹ä½è§’ï¼ˆåº¦ï¼‰
            double distance;    // è·ç¦»ï¼ˆç±³ï¼‰
        }
    >;
    SpatialRequest spatialRequest;
    
    // =============================================================================
    // ğŸ¯ æ•°æ®æºæ¨¡å¼é€‰æ‹©
    // =============================================================================
    enum class DataSourceMode {
        DIRECT_FILES,           // ç”¨æˆ·ç›´æ¥æŒ‡å®šæ–‡ä»¶
        DATABASE_QUERY          // é€šè¿‡æ•°æ®åº“æŸ¥è¯¢è·å–æ–‡ä»¶
    } dataSourceMode;
    
    // =============================================================================
    // ğŸ¯ ç›´æ¥æ–‡ä»¶æ¨¡å¼å‚æ•°
    // =============================================================================
    struct DirectFileParams {
        struct FileSpec {
            std::string filePath;
            std::vector<std::string> variableNames;
            
            // æ·±åº¦ç»´åº¦å‚æ•°
            struct DepthDimension {
                std::optional<std::vector<double>> specificDepths;     // æŒ‡å®šæ·±åº¦ï¼ˆç±³ï¼‰
                std::optional<double> minDepth, maxDepth;              // æ·±åº¦èŒƒå›´ï¼ˆç±³ï¼‰
                std::optional<std::vector<int>> layerIndices;          // å±‚ç´¢å¼•
                std::string depthUnit = "meters";
                std::string depthPositive = "down";
            };
            std::optional<DepthDimension> depthDimension;
            
            // CRSå¤„ç†é…ç½®
            struct CRSHandling {
                std::string userCRS = "EPSG:4326";                     // ç”¨æˆ·åæ ‡CRS
                std::optional<std::string> expectedDataCRS;            // é¢„æœŸæ•°æ®CRS
                bool enableAutoDetection = true;                       // å¯ç”¨CRSè‡ªåŠ¨æ£€æµ‹
                bool enableTransformation = true;                      // å¯ç”¨CRSè½¬æ¢
                std::string preferredOutputCRS = "EPSG:4326";         // é¦–é€‰è¾“å‡ºCRS
            } crsHandling;
            
            // ç©ºé—´ç²¾åº¦é…ç½®
            SpatialResolutionConfig spatialResolution;
            
            // å…¶ä»–å‚æ•°
            std::optional<core_services::TimeRange> expectedTimeRange;
            std::optional<std::string> preferredAccessPattern;
        };
        std::vector<FileSpec> fileSpecs;
    };
    std::optional<DirectFileParams> directFileParams;
    
    // =============================================================================
    // ğŸ¯ æ•°æ®åº“æŸ¥è¯¢æ¨¡å¼å‚æ•°
    // =============================================================================
    struct DatabaseQueryParams {
        std::vector<std::string> variableNames;                      // å…¨å±€å˜é‡åˆ—è¡¨
        std::optional<core_services::TimeRange> timeRange;          // æ—¶é—´èŒƒå›´
        std::optional<std::string> datasetType;                     // æ•°æ®é›†ç±»å‹
        std::optional<double> minQualityScore;                      // æœ€ä½è´¨é‡åˆ†æ•°
        
        // æ·±åº¦æŸ¥è¯¢å‚æ•°
        std::optional<double> minDepth, maxDepth;                   // æ·±åº¦èŒƒå›´è¿‡æ»¤
        std::optional<std::vector<std::string>> depthLayers;        // æ·±åº¦å±‚åç§°
        
        // ç©ºé—´ç²¾åº¦éœ€æ±‚
        SpatialResolutionConfig spatialResolution;
        
        // é«˜çº§æŸ¥è¯¢é€‰é¡¹
        bool enableGeohashOptimization = true;                      // å¯ç”¨Geohashä¼˜åŒ–
        bool preferHighQuality = true;                              // ä¼˜å…ˆé«˜è´¨é‡æ•°æ®
        int maxResults = 100;                                       // æœ€å¤§ç»“æœæ•°
    };
    std::optional<DatabaseQueryParams> databaseQueryParams;
    
    // =============================================================================
    // ğŸ¯ å…¨å±€å¤„ç†é€‰é¡¹
    // =============================================================================
    struct ProcessingOptions {
        // åæ ‡è½¬æ¢é€‰é¡¹
        std::optional<std::string> targetCRS;                       // æœ€ç»ˆè¾“å‡ºCRS
        bool enableCrsTransformation = true;
        
        // æ’å€¼å¤„ç†é€‰é¡¹
        bool enableAdvancedInterpolation = true;
        std::optional<double> interpolationTolerance;               // æ’å€¼å®¹å·®
        
        // æ•°æ®èåˆé€‰é¡¹
        enum class FusionStrategy {
            MOSAIC,             // é•¶åµŒ
            AVERAGE,            // å¹³å‡
            WEIGHTED_AVERAGE,   // åŠ æƒå¹³å‡
            LATEST_PRIORITY     // æœ€æ–°ä¼˜å…ˆ
        } fusionStrategy = FusionStrategy::MOSAIC;
        
        // è´¨é‡æ§åˆ¶
        bool enableQualityCheck = true;
        double minDataQuality = 0.5;
    } processingOptions;
    
    // =============================================================================
    // ğŸ¯ è¾“å‡ºé…ç½®
    // =============================================================================
    struct OutputOptions {
        enum class Format {
            NETCDF,             // NetCDFæ ¼å¼
            GEOTIFF,            // GeoTIFFæ ¼å¼
            CSV,                // CSVæ ¼å¼
            JSON,               // JSONæ ¼å¼
            MEMORY_OBJECT       // å†…å­˜å¯¹è±¡ï¼ˆç”¨äºé“¾å¼å¤„ç†ï¼‰
        } format = Format::NETCDF;
        
        std::optional<std::string> outputPath;                      // è¾“å‡ºè·¯å¾„
        std::optional<int> maxFileSizeMB;                          // æœ€å¤§æ–‡ä»¶å¤§å°
        bool enableCompression = true;                              // å¯ç”¨å‹ç¼©
        
        // å…ƒæ•°æ®è¾“å‡º
        bool includeMetadata = true;                                // åŒ…å«å…ƒæ•°æ®
        bool includeProcessingHistory = true;                      // åŒ…å«å¤„ç†å†å²
    };
    std::optional<OutputOptions> outputOptions;
    
    // =============================================================================
    // ğŸ¯ å·¥ä½œæµæ§åˆ¶é€‰é¡¹
    // =============================================================================
    struct WorkflowOptions {
        std::string workflowId;                                     // å·¥ä½œæµID
        int priority = 5;                                          // ä¼˜å…ˆçº§(1-10)
        std::chrono::seconds timeout = std::chrono::seconds(300);  // è¶…æ—¶æ—¶é—´
        bool enableProgressCallback = true;                        // å¯ç”¨è¿›åº¦å›è°ƒ
        bool enableErrorRecovery = true;                          // å¯ç”¨é”™è¯¯æ¢å¤
        int maxRetries = 3;                                        // æœ€å¤§é‡è¯•æ¬¡æ•°
    } workflowOptions;
};
```

## 4. ç¬¬äºŒæ­¥ï¼šç©ºé—´è¯·æ±‚è§£æä¸æ•°æ®è¯»å–å‡†å¤‡

### 4.1 ç©ºé—´è¯·æ±‚è§£æå™¨è®¾è®¡

ç©ºé—´å‡ ä½•å¤„ç†ç”±SpatialOpsServiceå®Œæˆï¼ŒåŒ…æ‹¬ç‚¹ã€çº¿ã€é¢ã€ä½“çš„ç©ºé—´éªŒè¯ã€èŒƒå›´è®¡ç®—ã€æŸ¥è¯¢ä¼˜åŒ–å‡ ä½•ç”Ÿæˆç­‰æ ¸å¿ƒåŠŸèƒ½ã€‚

```cpp
/**
 * @brief ç©ºé—´è¯·æ±‚è§£æå™¨ - ç¬¬äºŒæ­¥çš„æ ¸å¿ƒç»„ä»¶
 */
class SpatialRequestResolver {
public:
    /**
     * @brief ç©ºé—´æŸ¥è¯¢å…ƒæ•°æ® - æä¾›ç»™æ™ºèƒ½è¯†åˆ«å™¨çš„å®Œæ•´ä¿¡æ¯
     */
    struct SpatialQueryMetadata {
        // ğŸ¯ åŸå§‹è¯·æ±‚ä¿¡æ¯
        SpatialRequest originalRequest;
        std::string requestType;  // "point", "line", "polygon", "bounding_box", "bearing_distance"
        
        // ğŸ¯ å¤„ç†åçš„ç©ºé—´ä¿¡æ¯
        struct ProcessedSpatialInfo {
            // ç»Ÿä¸€çš„æŸ¥è¯¢è¾¹ç•Œæ¡†ï¼ˆWGS84ï¼‰
            BoundingBox queryBounds;
            
            // åŸå§‹å‡ ä½•ï¼ˆç”¨æˆ·åæ ‡ç³»ï¼‰
            std::variant<Point, LineString, Polygon, BoundingBox> originalGeometry;
            
            // è§„èŒƒåŒ–å‡ ä½•ï¼ˆWGS84ï¼‰
            std::variant<Point, LineString, Polygon, BoundingBox> normalizedGeometry;
            
            // ç©ºé—´ç‰¹å¾
            double spatialExtentArea;      // ç©ºé—´èŒƒå›´é¢ç§¯ï¼ˆå¹³æ–¹ç±³ï¼‰
            double spatialComplexity;      // ç©ºé—´å¤æ‚åº¦ï¼ˆ0-1ï¼‰
            std::string spatialPattern;   // "point", "linear", "compact_area", "complex_area", "large_area"
            
            // æŸ¥è¯¢ä¼˜åŒ–å‡ ä½•
            std::optional<BoundingBox> optimizedQueryBounds;  // ä¼˜åŒ–åçš„æŸ¥è¯¢è¾¹ç•Œ
            std::optional<Polygon> optimizedQueryPolygon;     // ä¼˜åŒ–åçš„æŸ¥è¯¢å¤šè¾¹å½¢
            
        } processedSpatial;
        
        // ğŸ¯ åæ ‡ç³»ç»Ÿä¿¡æ¯
        struct CRSInfo {
            std::string userCRS;           // ç”¨æˆ·æŒ‡å®šçš„CRS
            std::string processingCRS;     // å¤„ç†è¿‡ç¨‹ä¸­ä½¿ç”¨çš„CRS
            std::string outputCRS;         // æœ€ç»ˆè¾“å‡ºCRS
            bool needsTransformation;      // æ˜¯å¦éœ€è¦åæ ‡è½¬æ¢
            
            // è½¬æ¢å‚æ•°
            std::optional<std::string> transformationPipeline;  // PROJè½¬æ¢ç®¡é“
            std::optional<double> transformationAccuracy;       // è½¬æ¢ç²¾åº¦ï¼ˆç±³ï¼‰
        } crsInfo;
        
        // ğŸ¯ æ·±åº¦ç»´åº¦ä¿¡æ¯ï¼ˆå¦‚æœé€‚ç”¨ï¼‰
        struct DepthInfo {
            bool hasDepthDimension = false;
            std::optional<double> minDepth, maxDepth;
            std::optional<std::vector<double>> specificDepths;
            std::string depthUnit = "meters";
            std::string depthPositive = "down";
            
            // æ·±åº¦æŸ¥è¯¢ä¼˜åŒ–
            std::optional<std::vector<double>> optimizedDepthLayers;
        } depthInfo;
        
        // ğŸ¯ æŸ¥è¯¢æ€§èƒ½é¢„ä¼°
        struct QueryPerformanceEstimate {
            enum class DataAccessPattern {
                POINT_LOOKUP,      // ç‚¹æŸ¥æ‰¾
                SPATIAL_SCAN,      // ç©ºé—´æ‰«æ
                SPATIAL_INDEX,     // ç©ºé—´ç´¢å¼•
                FULL_SCAN         // å…¨è¡¨æ‰«æ
            } recommendedPattern;
            
            double estimatedDataVolume;    // é¢„ä¼°æ•°æ®é‡ï¼ˆMBï¼‰
            double estimatedProcessingTime; // é¢„ä¼°å¤„ç†æ—¶é—´ï¼ˆç§’ï¼‰
            int estimatedMemoryUsage;      // é¢„ä¼°å†…å­˜ä½¿ç”¨ï¼ˆMBï¼‰
            
            // ä¼˜åŒ–å»ºè®®
            std::vector<std::string> optimizationSuggestions;
        } performanceEstimate;
        
        // ğŸ¯ æ—¶é—´æˆ³
        std::chrono::system_clock::time_point processingTimestamp;
        std::string processingId;
    };
    
    /**
     * @brief è§£æç©ºé—´è¯·æ±‚ - ç¬¬äºŒæ­¥çš„æ ¸å¿ƒæ–¹æ³•
     */
    boost::future<SpatialQueryMetadata> resolveSpatialRequest(
        const DataWorkflowRequest& request,
        std::shared_ptr<SpatialOpsService> spatialService) {
        
        return boost::async([this, request, spatialService]() {
            SpatialQueryMetadata metadata;
            
            // ğŸ¯ æ­¥éª¤1ï¼šè¯†åˆ«å’ŒéªŒè¯ç©ºé—´å‡ ä½•ç±»å‹
            identifyAndValidateSpatialGeometry(request.spatialRequest, metadata);
            
            // ğŸ¯ æ­¥éª¤2ï¼šå¤„ç†åæ ‡ç³»ç»Ÿ
            processCRSInformation(request, metadata, spatialService);
            
            // ğŸ¯ æ­¥éª¤3ï¼šè®¡ç®—ç©ºé—´èŒƒå›´å’Œç‰¹å¾
            calculateSpatialExtentAndFeatures(metadata, spatialService);
            
            // ğŸ¯ æ­¥éª¤4ï¼šç”ŸæˆæŸ¥è¯¢ä¼˜åŒ–å‡ ä½•
            generateOptimizedQueryGeometry(metadata, spatialService);
            
            // ğŸ¯ æ­¥éª¤5ï¼šå¤„ç†æ·±åº¦ç»´åº¦
            processDepthDimension(request, metadata);
            
            // ğŸ¯ æ­¥éª¤6ï¼šæ€§èƒ½é¢„ä¼°
            estimateQueryPerformance(metadata);
            
            // ğŸ¯ æ­¥éª¤7ï¼šå¡«å……æ—¶é—´æˆ³å’ŒID
            metadata.processingTimestamp = std::chrono::system_clock::now();
            metadata.processingId = generateProcessingId();
            
            return metadata;
        });
    }
};
```

### 4.2 ç‚¹æŸ¥è¯¢æ’å€¼ç­–ç•¥

```cpp
/**
 * @brief ç‚¹æŸ¥è¯¢æ’å€¼ç­–ç•¥åˆ†æå™¨
 */
class PointQueryInterpolationAnalyzer {
public:
    /**
     * @brief ç‚¹æŸ¥è¯¢æ’å€¼é…ç½®
     */
    struct PointInterpolationConfig {
        enum class InterpolationMethod {
            NEAREST_NEIGHBOR,       // æœ€è¿‘é‚»ï¼ˆæ— æ’å€¼ï¼‰
            BILINEAR,              // åŒçº¿æ€§æ’å€¼ï¼ˆæ¨èï¼‰
            BICUBIC,               // åŒä¸‰æ¬¡æ’å€¼ï¼ˆé«˜ç²¾åº¦ï¼‰
            INVERSE_DISTANCE,      // åè·ç¦»æƒé‡
            NATURAL_NEIGHBOR       // è‡ªç„¶é‚»åŸŸæ’å€¼
        } method;
        
        // æœç´¢åŠå¾„é…ç½®
        double searchRadiusMeters = 5000.0;     // æœç´¢åŠå¾„ï¼ˆé»˜è®¤5kmï¼‰
        int maxSearchPoints = 4;                // æœ€å¤§æœç´¢ç‚¹æ•°
        double distanceWeightPower = 2.0;      // è·ç¦»æƒé‡å¹‚æ¬¡
        
        // è´¨é‡æ§åˆ¶
        double maxDistanceThreshold = 10000.0;  // æœ€å¤§è·ç¦»é˜ˆå€¼
        bool enableQualityWeighting = true;     // å¯ç”¨è´¨é‡æƒé‡
        
        std::string reasoningExplanation;
    };
    
    /**
     * @brief åˆ†æç‚¹æŸ¥è¯¢æ’å€¼éœ€æ±‚
     * 
     * ç‚¹æŸ¥è¯¢ç¡®å®éœ€è¦æ’å€¼å¤„ç†ï¼Œå› ä¸ºç”¨æˆ·æŒ‡å®šçš„ç‚¹å¯èƒ½åœ¨æ•°æ®ç½‘æ ¼ä¸­ä¸å­˜åœ¨
     */
    PointInterpolationConfig analyzePointInterpolation(
        const Point& queryPoint,
        const SpatialQueryMetadata& spatialMetadata,
        const DatabaseMetadataForIntelligentReading& dataMetadata) {
        
        PointInterpolationConfig config;
        
        // ğŸ¯ æ ¹æ®æ•°æ®ç±»å‹é€‰æ‹©æ’å€¼æ–¹æ³•
        if (dataMetadata.dataCategory == "ocean_environment") {
            // æµ·æ´‹ç¯å¢ƒæ•°æ®é€šå¸¸ç©ºé—´è¿ç»­æ€§å¥½ï¼Œé€‚åˆåŒçº¿æ€§æ’å€¼
            config.method = PointInterpolationConfig::InterpolationMethod::BILINEAR;
            config.searchRadiusMeters = 5000.0;
            config.reasoningExplanation = "æµ·æ´‹ç¯å¢ƒæ•°æ®ç©ºé—´è¿ç»­æ€§å¥½ï¼Œä½¿ç”¨åŒçº¿æ€§æ’å€¼";
            
        } else if (dataMetadata.dataCategory == "topography") {
            // åœ°å½¢æ•°æ®å¯èƒ½æœ‰çªå˜
            double dataResolution = dataMetadata.spatialCoverage.spatialResolutionX.value_or(1000.0);
            if (dataResolution < 100.0) {
                config.method = PointInterpolationConfig::InterpolationMethod::BICUBIC;
                config.reasoningExplanation = "é«˜åˆ†è¾¨ç‡åœ°å½¢æ•°æ®ä½¿ç”¨åŒä¸‰æ¬¡æ’å€¼ä¿æŒç»†èŠ‚";
            } else {
                config.method = PointInterpolationConfig::InterpolationMethod::BILINEAR;
                config.reasoningExplanation = "ä¸­ç­‰åˆ†è¾¨ç‡åœ°å½¢æ•°æ®ä½¿ç”¨åŒçº¿æ€§æ’å€¼";
            }
            
        } else if (dataMetadata.dataCategory == "sonar_propagation") {
            // å£°ä¼ æ’­æ•°æ®å¯èƒ½æœ‰å¤æ‚çš„ç©ºé—´å˜åŒ–
            config.method = PointInterpolationConfig::InterpolationMethod::INVERSE_DISTANCE;
            config.searchRadiusMeters = 2000.0;
            config.maxSearchPoints = 8;
            config.reasoningExplanation = "å£°ä¼ æ’­æ•°æ®ä½¿ç”¨åè·ç¦»æƒé‡æ’å€¼å¤„ç†å¤æ‚ç©ºé—´å˜åŒ–";
        }
        
        // ğŸ¯ æ ¹æ®æ•°æ®åˆ†è¾¨ç‡è°ƒæ•´æœç´¢å‚æ•°
        double dataRes = dataMetadata.spatialCoverage.spatialResolutionX.value_or(1000.0);
        config.searchRadiusMeters = std::max(dataRes * 2.5, 1000.0); // è‡³å°‘2.5ä¸ªç½‘æ ¼ç‚¹è·ç¦»
        
        return config;
    }
};
```

### 4.3 ç»Ÿä¸€ç½‘æ ¼ç³»ç»Ÿ

```cpp
/**
 * @brief ç»Ÿä¸€ç½‘æ ¼ç³»ç»Ÿå®šä¹‰
 * 
 * çº¿ã€é¢ã€ä½“çš„æ•°æ®ç½‘æ ¼éœ€è¦ç»Ÿä¸€ï¼Œä½†æ ¹æ®å‡ ä½•ç±»å‹é‡‡ç”¨ä¸åŒç­–ç•¥
 */
class UnifiedGridSystem {
public:
    /**
     * @brief ç»Ÿä¸€ç½‘æ ¼é…ç½®
     */
    struct UnifiedGridConfig {
        // ğŸ¯ åŸºç¡€ç½‘æ ¼å‚æ•°
        double horizontalResolutionMeters;      // æ°´å¹³åˆ†è¾¨ç‡ï¼ˆç±³ï¼‰
        double verticalResolutionMeters;        // å‚ç›´åˆ†è¾¨ç‡ï¼ˆç±³ï¼‰
        std::string gridProjection;            // ç½‘æ ¼æŠ•å½±ç³»ç»Ÿ
        
        // ğŸ¯ ç½‘æ ¼è¾¹ç•Œ
        BoundingBox gridExtent;                 // ç½‘æ ¼èŒƒå›´
        std::vector<double> depthLayers;        // æ·±åº¦å±‚å®šä¹‰
        
        // ğŸ¯ ä¸åŒå‡ ä½•ç±»å‹çš„ç½‘æ ¼ç­–ç•¥
        struct GeometryGridStrategy {
            enum class GridType {
                REGULAR_GRID,        // è§„åˆ™ç½‘æ ¼ï¼ˆé¢ã€ä½“ï¼‰
                ADAPTIVE_GRID,       // è‡ªé€‚åº”ç½‘æ ¼ï¼ˆå¤æ‚é¢ï¼‰
                PATH_ORIENTED_GRID,  // è·¯å¾„å¯¼å‘ç½‘æ ¼ï¼ˆçº¿ï¼‰
                POINT_BASED         // ç‚¹åŸºç¡€ï¼ˆç‚¹ï¼‰
            } gridType;
            
            // ç½‘æ ¼å¯†åº¦æ§åˆ¶
            double gridDensityFactor = 1.0;     // ç½‘æ ¼å¯†åº¦å› å­
            bool enableAdaptiveRefinement = false; // è‡ªé€‚åº”åŠ å¯†
        };
        
        std::map<std::string, GeometryGridStrategy> geometryStrategies;
    };
    
    /**
     * @brief ä¸ºä¸åŒå‡ ä½•ç±»å‹ç”Ÿæˆç»Ÿä¸€ç½‘æ ¼
     */
    UnifiedGridConfig generateUnifiedGrid(
        const SpatialQueryMetadata& spatialMetadata,
        const SpatialResolutionConfig& resolutionConfig) {
        
        UnifiedGridConfig gridConfig;
        
        // ğŸ¯ ç¡®å®šåŸºç¡€ç½‘æ ¼åˆ†è¾¨ç‡
        if (resolutionConfig.horizontalResolution.mode == 
            SpatialResolutionConfig::HorizontalResolution::Mode::SPECIFIED) {
            gridConfig.horizontalResolutionMeters = 
                resolutionConfig.horizontalResolution.targetResolutionMeters.value();
        } else {
            // åŸºäºç©ºé—´èŒƒå›´è‡ªåŠ¨ç¡®å®šåˆ†è¾¨ç‡
            gridConfig.horizontalResolutionMeters = 
                calculateOptimalResolution(spatialMetadata.processedSpatial.spatialExtentArea);
        }
        
        // ğŸ¯ æ ¹æ®å‡ ä½•ç±»å‹é…ç½®ç½‘æ ¼ç­–ç•¥
        if (spatialMetadata.requestType == "point") {
            gridConfig.geometryStrategies["point"] = {
                UnifiedGridConfig::GeometryGridStrategy::GridType::POINT_BASED,
                1.0, false
            };
        } else if (spatialMetadata.requestType == "line") {
            gridConfig.geometryStrategies["line"] = {
                UnifiedGridConfig::GeometryGridStrategy::GridType::PATH_ORIENTED_GRID,
                1.5, true  // æ²¿çº¿è·¯å¾„å¢åŠ å¯†åº¦
            };
        } else if (spatialMetadata.requestType == "polygon") {
            if (spatialMetadata.processedSpatial.spatialComplexity > 0.7) {
                gridConfig.geometryStrategies["polygon"] = {
                    UnifiedGridConfig::GeometryGridStrategy::GridType::ADAPTIVE_GRID,
                    2.0, true  // å¤æ‚å¤šè¾¹å½¢ä½¿ç”¨è‡ªé€‚åº”ç½‘æ ¼
                };
            } else {
                gridConfig.geometryStrategies["polygon"] = {
                    UnifiedGridConfig::GeometryGridStrategy::GridType::REGULAR_GRID,
                    1.0, false
                };
            }
        } else if (spatialMetadata.requestType == "bounding_box") {
            gridConfig.geometryStrategies["bounding_box"] = {
                UnifiedGridConfig::GeometryGridStrategy::GridType::REGULAR_GRID,
                1.0, false
            };
        }
        
        return gridConfig;
    }
};
```

### 4.4 é™†åœ°æ©ç å¤„ç†ç³»ç»Ÿ

#### 4.4.1 æŠ€æœ¯æ–¹æ¡ˆå¯¹æ¯”

```cpp
/**
 * @brief é™†åœ°æ©ç æ•°æ®æºç­–ç•¥
 */
namespace oscean::land_mask {

/**
 * @brief æ··åˆæ–¹æ¡ˆ - æ¨èå®ç°
 * 
 * ä¸»æ–¹æ¡ˆï¼šä¸“ç”¨å…¨çƒé™†åœ°æ©ç æ–‡ä»¶ï¼ˆé«˜æ€§èƒ½ï¼‰
 * è¾…åŠ©æ–¹æ¡ˆï¼šæ°´æ·±æ•°æ®éªŒè¯ï¼ˆé«˜ç²¾åº¦ï¼‰
 */
class HybridLandMaskProcessor {
public:
    struct HybridConfig {
        // ä¸»è¦æ©ç æºï¼ˆé«˜æ€§èƒ½ï¼‰
        struct PrimaryMaskConfig {
            std::string globalLandMaskPath = "/data/masks/natural_earth_land_50m.shp";
            std::string coastalLandMaskPath = "/data/masks/gshhg_coastlines_f.shp";
            double coastalBufferKm = 10.0;  // æµ·å²¸å¸¦ç¼“å†²åŒº
        } primaryMaskConfig;
        
        // è¾…åŠ©æ°´æ·±æºï¼ˆé«˜ç²¾åº¦éªŒè¯ï¼‰
        struct BathymetryConfig {
            std::string globalBathymetryPath = "/data/bathymetry/gebco_2023.nc";
            std::string regionalBathymetryPath = "/data/bathymetry/regional/";
            double landSeaThreshold = 0.0;      // é™†æµ·åˆ†ç•Œé˜ˆå€¼ï¼ˆç±³ï¼‰
            double uncertaintyBuffer = 10.0;    // ä¸ç¡®å®šæ€§ç¼“å†²åŒºï¼ˆç±³ï¼‰
        } bathymetryConfig;
        
        // æ··åˆç­–ç•¥å‚æ•°
        bool enableBathymetryValidation = true;     // å¯ç”¨æ°´æ·±éªŒè¯
        double validationThreshold = 100.0;         // éªŒè¯é˜ˆå€¼ï¼ˆç±³ï¼Œè·ç¦»æµ·å²¸çº¿ï¼‰
        bool preferBathymetryNearCoast = true;      // æµ·å²¸çº¿é™„è¿‘ä¼˜å…ˆä½¿ç”¨æ°´æ·±
    };
    
    /**
     * @brief æ··åˆé™†åœ°æ©ç æŸ¥è¯¢ - æ¨èæ–¹æ¡ˆ
     */
    boost::future<LandMaskResult> queryHybridMask(
        const Point& point, const HybridConfig& config) {
        
        return boost::async([this, point, config]() {
            LandMaskResult result;
            
            // ğŸ¯ ç¬¬ä¸€æ­¥ï¼šå¿«é€Ÿæ©ç æ–‡ä»¶æŸ¥è¯¢
            auto primaryResult = queryShapefileMask(point, config.primaryMaskConfig);
            
            if (primaryResult == OCEAN) {
                // æ˜ç¡®çš„æµ·æ´‹åŒºåŸŸï¼Œç›´æ¥è¿”å›
                result.locationType = LandMaskResult::LocationType::OCEAN;
                result.oceanPercentage = 1.0;
                result.processingNote = "åŸºäºNatural Earthæ•°æ®ç¡®å®šä¸ºæµ·æ´‹åŒºåŸŸ";
                
            } else if (primaryResult == LAND) {
                // å¯èƒ½çš„é™†åœ°åŒºåŸŸï¼Œæ ¹æ®é…ç½®å†³å®šæ˜¯å¦éªŒè¯
                if (config.enableBathymetryValidation) {
                    // ğŸ¯ ç¬¬äºŒæ­¥ï¼šæ°´æ·±éªŒè¯ï¼ˆä»…åœ¨å¿…è¦æ—¶ï¼‰
                    auto bathyResult = queryBathymetryDepth(point, config.bathymetryConfig);
                    
                    if (bathyResult < -10.0) {  // æ·±åº¦è¶…è¿‡10ç±³ï¼Œç¡®è®¤ä¸ºæµ·æ´‹
                        result.locationType = LandMaskResult::LocationType::OCEAN;
                        result.processingNote = "æ©ç æ˜¾ç¤ºé™†åœ°ï¼Œä½†GEBCOæ°´æ·±æ•°æ®è¡¨æ˜ä¸ºæµ·æ´‹";
                    } else {
                        result.locationType = LandMaskResult::LocationType::LAND;
                        result.processingNote = "æ©ç æ–‡ä»¶å’Œæ°´æ·±æ•°æ®å‡ç¡®è®¤ä¸ºé™†åœ°";
                    }
                } else {
                    result.locationType = LandMaskResult::LocationType::LAND;
                    result.processingNote = "åŸºäºNatural Earthæ•°æ®ç¡®å®šä¸ºé™†åœ°åŒºåŸŸ";
                }
                
            } else if (primaryResult == COASTLINE) {
                // æµ·å²¸çº¿åŒºåŸŸï¼Œä½¿ç”¨æ°´æ·±ç²¾ç¡®åˆ¤æ–­
                auto bathyResult = queryBathymetryDepth(point, config.bathymetryConfig);
                result.locationType = (bathyResult < 0) ? 
                    LandMaskResult::LocationType::OCEAN : 
                    LandMaskResult::LocationType::LAND;
                result.processingNote = "GSHHGæµ·å²¸çº¿åŒºåŸŸï¼ŒåŸºäºGEBCOæ°´æ·±æ•°æ®ç²¾ç¡®åˆ¤æ–­";
            }
            
            return result;
        });
    }
    
    /**
     * @brief å¤§åŒºåŸŸé™†åœ°æ··åˆå¤„ç†
     */
    boost::future<LandMaskResult> analyzeRegionalLandMask(
        const SpatialQueryMetadata& spatialMetadata) {
        
        return boost::async([this, spatialMetadata]() {
            LandMaskResult result;
            
            // ğŸ¯ è·å–æŸ¥è¯¢åŒºåŸŸçš„é™†åœ°æ©ç ç»Ÿè®¡
            auto maskStats = calculateRegionalMaskStatistics(
                spatialMetadata.processedSpatial.queryBounds);
            
            result.oceanPercentage = maskStats.oceanPercentage;
            result.landPercentage = maskStats.landPercentage;
            
            // ğŸ¯ æ ¹æ®æµ·æ´‹è¦†ç›–æ¯”ä¾‹ç¡®å®šå¤„ç†ç­–ç•¥
            if (result.oceanPercentage > 0.95) {
                result.locationType = LandMaskResult::LocationType::OCEAN;
                result.processingNote = "åŒºåŸŸä¸»è¦ä¸ºæµ·æ´‹ï¼Œå¯ç›´æ¥å¤„ç†";
                
            } else if (result.oceanPercentage < 0.05) {
                result.locationType = LandMaskResult::LocationType::LAND;
                result.processingNote = "åŒºåŸŸä¸»è¦ä¸ºé™†åœ°ï¼Œæ— æµ·æ´‹æ•°æ®å¯æå–";
                
            } else {
                result.locationType = LandMaskResult::LocationType::MIXED;
                // ğŸ¯ æå–æµ·æ´‹åŒºåŸŸå‡ ä½•
                result.oceanAreas = extractOceanPolygons(spatialMetadata.processedSpatial.queryBounds);
                result.landAreas = extractLandPolygons(spatialMetadata.processedSpatial.queryBounds);
                result.processingNote = "æ··åˆåŒºåŸŸï¼Œå°†ä»…å¤„ç†æµ·æ´‹éƒ¨åˆ†";
            }
            
            return result;
        });
    }
};

}
```

#### 4.4.2 å…¨çƒæ©ç æ•°æ®é›†èµ„æº

**æ¨èçš„å…¨çƒé™†åœ°æ©ç æ•°æ®é›†åŠä¸‹è½½é“¾æ¥ï¼š**

1. **Natural Earth Land (æ¨èä¸»æ•°æ®æº)**
   - **å®˜æ–¹ç½‘ç«™**: https://www.naturalearthdata.com/
   - **ä¸‹è½½é“¾æ¥**: 
     - é«˜ç²¾åº¦(10m): https://www.naturalearthdata.com/http//www.naturalearthdata.com/download/10m/physical/ne_10m_land.zip
     - ä¸­ç²¾åº¦(50m): https://www.naturalearthdata.com/http//www.naturalearthdata.com/download/50m/physical/ne_50m_land.zip
     - ä½ç²¾åº¦(110m): https://www.naturalearthdata.com/http//www.naturalearthdata.com/download/110m/physical/ne_110m_land.zip
   - **ç‰¹ç‚¹**: 
     - é«˜è´¨é‡çš„å…¨çƒé™†åœ°è¾¹ç•Œæ•°æ®
     - å¤šåˆ†è¾¨ç‡é€‰æ‹©ï¼Œé€‚åˆä¸åŒç²¾åº¦éœ€æ±‚
     - å®šæœŸæ›´æ–°ï¼Œæ•°æ®å‡†ç¡®æ€§é«˜
     - æ”¯æŒShapefileå’ŒGeoJSONæ ¼å¼

2. **GSHHG (Global Self-consistent, Hierarchical, High-resolution Geography)**
   - **å®˜æ–¹ç½‘ç«™**: https://www.soest.hawaii.edu/pwessel/gshhg/
   - **ä¸‹è½½é“¾æ¥**: 
     - å®Œæ•´æ•°æ®é›†: https://www.soest.hawaii.edu/pwessel/gshhg/gshhg-shp-2.3.7.zip
     - æµ·å²¸çº¿æ•°æ®: https://www.soest.hawaii.edu/pwessel/gshhg/gshhg-bin-2.3.7.tar.gz
   - **ç‰¹ç‚¹**:
     - æé«˜ç²¾åº¦çš„å…¨çƒæµ·å²¸çº¿æ•°æ®
     - åˆ†çº§æ•°æ®ç»“æ„(Full, High, Intermediate, Low, Crude)
     - åŒ…å«æ¹–æ³Šã€å²›å±¿ç­‰å¤æ‚åœ°ç†è¦ç´ 
     - ç”¨äºä¸“ä¸šåˆ¶å›¾å’Œç§‘å­¦ç ”ç©¶

3. **GADM (Global Administrative Areas)**
   - **å®˜æ–¹ç½‘ç«™**: https://gadm.org/
   - **ä¸‹è½½é“¾æ¥**: https://gadm.org/download_world.html
   - **ç‰¹ç‚¹**:
     - å…¨çƒè¡Œæ”¿è¾¹ç•Œæ•°æ®
     - åŒ…å«å›½å®¶ã€çœä»½ã€å¸‚å¿çº§è¾¹ç•Œ
     - å¯ä½œä¸ºé™†åœ°æ©ç çš„è¡¥å……æ•°æ®æº

4. **OSM Land Polygons (OpenStreetMap)**
   - **å®˜æ–¹ç½‘ç«™**: https://osmdata.openstreetmap.de/
   - **ä¸‹è½½é“¾æ¥**: 
     - å¤§é™†: https://osmdata.openstreetmap.de/data/land-polygons-complete-4326.zip
     - åˆ†ç‰‡: https://osmdata.openstreetmap.de/data/land-polygons-split-4326.zip
   - **ç‰¹ç‚¹**:
     - åŸºäºOpenStreetMapæ•°æ®
     - æ›´æ–°é¢‘ç‡é«˜
     - å¼€æºå…è´¹

**æ¨èçš„å…¨çƒæ°´æ·±æ•°æ®é›†ï¼š**

1. **GEBCO (General Bathymetric Chart of the Oceans)**
   - **å®˜æ–¹ç½‘ç«™**: https://www.gebco.net/
   - **ä¸‹è½½é“¾æ¥**: 
     - GEBCO 2023: https://www.gebco.net/data_and_products/gridded_bathymetry_data/gebco_2023/
     - ç›´æ¥ä¸‹è½½: https://www.bodc.ac.uk/data/open_download/gebco/gebco_2023/zip/
   - **ç‰¹ç‚¹**:
     - å…¨çƒæœ€æƒå¨çš„æ°´æ·±æ•°æ®é›†
     - 15å¼§ç§’åˆ†è¾¨ç‡(çº¦450ç±³)
     - æŒç»­æ›´æ–°ï¼Œæ•°æ®è´¨é‡é«˜

2. **ETOPO Global Relief Models**
   - **å®˜æ–¹ç½‘ç«™**: https://www.ncei.noaa.gov/products/etopo-global-relief-model
   - **ä¸‹è½½é“¾æ¥**: https://www.ngdc.noaa.gov/mgg/global/
   - **ç‰¹ç‚¹**:
     - NOAAæä¾›çš„å…¨çƒåœ°å½¢æ°´æ·±æ¨¡å‹
     - å¤šç§åˆ†è¾¨ç‡é€‰æ‹©
     - åŒ…å«é™†åœ°åœ°å½¢å’Œæµ·åº•åœ°å½¢

**é…ç½®ç¤ºä¾‹ï¼š**

```cpp
/**
 * @brief ç”Ÿäº§ç¯å¢ƒæ¨èé…ç½®
 */
struct ProductionLandMaskConfig {
    // ğŸ¯ ä¸»è¦æ•°æ®æºé…ç½®
    PrimaryMaskConfig primaryMask {
        .globalLandMaskPath = "/data/masks/ne_50m_land.shp",          // Natural Earth 50m
        .coastalLandMaskPath = "/data/masks/gshhg_coastlines_h.shp",  // GSHHG Highç²¾åº¦
        .coastalBufferKm = 10.0
    };
    
    // ğŸ¯ è¾…åŠ©æ•°æ®æºé…ç½®
    BathymetryConfig bathymetry {
        .globalBathymetryPath = "/data/bathymetry/gebco_2023.nc",     // GEBCO 2023
        .regionalBathymetryPath = "/data/bathymetry/regional/",
        .landSeaThreshold = 0.0,
        .uncertaintyBuffer = 10.0
    };
    
    // ğŸ¯ æ€§èƒ½ä¼˜åŒ–é…ç½®
    PerformanceConfig performance {
        .enableSpatialCache = true,
        .cacheSize = 1000,
        .enableRegionalPreload = true,
        .preloadBufferKm = 50.0
    };
};
```

### 4.5 å¢å¼ºçš„ç©ºé—´è¯·æ±‚è§£æå™¨

```cpp
/**
 * @brief å¢å¼ºçš„ç©ºé—´è¯·æ±‚è§£æå™¨ - é›†æˆé™†åœ°æ©ç å¤„ç†
 */
class EnhancedSpatialRequestResolver : public SpatialRequestResolver {
public:
    /**
     * @brief å¢å¼ºçš„ç©ºé—´æŸ¥è¯¢å…ƒæ•°æ® - åŒ…å«é™†åœ°æ©ç ä¿¡æ¯
     */
    struct EnhancedSpatialQueryMetadata : public SpatialQueryMetadata {
        // ğŸ¯ é™†åœ°æ©ç å¤„ç†ç»“æœ
        HybridLandMaskProcessor::LandMaskResult landMaskResult;
        
        // ğŸ¯ æµ·æ´‹æ•°æ®è¯»å–æ©ç 
        std::optional<Polygon> oceanDataMask;
        
        // ğŸ¯ å¤„ç†ç­–ç•¥
        enum class ProcessingStrategy {
            DIRECT_OCEAN_PROCESSING,    // ç›´æ¥æµ·æ´‹å¤„ç†
            MASKED_OCEAN_PROCESSING,    // æ©ç æµ·æ´‹å¤„ç†
            LAND_ONLY_WARNING,          // ä»…é™†åœ°è­¦å‘Š
            MIXED_REGION_PROCESSING     // æ··åˆåŒºåŸŸå¤„ç†
        } processingStrategy;
        
        // ğŸ¯ ç”¨æˆ·é€šçŸ¥ä¿¡æ¯
        struct UserNotification {
            bool hasLandAreas = false;
            double landCoveragePercentage = 0.0;
            std::string landProcessingNote;
            std::vector<std::string> userWarnings;
        } userNotification;
    };
    
    /**
     * @brief å¢å¼ºçš„ç©ºé—´è¯·æ±‚è§£æ - ç¬¬äºŒæ­¥å®Œæ•´ç‰ˆ
     */
    boost::future<EnhancedSpatialQueryMetadata> resolveEnhancedSpatialRequest(
        const DataWorkflowRequest& request,
        std::shared_ptr<SpatialOpsService> spatialService,
        std::shared_ptr<HybridLandMaskProcessor> landMaskProcessor) {
        
        return boost::async([this, request, spatialService, landMaskProcessor]() {
            EnhancedSpatialQueryMetadata metadata;
            
            // ğŸ¯ æ‰§è¡ŒåŸºç¡€ç©ºé—´è§£æ
            auto baseMetadata = resolveSpatialRequest(request, spatialService).get();
            static_cast<SpatialQueryMetadata&>(metadata) = baseMetadata;
            
            // ğŸ¯ æ‰§è¡Œé™†åœ°æ©ç åˆ†æ
            if (metadata.requestType == "point") {
                metadata.landMaskResult = landMaskProcessor->queryHybridMask(
                    std::get<Point>(metadata.originalRequest), 
                    landMaskProcessor->getConfig()).get();
            } else {
                metadata.landMaskResult = landMaskProcessor->analyzeRegionalLandMask(metadata).get();
            }
            
            // ğŸ¯ ç¡®å®šå¤„ç†ç­–ç•¥
            determineProcessingStrategy(metadata, landMaskProcessor);
            
            // ğŸ¯ ç”Ÿæˆç”¨æˆ·é€šçŸ¥
            generateUserNotifications(metadata);
            
            return metadata;
        });
    }
};
```

## 5. æ™ºèƒ½æ’å€¼å†³ç­–é€»è¾‘

### 5.1 æ’å€¼éœ€æ±‚åˆ†æå™¨

```cpp
/**
 * @brief æ™ºèƒ½æ’å€¼éœ€æ±‚åˆ†æå™¨
 */
class InterpolationNeedsAnalyzer {
public:
    /**
     * @brief æ’å€¼éœ€æ±‚åˆ†æç»“æœ
     */
    struct InterpolationNeeds {
        bool needsHorizontalInterpolation = false;
        bool needsVerticalInterpolation = false;
        bool needsTemporalInterpolation = false;
        
        // æ’å€¼æ¯”ä¾‹
        double horizontalInterpolationRatio = 1.0;
        double verticalInterpolationRatio = 1.0;
        double temporalInterpolationRatio = 1.0;
        
        // æ¨èç®—æ³•
        SpatialResolutionConfig::InterpolationAlgorithm recommendedAlgorithm;
        
        // æ€§èƒ½è¯„ä¼°
        enum class PerformanceImpact {
            MINIMAL,    // æœ€å°å½±å“
            MODERATE,   // ä¸­ç­‰å½±å“
            SIGNIFICANT // æ˜¾è‘—å½±å“
        } performanceImpact;
        
        std::string reasoningExplanation;   // å†³ç­–è¯´æ˜
    };
    
    /**
     * @brief åˆ†ææ’å€¼éœ€æ±‚
     */
    InterpolationNeeds analyzeInterpolationNeeds(
        const SpatialResolutionConfig& userRequirements,
        const DatabaseMetadataForIntelligentReading& dataMetadata) {
        
        InterpolationNeeds needs;
        
        // ğŸ¯ æ°´å¹³æ’å€¼éœ€æ±‚åˆ†æ
        needs.needsHorizontalInterpolation = analyzeHorizontalInterpolationNeeds(
            userRequirements.horizontalResolution, dataMetadata, needs);
        
        // ğŸ¯ å‚ç›´æ’å€¼éœ€æ±‚åˆ†æ  
        needs.needsVerticalInterpolation = analyzeVerticalInterpolationNeeds(
            userRequirements.verticalResolution, dataMetadata, needs);
        
        // ğŸ¯ æ¨èç®—æ³•é€‰æ‹©
        needs.recommendedAlgorithm = selectOptimalInterpolationAlgorithm(
            userRequirements, dataMetadata, needs);
        
        // ğŸ¯ æ€§èƒ½å½±å“è¯„ä¼°
        needs.performanceImpact = assessPerformanceImpact(needs);
        
        // ğŸ¯ ç”Ÿæˆå†³ç­–è¯´æ˜
        needs.reasoningExplanation = generateReasoningExplanation(needs, userRequirements, dataMetadata);
        
        return needs;
    }

private:
    bool analyzeHorizontalInterpolationNeeds(
        const SpatialResolutionConfig::HorizontalResolution& userHorizontal,
        const DatabaseMetadataForIntelligentReading& dataMetadata,
        InterpolationNeeds& needs) {
        
        if (userHorizontal.mode == SpatialResolutionConfig::HorizontalResolution::Mode::ORIGINAL) {
            return false; // ä½¿ç”¨åŸå§‹ç²¾åº¦ï¼Œæ— éœ€æ’å€¼
        }
        
        if (!userHorizontal.targetResolutionMeters.has_value()) {
            return false; // æœªæŒ‡å®šç›®æ ‡ç²¾åº¦
        }
        
        double targetRes = userHorizontal.targetResolutionMeters.value();
        double dataResX = dataMetadata.spatialCoverage.spatialResolutionX.value_or(1000.0);
        double dataResY = dataMetadata.spatialCoverage.spatialResolutionY.value_or(1000.0);
        double dataRes = std::min(dataResX, dataResY); // ä½¿ç”¨è¾ƒç»†çš„åˆ†è¾¨ç‡
        
        if (targetRes < dataRes) {
            // ç›®æ ‡ç²¾åº¦é«˜äºæ•°æ®ç²¾åº¦ï¼Œéœ€è¦æ’å€¼
            needs.horizontalInterpolationRatio = dataRes / targetRes;
            return true;
        }
        
        return false;
    }
    
    bool analyzeVerticalInterpolationNeeds(
        const SpatialResolutionConfig::VerticalResolution& userVertical,
        const DatabaseMetadataForIntelligentReading& dataMetadata,
        InterpolationNeeds& needs) {
        
        if (userVertical.mode == SpatialResolutionConfig::VerticalResolution::Mode::ORIGINAL) {
            return false;
        }
        
        if (!userVertical.targetResolutionMeters.has_value()) {
            return false;
        }
        
        double targetRes = userVertical.targetResolutionMeters.value();
        double dataRes = dataMetadata.spatialCoverage.depthResolution.value_or(100.0);
        
        if (targetRes < dataRes) {
            needs.verticalInterpolationRatio = dataRes / targetRes;
            return true;
        }
        
        return false;
    }
    
    SpatialResolutionConfig::InterpolationAlgorithm selectOptimalInterpolationAlgorithm(
        const SpatialResolutionConfig& userRequirements,
        const DatabaseMetadataForIntelligentReading& dataMetadata,
        const InterpolationNeeds& needs) {
        
        if (userRequirements.interpolationAlgorithm != SpatialResolutionConfig::InterpolationAlgorithm::AUTO) {
            return userRequirements.interpolationAlgorithm;
        }
        
        // åŸºäºæ•°æ®ç‰¹å¾è‡ªåŠ¨é€‰æ‹©
        if (dataMetadata.dataCategory == "ocean_environment") {
            // æµ·æ´‹ç¯å¢ƒæ•°æ®é€šå¸¸æ¯”è¾ƒå¹³æ»‘
            if (needs.horizontalInterpolationRatio > 4.0) {
                return SpatialResolutionConfig::InterpolationAlgorithm::BICUBIC;
            } else {
                return SpatialResolutionConfig::InterpolationAlgorithm::BILINEAR;
            }
        } else if (dataMetadata.dataCategory == "topography") {
            // åœ°å½¢æ•°æ®å¯èƒ½æœ‰é”åˆ©è¾¹ç¼˜
            if (needs.horizontalInterpolationRatio > 2.0) {
                return SpatialResolutionConfig::InterpolationAlgorithm::LANCZOS;
            } else {
                return SpatialResolutionConfig::InterpolationAlgorithm::BILINEAR;
            }
        } else {
            // é»˜è®¤ä½¿ç”¨åŒçº¿æ€§æ’å€¼
            return SpatialResolutionConfig::InterpolationAlgorithm::BILINEAR;
        }
    }
};
```

## 5. å‰ç«¯åˆ°åç«¯çš„APIè¯·æ±‚å‚æ•°

### 5.1 REST APIæ¥å£å®šä¹‰

```json
{
  "endpoint": "POST /api/v1/workflow/data-processing",
  "description": "æ‰§è¡Œæ•°æ®å¤„ç†å·¥ä½œæµ",
  "request_schema": {
    "spatial_request": {
      "type": "object",
      "description": "ç©ºé—´æŸ¥è¯¢è¯·æ±‚",
      "oneOf": [
        {
          "type": "point",
          "coordinates": [longitude, latitude],
          "optional_depth": "number_in_meters"
        },
        {
          "type": "bounding_box", 
          "bounds": {
            "min_longitude": "number",
            "max_longitude": "number", 
            "min_latitude": "number",
            "max_latitude": "number",
            "min_depth": "optional_number",
            "max_depth": "optional_number"
          }
        },
        {
          "type": "polygon",
          "coordinates": "array_of_coordinate_arrays"
        },
        {
          "type": "bearing_distance",
          "start_point": [longitude, latitude],
          "bearing": "number_in_degrees",
          "distance": "number_in_meters"
        }
      ]
    },
    
    "data_source_mode": {
      "type": "string",
      "enum": ["direct_files", "database_query"]
    },
    
    "direct_file_params": {
      "type": "object",
      "description": "ç›´æ¥æ–‡ä»¶æ¨¡å¼å‚æ•°",
      "when": "data_source_mode == 'direct_files'",
      "properties": {
        "file_specs": {
          "type": "array",
          "items": {
            "file_path": "string",
            "variable_names": ["array_of_strings"],
            "depth_dimension": {
              "specific_depths": "optional_array_of_numbers",
              "min_depth": "optional_number",
              "max_depth": "optional_number",
              "layer_indices": "optional_array_of_integers",
              "depth_unit": "string_default_meters",
              "depth_positive": "string_default_down"
            },
            "crs_handling": {
              "user_crs": "string_default_EPSG:4326",
              "expected_data_crs": "optional_string",
              "enable_auto_detection": "boolean_default_true",
              "enable_transformation": "boolean_default_true",
              "preferred_output_crs": "string_default_EPSG:4326"
            },
            "spatial_resolution": {
              "horizontal_resolution": {
                "mode": "enum[original, specified]",
                "target_resolution_meters": "optional_number",
                "target_resolution_x": "optional_number",
                "target_resolution_y": "optional_number"
              },
              "vertical_resolution": {
                "mode": "enum[original, specified, adaptive]", 
                "target_resolution_meters": "optional_number",
                "min_resolution_meters": "optional_number",
                "max_resolution_meters": "optional_number"
              },
              "interpolation_algorithm": "enum[auto, nearest, bilinear, bicubic, lanczos]",
              "thresholds": {
                "horizontal_improvement_threshold": "number_default_0.5",
                "vertical_improvement_threshold": "number_default_0.5",
                "max_interpolation_ratio": "number_default_10.0"
              }
            }
          }
        }
      }
    },
    
    "database_query_params": {
      "type": "object", 
      "description": "æ•°æ®åº“æŸ¥è¯¢æ¨¡å¼å‚æ•°",
      "when": "data_source_mode == 'database_query'",
      "properties": {
        "variable_names": ["array_of_strings"],
        "time_range": {
          "start_time": "ISO8601_datetime",
          "end_time": "ISO8601_datetime"
        },
        "dataset_type": "optional_string",
        "min_quality_score": "optional_number_0_to_1",
        "min_depth": "optional_number",
        "max_depth": "optional_number", 
        "depth_layers": "optional_array_of_strings",
        "spatial_resolution": "same_as_direct_file_spatial_resolution",
        "enable_geohash_optimization": "boolean_default_true",
        "prefer_high_quality": "boolean_default_true",
        "max_results": "integer_default_100"
      }
    },
    
    "processing_options": {
      "type": "object",
      "description": "å…¨å±€å¤„ç†é€‰é¡¹",
      "properties": {
        "target_crs": "optional_string",
        "enable_crs_transformation": "boolean_default_true",
        "enable_advanced_interpolation": "boolean_default_true",
        "interpolation_tolerance": "optional_number",
        "fusion_strategy": "enum[mosaic, average, weighted_average, latest_priority]",
        "enable_quality_check": "boolean_default_true",
        "min_data_quality": "number_default_0.5"
      }
    },
    
    "output_options": {
      "type": "object",
      "description": "è¾“å‡ºé…ç½®",
      "properties": {
        "format": "enum[netcdf, geotiff, csv, json, memory_object]",
        "output_path": "optional_string",
        "max_file_size_mb": "optional_integer",
        "enable_compression": "boolean_default_true",
        "include_metadata": "boolean_default_true",
        "include_processing_history": "boolean_default_true"
      }
    },
    
    "workflow_options": {
      "type": "object",
      "description": "å·¥ä½œæµæ§åˆ¶é€‰é¡¹",
      "properties": {
        "workflow_id": "optional_string",
        "priority": "integer_1_to_10_default_5",
        "timeout_seconds": "integer_default_300",
        "enable_progress_callback": "boolean_default_true",
        "enable_error_recovery": "boolean_default_true",
        "max_retries": "integer_default_3"
      }
    }
  }
}
```

### 5.2 å‰ç«¯è¯·æ±‚ç¤ºä¾‹

#### 5.2.1 ç›´æ¥æ–‡ä»¶æ¨¡å¼ç¤ºä¾‹

```json
{
  "spatial_request": {
    "type": "bounding_box",
    "bounds": {
      "min_longitude": 120.0,
      "max_longitude": 125.0,
      "min_latitude": 30.0,
      "max_latitude": 35.0,
      "min_depth": 0.0,
      "max_depth": 1000.0
    }
  },
  "data_source_mode": "direct_files",
  "direct_file_params": {
    "file_specs": [
      {
        "file_path": "/data/ocean/temperature_2024.nc",
        "variable_names": ["temperature", "salinity"],
        "depth_dimension": {
          "specific_depths": [0, 10, 20, 50, 100, 200, 500, 1000],
          "depth_unit": "meters",
          "depth_positive": "down"
        },
        "crs_handling": {
          "user_crs": "EPSG:4326",
          "enable_auto_detection": true,
          "enable_transformation": true
        },
        "spatial_resolution": {
          "horizontal_resolution": {
            "mode": "specified",
            "target_resolution_meters": 1000.0
          },
          "vertical_resolution": {
            "mode": "specified", 
            "target_resolution_meters": 5.0
          },
          "interpolation_algorithm": "auto"
        }
      }
    ]
  },
  "processing_options": {
    "enable_advanced_interpolation": true,
    "fusion_strategy": "mosaic"
  },
  "output_options": {
    "format": "netcdf",
    "output_path": "/output/result.nc",
    "enable_compression": true
  }
}
```

#### 5.2.2 æ•°æ®åº“æŸ¥è¯¢æ¨¡å¼ç¤ºä¾‹

```json
{
  "spatial_request": {
    "type": "point",
    "coordinates": [122.5, 32.5],
    "optional_depth": 100.0
  },
  "data_source_mode": "database_query",
  "database_query_params": {
    "variable_names": ["sea_surface_temperature", "chlorophyll_concentration"],
    "time_range": {
      "start_time": "2024-01-01T00:00:00Z",
      "end_time": "2024-12-31T23:59:59Z"
    },
    "min_quality_score": 0.8,
    "spatial_resolution": {
      "horizontal_resolution": {
        "mode": "original"
      },
      "vertical_resolution": {
        "mode": "original"
      }
    },
    "prefer_high_quality": true,
    "max_results": 50
  },
  "processing_options": {
    "target_crs": "EPSG:4326",
    "enable_quality_check": true
  },
  "output_options": {
    "format": "csv",
    "include_metadata": true
  }
}
```

## 6. å“åº”æ ¼å¼

### 6.1 æˆåŠŸå“åº”

```json
{
  "success": true,
  "workflow_id": "wf_20241220_001234",
  "status": "completed",
  "execution_time_ms": 15420,
  "result": {
    "output_location": "/output/result.nc",
    "data_points_processed": 1000000,
    "data_volume_mb": 45.6,
    "interpolation_applied": {
      "horizontal_interpolation": true,
      "vertical_interpolation": false,
      "algorithm_used": "bilinear",
      "performance_impact": "moderate"
    },
    "crs_transformations": [
      {
        "from": "EPSG:4326", 
        "to": "EPSG:32650",
        "transformation_type": "query_geometry"
      }
    ],
    "metadata": {
      "spatial_bounds": {
        "min_longitude": 120.0,
        "max_longitude": 125.0,
        "min_latitude": 30.0,
        "max_latitude": 35.0
      },
      "temporal_range": {
        "start_time": "2024-01-01T00:00:00Z",
        "end_time": "2024-01-31T23:59:59Z"  
      },
      "variables_included": ["temperature", "salinity"],
      "depth_layers": [0, 10, 20, 50, 100, 200, 500, 1000],
      "data_quality_score": 0.92
    }
  },
  "processing_history": [
    {
      "step": "spatial_request_resolution",
      "duration_ms": 150,
      "status": "completed"
    },
    {
      "step": "data_source_discovery", 
      "duration_ms": 2340,
      "status": "completed",
      "files_found": 3
    },
    {
      "step": "intelligent_data_reading",
      "duration_ms": 8950,
      "status": "completed",
      "strategy_used": "chunked_reading"
    },
    {
      "step": "data_processing_pipeline",
      "duration_ms": 3890,
      "status": "completed",
      "interpolation_applied": true
    },
    {
      "step": "output_generation",
      "duration_ms": 90,
      "status": "completed"
    }
  ]
}
```

### 6.2 é”™è¯¯å“åº”

```json
{
  "success": false,
  "error": {
    "code": "INTERPOLATION_FAILED",
    "message": "æ’å€¼å¤„ç†å¤±è´¥ï¼šç›®æ ‡åˆ†è¾¨ç‡è¶…å‡ºåˆç†èŒƒå›´",
    "details": {
      "requested_resolution": 0.1,
      "source_resolution": 1000.0,
      "max_interpolation_ratio": 10.0,
      "actual_ratio": 10000.0
    },
    "suggestions": [
      "è¯·è°ƒæ•´ç›®æ ‡åˆ†è¾¨ç‡åˆ°åˆç†èŒƒå›´å†…",
      "è€ƒè™‘ä½¿ç”¨æ›´é«˜åˆ†è¾¨ç‡çš„æºæ•°æ®",
      "å¢åŠ max_interpolation_ratioå‚æ•°"
    ]
  },
  "workflow_id": "wf_20241220_001235",
  "partial_results": null,
  "retry_possible": true
}
```

### 4.6 ç©ºé—´è®¡ç®—èŒè´£åˆ†å·¥åŸåˆ™

#### 4.6.1 æœåŠ¡èŒè´£æ˜ç¡®åˆ’åˆ†

**ç©ºé—´è®¡ç®—ç”±SpatialOpsServiceç»Ÿä¸€å®Œæˆ**ï¼Œå…¶ä»–æœåŠ¡ä¸æ‰¿æ‹…ç©ºé—´è®¡ç®—èŒè´£ï¼š

```cpp
/**
 * @brief ç©ºé—´è®¡ç®—æœåŠ¡èŒè´£åˆ’åˆ†
 */
namespace oscean::spatial_computing {

/**
 * @brief SpatialOpsService - æ ¸å¿ƒç©ºé—´è®¡ç®—æœåŠ¡
 * èŒè´£ï¼šé«˜çº§ç©ºé—´åˆ†æå’Œå‡ ä½•å¤„ç†
 */
class SpatialOpsService {
public:
    // ğŸ¯ æ ¸å¿ƒå‡ ä½•è¿ç®—ï¼ˆç”±SpatialOpsServiceè´Ÿè´£ï¼‰
    boost::future<BoundingBox> calculateBoundingBox(const SpatialRequest& request);
    boost::future<double> calculateArea(const BoundingBox& bounds);
    boost::future<Polygon> createBufferedBounds(const BoundingBox& bounds, double bufferMeters);
    boost::future<std::vector<BoundingBox>> createSpatialChunks(const BoundingBox& bounds, double chunkSizeMeters);
    boost::future<Polygon> simplifyPolygon(const Polygon& polygon, double toleranceMeters);
    
    // ğŸ¯ åæ ‡è½¬æ¢ï¼ˆé€šè¿‡é›†æˆPROJåº“ï¼‰
    boost::future<Point> transformPoint(const Point& point, const std::string& fromCRS, const std::string& toCRS);
    boost::future<Polygon> transformPolygon(const Polygon& polygon, const std::string& fromCRS, const std::string& toCRS);
    
    // ğŸ¯ ç©ºé—´å…³ç³»æŸ¥è¯¢
    boost::future<bool> intersects(const Polygon& poly1, const Polygon& poly2);
    boost::future<bool> contains(const Polygon& container, const Point& point);
    boost::future<double> distance(const Point& point1, const Point& point2);
};

/**
 * @brief ä¸“é—¨æœåŠ¡ - è°ƒç”¨SpatialOpsServiceè¿›è¡Œè®¡ç®—
 */
class LandMaskProcessor {
    // âœ… æ­£ç¡®ï¼šè°ƒç”¨SpatialOpsServiceè¿›è¡Œç©ºé—´è®¡ç®—
    boost::future<bool> isPointInOcean(const Point& point) {
        return spatialOpsService_->contains(oceanPolygon_, point);
    }
    
private:
    std::shared_ptr<SpatialOpsService> spatialOpsService_;
};

class DataAccessService {
    // âœ… æ­£ç¡®ï¼šè°ƒç”¨SpatialOpsServiceè¿›è¡Œç©ºé—´åˆ†æ
    boost::future<std::vector<std::string>> findDataFilesInRegion(const BoundingBox& region) {
        auto expandedRegion = spatialOpsService_->createBufferedBounds(region, 1000.0).get();
        // ä½¿ç”¨æ‰©å±•åŒºåŸŸè¿›è¡Œæ–‡ä»¶æŸ¥æ‰¾...
    }
    
private:
    std::shared_ptr<SpatialOpsService> spatialOpsService_;
};

}
```

#### 4.6.2 ç¬¬äºŒæ­¥å®Œæ•´å·¥ä½œæµç¨‹

```cpp
/**
 * @brief ç¬¬äºŒæ­¥ï¼šç©ºé—´è¯·æ±‚è§£æä¸æ•°æ®è¯»å–å‡†å¤‡ - å®Œæ•´æµç¨‹
 */
class Step2Orchestrator {
public:
    struct Step2Result {
        EnhancedSpatialQueryMetadata spatialMetadata;
        UnifiedGridConfig gridConfig;
        PointInterpolationConfig interpolationConfig;
        DatabaseMetadataForIntelligentReading requiredMetadata;
        
        // å·¥ä½œæµç¼–æ’ç»“æœ
        bool readyForDataReading = false;
        std::string nextStepRecommendation;
        std::vector<std::string> preparationWarnings;
    };
    
    /**
     * @brief æ‰§è¡Œç¬¬äºŒæ­¥å®Œæ•´æµç¨‹
     */
    boost::future<Step2Result> executeStep2(
        const DataWorkflowRequest& request,
        std::shared_ptr<SpatialOpsService> spatialService,
        std::shared_ptr<HybridLandMaskProcessor> landMaskProcessor) {
        
        return boost::async([this, request, spatialService, landMaskProcessor]() {
            Step2Result result;
            
            // ğŸ¯ 2.1 ç©ºé—´è¯·æ±‚è§£æ
            result.spatialMetadata = enhancedSpatialResolver_->resolveEnhancedSpatialRequest(
                request, spatialService, landMaskProcessor).get();
            
            // ğŸ¯ 2.2 ç»Ÿä¸€ç½‘æ ¼ç”Ÿæˆ
            result.gridConfig = unifiedGridSystem_->generateUnifiedGrid(
                result.spatialMetadata, request.directFileParams->fileSpecs[0].spatialResolution);
            
            // ğŸ¯ 2.3 æ’å€¼é…ç½®ç”Ÿæˆï¼ˆå¦‚æœæ˜¯ç‚¹æŸ¥è¯¢ï¼‰
            if (result.spatialMetadata.requestType == "point") {
                result.interpolationConfig = pointInterpolationAnalyzer_->analyzePointInterpolation(
                    std::get<Point>(result.spatialMetadata.originalRequest),
                    result.spatialMetadata,
                    result.requiredMetadata);
            }
            
            // ğŸ¯ 2.4 ç¡®å®šæ™ºèƒ½è¯†åˆ«å™¨æ‰€éœ€çš„å…ƒæ•°æ®è¦æ±‚
            result.requiredMetadata = determineRequiredMetadataForIntelligentReading(
                result.spatialMetadata, result.gridConfig);
            
            // ğŸ¯ 2.5 éªŒè¯å‡†å¤‡å®Œæ•´æ€§
            result.readyForDataReading = validatePreparationCompleteness(result);
            
            // ğŸ¯ 2.6 ç”Ÿæˆä¸‹ä¸€æ­¥å»ºè®®
            if (result.readyForDataReading) {
                result.nextStepRecommendation = "è¿›å…¥ç¬¬ä¸‰æ­¥ï¼šæ™ºèƒ½æ•°æ®è¯»å–";
            } else {
                result.nextStepRecommendation = "éœ€è¦è¡¥å……å‡†å¤‡å·¥ä½œ";
            }
            
            return result;
        });
    }
    
private:
    std::shared_ptr<EnhancedSpatialRequestResolver> enhancedSpatialResolver_;
    std::shared_ptr<UnifiedGridSystem> unifiedGridSystem_;
    std::shared_ptr<PointQueryInterpolationAnalyzer> pointInterpolationAnalyzer_;
};
```

## 6. ç¬¬ä¸‰æ­¥ï¼šæ™ºèƒ½æ•°æ®è¯»å–

### 6.1 æ™ºèƒ½è¯»å–å™¨å‚æ•°ä¼ é€’è®¾è®¡

ç¬¬äºŒæ­¥å®Œæˆåï¼Œéœ€è¦å°†å‡†å¤‡ç»“æœè½¬åŒ–ä¸ºé«˜æ•ˆçš„æ•°æ®è¯»å–æ“ä½œã€‚æ™ºèƒ½è¯»å–å™¨éœ€è¦æ¥æ”¶å®Œæ•´çš„ä¸Šä¸‹æ–‡ä¿¡æ¯æ¥åšå‡ºæœ€ä¼˜å†³ç­–ã€‚

```cpp
/**
 * @brief æ™ºèƒ½è¯»å–å™¨è¾“å…¥å‚æ•° - ç¬¬ä¸‰æ­¥æ ¸å¿ƒå‚æ•°
 */
struct IntelligentReaderParameters {
    // =============================================================================
    // ğŸ¯ ç¬¬äºŒæ­¥ä¼ é€’çš„æ ¸å¿ƒä¿¡æ¯
    // =============================================================================
    
    // ç©ºé—´è§£æç»“æœ
    EnhancedSpatialQueryMetadata spatialMetadata;
    
    // ç½‘æ ¼é…ç½®
    UnifiedGridConfig gridConfig;
    
    // æ’å€¼é…ç½®ï¼ˆå¦‚æœéœ€è¦ï¼‰
    std::optional<PointInterpolationConfig> interpolationConfig;
    
    // æ•°æ®åº“å…ƒæ•°æ®ï¼ˆå¦‚æœæ˜¯æ•°æ®åº“æŸ¥è¯¢æ¨¡å¼ï¼‰
    std::optional<DatabaseMetadataForIntelligentReading> databaseMetadata;
    
    // =============================================================================
    // ğŸ¯ è¯»å–ç­–ç•¥é…ç½®
    // =============================================================================
    
    struct ReadingStrategy {
        enum class AccessPattern {
            SEQUENTIAL_SCAN,        // é¡ºåºæ‰«æï¼ˆå¤§åŒºåŸŸï¼‰
            RANDOM_ACCESS,          // éšæœºè®¿é—®ï¼ˆç‚¹æŸ¥è¯¢ï¼‰
            CHUNKED_READING,        // åˆ†å—è¯»å–ï¼ˆä¸­ç­‰åŒºåŸŸï¼‰
            STREAMING_PROCESSING,   // æµå¼å¤„ç†ï¼ˆè¶…å¤§æ–‡ä»¶ï¼‰
            MEMORY_MAPPED,          // å†…å­˜æ˜ å°„ï¼ˆé¢‘ç¹è®¿é—®ï¼‰
            PARALLEL_READING        // å¹¶è¡Œè¯»å–ï¼ˆå¤šæ–‡ä»¶ï¼‰
        } accessPattern;
        
        // æ€§èƒ½ä¼˜åŒ–é…ç½®
        struct PerformanceConfig {
            bool enableSIMD = true;                     // å¯ç”¨SIMDä¼˜åŒ–
            bool enableCaching = true;                  // å¯ç”¨æ™ºèƒ½ç¼“å­˜
            bool enableMemoryOptimization = true;       // å¯ç”¨å†…å­˜ä¼˜åŒ–
            bool enableAsyncProcessing = true;          // å¯ç”¨å¼‚æ­¥å¤„ç†
            bool enableProgressTracking = true;         // å¯ç”¨è¿›åº¦è·Ÿè¸ª
            
            // èµ„æºé™åˆ¶
            size_t maxMemoryUsageMB = 1024;            // æœ€å¤§å†…å­˜ä½¿ç”¨ï¼ˆMBï¼‰
            size_t maxConcurrentOperations = 8;        // æœ€å¤§å¹¶å‘æ“ä½œæ•°
            double timeoutSeconds = 300.0;             // è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰
            
            // SIMDç‰¹å®šé…ç½®
            struct SIMDConfig {
                oscean::common_utils::simd::SIMDImplementation implementation = 
                    oscean::common_utils::simd::SIMDImplementation::AUTO_DETECT;
                size_t batchSize = 1024;               // æ‰¹å¤„ç†å¤§å°
                std::vector<std::string> optimizedOperations = {
                    "interpolation", "statistics", "transformation"
                };
            } simdConfig;
            
            // ç¼“å­˜ç‰¹å®šé…ç½®
            struct CacheConfig {
                size_t maxCacheSizeMB = 256;           // æœ€å¤§ç¼“å­˜å¤§å°ï¼ˆMBï¼‰
                std::chrono::minutes ttlMinutes{30};   // ç¼“å­˜ç”Ÿå­˜æ—¶é—´
                bool enablePersistent = false;         // æŒä¹…åŒ–ç¼“å­˜
                std::string cacheStrategy = "LRU";     // ç¼“å­˜ç­–ç•¥
            } cacheConfig;
            
            // æµå¼å¤„ç†é…ç½®
            struct StreamingConfig {
                size_t chunkSizeMB = 64;               // æ•°æ®å—å¤§å°ï¼ˆMBï¼‰
                size_t maxConcurrentChunks = 4;        // æœ€å¤§å¹¶å‘å—æ•°
                bool enableBackpressure = true;        // å¯ç”¨èƒŒå‹æ§åˆ¶
                bool enableCompression = false;        // å¯ç”¨å‹ç¼©
            } streamingConfig;
            
        } performanceConfig;
        
        // æ•°æ®è´¨é‡é…ç½®
        struct QualityConfig {
            bool enableQualityCheck = true;            // å¯ç”¨è´¨é‡æ£€æŸ¥
            double minDataQuality = 0.5;              // æœ€ä½æ•°æ®è´¨é‡
            bool skipInvalidData = true;               // è·³è¿‡æ— æ•ˆæ•°æ®
            bool enableDataValidation = true;          // å¯ç”¨æ•°æ®éªŒè¯
            
            // æ’å€¼è´¨é‡æ§åˆ¶
            double maxInterpolationDistance = 10000.0; // æœ€å¤§æ’å€¼è·ç¦»ï¼ˆç±³ï¼‰
            double interpolationQualityThreshold = 0.8; // æ’å€¼è´¨é‡é˜ˆå€¼
        } qualityConfig;
        
    } readingStrategy;
    
    // =============================================================================
    // ğŸ¯ æ•°æ®è®¿é—®é…ç½®
    // =============================================================================
    
    struct DataAccessConfig {
        // æ–‡ä»¶è®¿é—®å‚æ•°
        std::vector<std::string> filePaths;           // æ–‡ä»¶è·¯å¾„åˆ—è¡¨
        std::vector<std::string> variableNames;       // å˜é‡ååˆ—è¡¨
        
        // ç©ºé—´è®¿é—®å‚æ•°
        std::optional<oscean::core_services::BoundingBox> spatialBounds;
        std::optional<oscean::core_services::Point> targetPoint;
        
        // æ—¶é—´è®¿é—®å‚æ•°
        std::optional<oscean::core_services::TimeRange> timeRange;
        std::optional<std::chrono::system_clock::time_point> targetTime;
        
        // æ·±åº¦è®¿é—®å‚æ•°
        std::optional<std::vector<double>> targetDepths;
        std::optional<double> minDepth, maxDepth;
        
        // åˆ†è¾¨ç‡å‚æ•°
        std::optional<double> targetHorizontalResolution;  // ç›®æ ‡æ°´å¹³åˆ†è¾¨ç‡ï¼ˆç±³ï¼‰
        std::optional<double> targetVerticalResolution;    // ç›®æ ‡å‚ç›´åˆ†è¾¨ç‡ï¼ˆç±³ï¼‰
        
        // é‡é‡‡æ ·å‚æ•°
        oscean::core_services::ResampleAlgorithm resampleAlgorithm = 
            oscean::core_services::ResampleAlgorithm::BILINEAR;
        std::string interpolationMethod = "bilinear";
        
        // è¾“å‡ºæ ¼å¼å‚æ•°
        bool includeMetadata = true;                   // åŒ…å«å…ƒæ•°æ®
        bool includeQualityInfo = true;               // åŒ…å«è´¨é‡ä¿¡æ¯
        bool includeProcessingHistory = true;         // åŒ…å«å¤„ç†å†å²
        
    } dataAccessConfig;
    
    // =============================================================================
    // ğŸ¯ å·¥ä½œæµæ§åˆ¶å‚æ•°
    // =============================================================================
    
    struct WorkflowControl {
        std::string workflowId;                       // å·¥ä½œæµID
        std::string stepId = "step3_intelligent_reading"; // æ­¥éª¤ID
        int priority = 5;                             // ä¼˜å…ˆçº§ï¼ˆ1-10ï¼‰
        
        // è¿›åº¦å›è°ƒ
        std::function<void(double progress, const std::string& status)> progressCallback;
        
        // é”™è¯¯å¤„ç†
        bool enableErrorRecovery = true;              // å¯ç”¨é”™è¯¯æ¢å¤
        int maxRetries = 3;                          // æœ€å¤§é‡è¯•æ¬¡æ•°
        std::chrono::seconds retryDelay{5};          // é‡è¯•å»¶è¿Ÿ
        
        // å–æ¶ˆæ§åˆ¶
        std::shared_ptr<std::atomic<bool>> cancellationToken; // å–æ¶ˆä»¤ç‰Œ
        
    } workflowControl;
    
    // =============================================================================
    // ğŸ¯ æ™ºèƒ½å†³ç­–æç¤º
    // =============================================================================
    
    struct IntelligentHints {
        // æ•°æ®ç‰¹å¾æç¤º
        std::string dataCategory;                     // æ•°æ®ç±»åˆ«ï¼ˆocean_environment, topographyç­‰ï¼‰
        std::string dataPattern;                      // æ•°æ®æ¨¡å¼ï¼ˆregular_grid, irregular_pointsç­‰ï¼‰
        double estimatedDataVolume;                   // é¢„ä¼°æ•°æ®é‡ï¼ˆMBï¼‰
        
        // æ€§èƒ½æç¤º
        ReadingStrategy::AccessPattern recommendedAccessPattern;
        std::vector<std::string> performanceOptimizations; // æ¨èçš„æ€§èƒ½ä¼˜åŒ–
        
        // è´¨é‡æç¤º
        double expectedDataQuality;                   // é¢„æœŸæ•°æ®è´¨é‡
        std::vector<std::string> qualityWarnings;    // è´¨é‡è­¦å‘Š
        
        // å¤„ç†æç¤º
        bool needsInterpolation;                      // éœ€è¦æ’å€¼
        bool needsCRSTransformation;                  // éœ€è¦åæ ‡è½¬æ¢
        bool needsTemporalAlignment;                  // éœ€è¦æ—¶é—´å¯¹é½
        
    } intelligentHints;
    
    // =============================================================================
    // ğŸ¯ ä¾¿æ·æ„é€ æ–¹æ³•
    // =============================================================================
    
    /**
     * @brief ä»ç¬¬äºŒæ­¥ç»“æœåˆ›å»ºæ™ºèƒ½è¯»å–å™¨å‚æ•°
     */
    static IntelligentReaderParameters fromStep2Result(
        const Step2Orchestrator::Step2Result& step2Result,
        const DataWorkflowRequest& originalRequest) {
        
        IntelligentReaderParameters params;
        
        // ğŸ¯ å¤åˆ¶ç¬¬äºŒæ­¥ç»“æœ
        params.spatialMetadata = step2Result.spatialMetadata;
        params.gridConfig = step2Result.gridConfig;
        params.interpolationConfig = step2Result.interpolationConfig;
        params.databaseMetadata = step2Result.requiredMetadata;
        
        // ğŸ¯ æ ¹æ®åŸå§‹è¯·æ±‚é…ç½®æ•°æ®è®¿é—®
        if (originalRequest.dataSourceMode == DataWorkflowRequest::DataSourceMode::DIRECT_FILES) {
            configureForDirectFiles(params, originalRequest.directFileParams.value());
        } else {
            configureForDatabaseQuery(params, originalRequest.databaseQueryParams.value());
        }
        
        // ğŸ¯ ç”Ÿæˆæ™ºèƒ½å†³ç­–æç¤º
        generateIntelligentHints(params, step2Result);
        
        // ğŸ¯ é…ç½®å·¥ä½œæµæ§åˆ¶
        params.workflowControl.workflowId = originalRequest.workflowOptions.workflowId;
        params.workflowControl.priority = originalRequest.workflowOptions.priority;
        
        return params;
    }
    
private:
    static void configureForDirectFiles(IntelligentReaderParameters& params, 
                                      const DataWorkflowRequest::DirectFileParams& directParams);
    static void configureForDatabaseQuery(IntelligentReaderParameters& params,
                                        const DataWorkflowRequest::DatabaseQueryParams& dbParams);
    static void generateIntelligentHints(IntelligentReaderParameters& params,
                                       const Step2Orchestrator::Step2Result& step2Result);
};
```

### 6.2 æ™ºèƒ½è¯»å–ç­–ç•¥é€‰æ‹©å™¨

```cpp
/**
 * @brief æ™ºèƒ½è¯»å–ç­–ç•¥é€‰æ‹©å™¨
 * 
 * æ ¹æ®è¾“å…¥å‚æ•°è‡ªåŠ¨é€‰æ‹©æœ€ä¼˜çš„è¯»å–ç­–ç•¥å’Œé…ç½®
 */
class IntelligentReadingStrategySelector {
public:
    /**
     * @brief ç­–ç•¥é€‰æ‹©ç»“æœ
     */
    struct StrategySelectionResult {
        IntelligentReaderParameters::ReadingStrategy::AccessPattern selectedPattern;
        std::string selectionReasoning;                // é€‰æ‹©ç†ç”±
        
        // ä¼˜åŒ–çš„é…ç½®
        IntelligentReaderParameters::ReadingStrategy::PerformanceConfig optimizedPerformanceConfig;
        
        // é¢„æœŸæ€§èƒ½æŒ‡æ ‡
        struct PerformanceExpectation {
            double estimatedProcessingTimeSeconds;      // é¢„ä¼°å¤„ç†æ—¶é—´
            double estimatedMemoryUsageMB;             // é¢„ä¼°å†…å­˜ä½¿ç”¨
            double estimatedIOOperations;              // é¢„ä¼°IOæ“ä½œæ•°
            double confidenceLevel;                    // é¢„ä¼°ç½®ä¿¡åº¦
        } performanceExpectation;
        
        // é£é™©è¯„ä¼°
        std::vector<std::string> potentialRisks;       // æ½œåœ¨é£é™©
        std::vector<std::string> mitigationStrategies; // ç¼“è§£ç­–ç•¥
    };
    
    /**
     * @brief é€‰æ‹©æœ€ä¼˜è¯»å–ç­–ç•¥
     */
    StrategySelectionResult selectOptimalStrategy(
        const IntelligentReaderParameters& params) {
        
        StrategySelectionResult result;
        
        // ğŸ¯ åŸºäºç©ºé—´ç‰¹å¾é€‰æ‹©è®¿é—®æ¨¡å¼
        result.selectedPattern = selectAccessPatternBySpaceCharacteristics(params);
        
        // ğŸ¯ åŸºäºæ•°æ®é‡ä¼˜åŒ–æ€§èƒ½é…ç½®
        result.optimizedPerformanceConfig = optimizePerformanceConfig(params, result.selectedPattern);
        
        // ğŸ¯ é¢„ä¼°æ€§èƒ½æŒ‡æ ‡
        result.performanceExpectation = estimatePerformance(params, result);
        
        // ğŸ¯ è¯„ä¼°é£é™©å’Œç¼“è§£ç­–ç•¥
        assessRisksAndMitigations(params, result);
        
        // ğŸ¯ ç”Ÿæˆé€‰æ‹©ç†ç”±
        result.selectionReasoning = generateSelectionReasoning(params, result);
        
        return result;
    }
    
private:
    IntelligentReaderParameters::ReadingStrategy::AccessPattern 
    selectAccessPatternBySpaceCharacteristics(const IntelligentReaderParameters& params) {
        
        const auto& spatial = params.spatialMetadata.processedSpatial;
        
        // ğŸ¯ ç‚¹æŸ¥è¯¢ - éšæœºè®¿é—®
        if (params.spatialMetadata.requestType == "point") {
            return IntelligentReaderParameters::ReadingStrategy::AccessPattern::RANDOM_ACCESS;
        }
        
        // ğŸ¯ å¤§åŒºåŸŸæŸ¥è¯¢ - æ ¹æ®é¢ç§¯å†³å®š
        if (spatial.spatialExtentArea > 100000000.0) { // 100å¹³æ–¹å…¬é‡Œ
            // è¶…å¤§åŒºåŸŸï¼Œä½¿ç”¨æµå¼å¤„ç†
            return IntelligentReaderParameters::ReadingStrategy::AccessPattern::STREAMING_PROCESSING;
        } else if (spatial.spatialExtentArea > 10000000.0) { // 10å¹³æ–¹å…¬é‡Œ
            // å¤§åŒºåŸŸï¼Œä½¿ç”¨åˆ†å—è¯»å–
            return IntelligentReaderParameters::ReadingStrategy::AccessPattern::CHUNKED_READING;
        } else {
            // å°åŒºåŸŸï¼Œé¡ºåºæ‰«æ
            return IntelligentReaderParameters::ReadingStrategy::AccessPattern::SEQUENTIAL_SCAN;
        }
    }
    
    IntelligentReaderParameters::ReadingStrategy::PerformanceConfig 
    optimizePerformanceConfig(const IntelligentReaderParameters& params,
                            IntelligentReaderParameters::ReadingStrategy::AccessPattern pattern) {
        
        IntelligentReaderParameters::ReadingStrategy::PerformanceConfig config;
        
        // ğŸ¯ æ ¹æ®è®¿é—®æ¨¡å¼ä¼˜åŒ–é…ç½®
        switch (pattern) {
            case IntelligentReaderParameters::ReadingStrategy::AccessPattern::RANDOM_ACCESS:
                // ç‚¹æŸ¥è¯¢ä¼˜åŒ–ï¼šå¯ç”¨ç¼“å­˜ï¼Œå‡å°‘å¹¶å‘
                config.enableCaching = true;
                config.maxConcurrentOperations = 2;
                config.cacheConfig.maxCacheSizeMB = 128;
                config.simdConfig.batchSize = 256; // è¾ƒå°æ‰¹æ¬¡
                break;
                
            case IntelligentReaderParameters::ReadingStrategy::AccessPattern::STREAMING_PROCESSING:
                // æµå¼å¤„ç†ä¼˜åŒ–ï¼šå¤§å—ï¼Œé«˜å¹¶å‘
                config.enableAsyncProcessing = true;
                config.maxConcurrentOperations = 16;
                config.streamingConfig.chunkSizeMB = 128;
                config.streamingConfig.maxConcurrentChunks = 8;
                config.enableMemoryOptimization = true;
                break;
                
            case IntelligentReaderParameters::ReadingStrategy::AccessPattern::CHUNKED_READING:
                // åˆ†å—è¯»å–ä¼˜åŒ–ï¼šå¹³è¡¡é…ç½®
                config.enableSIMD = true;
                config.maxConcurrentOperations = 8;
                config.streamingConfig.chunkSizeMB = 64;
                config.cacheConfig.maxCacheSizeMB = 256;
                break;
                
            default:
                // é»˜è®¤é…ç½®
                break;
        }
        
        // ğŸ¯ æ ¹æ®æ•°æ®ç‰¹å¾è¿›ä¸€æ­¥ä¼˜åŒ–
        if (params.intelligentHints.dataCategory == "ocean_environment") {
            // æµ·æ´‹æ•°æ®é€šå¸¸ç©ºé—´è¿ç»­æ€§å¥½ï¼Œé€‚åˆSIMDä¼˜åŒ–
            config.enableSIMD = true;
            config.simdConfig.optimizedOperations.push_back("interpolation");
        }
        
        return config;
    }
};
```

### 6.3 é«˜çº§åŠŸèƒ½è°ƒç”¨æ¥å£

```cpp
/**
 * @brief æ™ºèƒ½æ•°æ®è¯»å–å™¨ - ç¬¬ä¸‰æ­¥æ ¸å¿ƒæ‰§è¡Œå™¨
 */
class IntelligentDataReader {
public:
    /**
     * @brief è¯»å–ç»“æœ
     */
    struct ReadingResult {
        bool success = false;
        std::string errorMessage;
        
        // è¯»å–çš„æ•°æ®
        std::variant<
            std::shared_ptr<oscean::core_services::GridData>,
            std::shared_ptr<oscean::core_services::FeatureCollection>,
            std::shared_ptr<oscean::core_services::TimeSeriesData>,
            std::shared_ptr<oscean::core_services::VerticalProfileData>
        > data;
        
        // å¤„ç†ç»Ÿè®¡
        struct ProcessingStats {
            std::chrono::milliseconds processingTime;
            size_t bytesRead;
            size_t dataPointsProcessed;
            double dataQualityScore;
            bool interpolationApplied;
            bool crsTransformationApplied;
            std::vector<std::string> optimizationsUsed;
        } processingStats;
        
        // è´¨é‡ä¿¡æ¯
        struct QualityInfo {
            double overallQuality;
            std::vector<std::string> qualityWarnings;
            std::map<std::string, double> variableQualityScores;
        } qualityInfo;
    };
    
    /**
     * @brief æ‰§è¡Œæ™ºèƒ½æ•°æ®è¯»å– - ç¬¬ä¸‰æ­¥ä¸»æ–¹æ³•
     */
    boost::future<ReadingResult> executeIntelligentReading(
        const IntelligentReaderParameters& params) {
        
        return boost::async([this, params]() -> ReadingResult {
            ReadingResult result;
            auto startTime = std::chrono::steady_clock::now();
            
            try {
                // ğŸ¯ 3.1 ç­–ç•¥é€‰æ‹©
                auto strategy = strategySelector_->selectOptimalStrategy(params);
                
                // ğŸ¯ 3.2 é…ç½®æ•°æ®è®¿é—®æœåŠ¡
                configureDataAccessService(strategy);
                
                // ğŸ¯ 3.3 æ‰§è¡Œæ•°æ®è¯»å–
                result = executeDataReading(params, strategy);
                
                // ğŸ¯ 3.4 åº”ç”¨åå¤„ç†ï¼ˆæ’å€¼ã€è½¬æ¢ç­‰ï¼‰
                applyPostProcessing(result, params, strategy);
                
                // ğŸ¯ 3.5 è´¨é‡è¯„ä¼°
                evaluateDataQuality(result, params);
                
                // ğŸ¯ 3.6 ç”Ÿæˆå¤„ç†ç»Ÿè®¡
                generateProcessingStats(result, startTime, strategy);
                
                result.success = true;
                
            } catch (const std::exception& e) {
                result.success = false;
                result.errorMessage = e.what();
            }
            
            return result;
        });
    }
    
private:
    std::shared_ptr<IntelligentReadingStrategySelector> strategySelector_;
    std::shared_ptr<oscean::core_services::data_access::IUnifiedDataAccessService> dataAccessService_;
    
    /**
     * @brief é…ç½®æ•°æ®è®¿é—®æœåŠ¡çš„é«˜çº§åŠŸèƒ½
     */
    void configureDataAccessService(const IntelligentReadingStrategySelector::StrategySelectionResult& strategy) {
        
        // ğŸ¯ åˆ›å»ºé«˜çº§é…ç½®
        oscean::core_services::data_access::api::DataAccessConfiguration config;
        
        // åŸºç¡€æ€§èƒ½é…ç½®
        config.maxConcurrentRequests = strategy.optimizedPerformanceConfig.maxConcurrentOperations;
        config.maxMemoryUsageMB = strategy.optimizedPerformanceConfig.maxMemoryUsageMB;
        config.requestTimeoutSeconds = strategy.optimizedPerformanceConfig.timeoutSeconds;
        
        // SIMDä¼˜åŒ–é…ç½®
        config.enableSIMD = strategy.optimizedPerformanceConfig.enableSIMD;
        
        // ç¼“å­˜é…ç½®
        config.enableCaching = strategy.optimizedPerformanceConfig.enableCaching;
        config.gridDataCacheSize = strategy.optimizedPerformanceConfig.cacheConfig.maxCacheSizeMB * 1024 * 1024;
        
        // æµå¼å¤„ç†é…ç½®
        config.defaultChunkSize = strategy.optimizedPerformanceConfig.streamingConfig.chunkSizeMB * 1024 * 1024;
        
        // ğŸ¯ é‡æ–°é…ç½®æœåŠ¡ï¼ˆå¦‚æœæ”¯æŒåŠ¨æ€é…ç½®ï¼‰
        // dataAccessService_->reconfigure(config);
    }
    
    /**
     * @brief æ‰§è¡Œæ•°æ®è¯»å– - è°ƒç”¨é«˜çº§åŠŸèƒ½
     */
    ReadingResult executeDataReading(
        const IntelligentReaderParameters& params,
        const IntelligentReadingStrategySelector::StrategySelectionResult& strategy) {
        
        ReadingResult result;
        
        // ğŸ¯ æ ¹æ®è®¿é—®æ¨¡å¼é€‰æ‹©è¯»å–æ–¹æ³•
        switch (strategy.selectedPattern) {
            case IntelligentReaderParameters::ReadingStrategy::AccessPattern::RANDOM_ACCESS:
                result = executePointQuery(params);
                break;
                
            case IntelligentReaderParameters::ReadingStrategy::AccessPattern::STREAMING_PROCESSING:
                result = executeStreamingReading(params, strategy);
                break;
                
            case IntelligentReaderParameters::ReadingStrategy::AccessPattern::CHUNKED_READING:
                result = executeChunkedReading(params, strategy);
                break;
                
            case IntelligentReaderParameters::ReadingStrategy::AccessPattern::SEQUENTIAL_SCAN:
                result = executeSequentialReading(params);
                break;
                
            case IntelligentReaderParameters::ReadingStrategy::AccessPattern::PARALLEL_READING:
                result = executeParallelReading(params, strategy);
                break;
                
            default:
                throw std::runtime_error("ä¸æ”¯æŒçš„è®¿é—®æ¨¡å¼");
        }
        
        return result;
    }
    
    /**
     * @brief æ‰§è¡Œç‚¹æŸ¥è¯¢ - ä½¿ç”¨æ’å€¼åŠŸèƒ½
     */
    ReadingResult executePointQuery(const IntelligentReaderParameters& params) {
        ReadingResult result;
        
        if (!params.interpolationConfig.has_value()) {
            throw std::runtime_error("ç‚¹æŸ¥è¯¢éœ€è¦æ’å€¼é…ç½®");
        }
        
        const auto& interpConfig = params.interpolationConfig.value();
        const auto& point = std::get<oscean::core_services::Point>(params.spatialMetadata.originalRequest);
        
        // ğŸ¯ ä½¿ç”¨é«˜çº§ç‚¹æŸ¥è¯¢åŠŸèƒ½
        for (const auto& filePath : params.dataAccessConfig.filePaths) {
            for (const auto& variableName : params.dataAccessConfig.variableNames) {
                
                // è°ƒç”¨æ•°æ®è®¿é—®æœåŠ¡çš„ç‚¹æŸ¥è¯¢åŠŸèƒ½
                auto pointValue = dataAccessService_->readPointValueAsync(
                    filePath, variableName, 
                    point.longitude, point.latitude,
                    params.dataAccessConfig.targetDepths.has_value() ? 
                        std::optional<double>(params.dataAccessConfig.targetDepths.value()[0]) : std::nullopt,
                    params.dataAccessConfig.targetTime
                ).get();
                
                if (pointValue.has_value()) {
                    // åˆ›å»ºç‚¹æ•°æ®ç»“æœ
                    auto gridData = std::make_shared<oscean::core_services::GridData>();
                    gridData->values = {pointValue.value()};
                    gridData->width = 1;
                    gridData->height = 1;
                    gridData->variableName = variableName;
                    
                    result.data = gridData;
                    result.processingStats.interpolationApplied = true;
                    break;
                }
            }
        }
        
        return result;
    }
    
    /**
     * @brief æ‰§è¡Œæµå¼è¯»å– - ä½¿ç”¨æµå¼å¤„ç†åŠŸèƒ½
     */
    ReadingResult executeStreamingReading(
        const IntelligentReaderParameters& params,
        const IntelligentReadingStrategySelector::StrategySelectionResult& strategy) {
        
        ReadingResult result;
        
        // ğŸ¯ åˆ›å»ºæµå¼å¤„ç†å™¨
        class WorkflowStreamProcessor : public oscean::core_services::data_access::IStreamProcessor {
        public:
            std::vector<double> accumulatedData;
            std::atomic<size_t> chunksProcessed{0};
            
            bool processChunk(const std::vector<double>& chunk, 
                            const std::map<std::string, std::any>& chunkInfo) override {
                accumulatedData.insert(accumulatedData.end(), chunk.begin(), chunk.end());
                chunksProcessed++;
                return true; // ç»§ç»­å¤„ç†
            }
            
            void onStreamComplete() override {
                // æµå¼å¤„ç†å®Œæˆ
            }
            
            void onStreamError(const std::string& error) override {
                throw std::runtime_error("æµå¼å¤„ç†é”™è¯¯: " + error);
            }
        };
        
        auto streamProcessor = std::make_shared<WorkflowStreamProcessor>();
        
        // ğŸ¯ é…ç½®å¤§æ–‡ä»¶è¯»å–
        oscean::core_services::data_access::LargeFileReadConfig streamConfig;
        streamConfig.chunkSizeBytes = strategy.optimizedPerformanceConfig.streamingConfig.chunkSizeMB * 1024 * 1024;
        streamConfig.maxMemoryUsageBytes = strategy.optimizedPerformanceConfig.maxMemoryUsageMB * 1024 * 1024;
        streamConfig.enableProgressCallback = true;
        streamConfig.enableMemoryOptimization = strategy.optimizedPerformanceConfig.enableMemoryOptimization;
        
        // ğŸ¯ å¯åŠ¨é«˜çº§æµå¼å¤„ç†
        for (const auto& filePath : params.dataAccessConfig.filePaths) {
            for (const auto& variableName : params.dataAccessConfig.variableNames) {
                
                dataAccessService_->startAdvancedStreamingAsync(
                    filePath, variableName, streamProcessor, streamConfig
                ).get();
                
                // åˆ›å»ºç½‘æ ¼æ•°æ®ç»“æœ
                auto gridData = std::make_shared<oscean::core_services::GridData>();
                gridData->values = std::move(streamProcessor->accumulatedData);
                gridData->variableName = variableName;
                
                result.data = gridData;
                result.processingStats.dataPointsProcessed = gridData->values.size();
                break;
            }
        }
        
        return result;
    }
    
    /**
     * @brief æ‰§è¡Œåˆ†å—è¯»å– - ä½¿ç”¨æ‰¹é‡å¤„ç†åŠŸèƒ½
     */
    ReadingResult executeChunkedReading(
        const IntelligentReaderParameters& params,
        const IntelligentReadingStrategySelector::StrategySelectionResult& strategy) {
        
        ReadingResult result;
        
        // ğŸ¯ åˆ›å»ºæ‰¹é‡è¯·æ±‚
        std::vector<oscean::core_services::data_access::api::UnifiedDataRequest> batchRequests;
        
        for (const auto& filePath : params.dataAccessConfig.filePaths) {
            for (const auto& variableName : params.dataAccessConfig.variableNames) {
                
                oscean::core_services::data_access::api::UnifiedDataRequest request;
                request.requestType = oscean::core_services::data_access::api::UnifiedRequestType::GRID_DATA;
                request.filePath = filePath;
                request.variableName = variableName;
                request.spatialBounds = params.dataAccessConfig.spatialBounds;
                request.timeRange = params.dataAccessConfig.timeRange;
                request.includeMetadata = params.dataAccessConfig.includeMetadata;
                
                batchRequests.push_back(request);
            }
        }
        
        // ğŸ¯ æ‰§è¡Œæ‰¹é‡å¤„ç†
        auto batchResponses = dataAccessService_->processBatchRequestsAsync(batchRequests).get();
        
        // ğŸ¯ åˆå¹¶ç»“æœ
        for (const auto& response : batchResponses) {
            if (response.status == oscean::core_services::data_access::api::UnifiedResponseStatus::SUCCESS) {
                if (std::holds_alternative<std::shared_ptr<oscean::core_services::GridData>>(response.data)) {
                    result.data = std::get<std::shared_ptr<oscean::core_services::GridData>>(response.data);
                    break;
                }
            }
        }
        
                 return result;
     }
 };
```

### 6.4 é«˜çº§åŠŸèƒ½è°ƒç”¨çš„æœ€é«˜æ•ˆç­–ç•¥

åŸºäºç°æœ‰çš„æ•°æ®è®¿é—®æœåŠ¡æ¶æ„ï¼Œç¬¬ä¸‰æ­¥çš„é«˜æ•ˆå®ç°å…³é”®åœ¨äºï¼š

#### 6.4.1 ä¼ é€’ç»™è¯»å–å™¨çš„æ ¸å¿ƒå‚æ•°

```cpp
/**
 * @brief é«˜æ•ˆæ•°æ®è¯»å–çš„å…³é”®å‚æ•°æ˜ å°„
 */
struct HighPerformanceReadingParameters {
    // =============================================================================
    // ğŸ¯ ä»ç¬¬äºŒæ­¥ä¼ é€’çš„å¿…è¦å‚æ•°
    // =============================================================================
    
    // 1. ç©ºé—´ä¼˜åŒ–å‚æ•°
    struct SpatialOptimization {
        oscean::core_services::BoundingBox optimizedBounds;     // ä¼˜åŒ–åçš„è¾¹ç•Œæ¡†
        std::string targetCRS;                                  // ç›®æ ‡åæ ‡ç³»
        bool needsCRSTransformation;                           // æ˜¯å¦éœ€è¦åæ ‡è½¬æ¢
        double spatialBufferMeters = 0.0;                     // ç©ºé—´ç¼“å†²åŒº
        
        // ç½‘æ ¼ä¼˜åŒ–
        std::optional<double> targetResolutionMeters;          // ç›®æ ‡åˆ†è¾¨ç‡
        bool enableSpatialIndexing = true;                     // å¯ç”¨ç©ºé—´ç´¢å¼•
    } spatialOptimization;
    
    // 2. æ—¶é—´ä¼˜åŒ–å‚æ•°
    struct TemporalOptimization {
        std::optional<oscean::core_services::TimeRange> timeRange;
        std::optional<std::chrono::system_clock::time_point> targetTime;
        std::string temporalInterpolationMethod = "linear";    // æ—¶é—´æ’å€¼æ–¹æ³•
        bool enableTemporalCaching = true;                     // å¯ç”¨æ—¶é—´ç¼“å­˜
    } temporalOptimization;
    
    // 3. æ·±åº¦ä¼˜åŒ–å‚æ•°
    struct DepthOptimization {
        std::optional<std::vector<double>> targetDepths;       // ç›®æ ‡æ·±åº¦å±‚
        std::optional<double> minDepth, maxDepth;             // æ·±åº¦èŒƒå›´
        std::string depthInterpolationMethod = "linear";       // æ·±åº¦æ’å€¼æ–¹æ³•
        bool enableDepthIndexing = true;                      // å¯ç”¨æ·±åº¦ç´¢å¼•
    } depthOptimization;
    
    // 4. æ€§èƒ½ä¼˜åŒ–å‚æ•°
    struct PerformanceOptimization {
        // SIMDé…ç½®
        bool enableSIMD = true;
        oscean::common_utils::simd::SIMDImplementation simdImplementation = 
            oscean::common_utils::simd::SIMDImplementation::AUTO_DETECT;
        size_t simdBatchSize = 1024;
        
        // ç¼“å­˜é…ç½®
        bool enableCaching = true;
        size_t cacheSizeMB = 256;
        std::chrono::minutes cacheTTL{30};
        
        // å†…å­˜é…ç½®
        bool enableMemoryOptimization = true;
        size_t maxMemoryUsageMB = 1024;
        bool enableMemoryMapping = false;                      // å†…å­˜æ˜ å°„ï¼ˆå¤§æ–‡ä»¶ï¼‰
        
        // å¹¶å‘é…ç½®
        bool enableAsyncProcessing = true;
        size_t maxConcurrentOperations = 8;
        size_t threadPoolSize = 0;                            // 0=è‡ªåŠ¨æ£€æµ‹
        
        // æµå¼é…ç½®
        bool enableStreaming = false;                          // æ˜¯å¦å¯ç”¨æµå¼å¤„ç†
        size_t streamingChunkSizeMB = 64;                     // æµå¼å—å¤§å°
        size_t maxConcurrentChunks = 4;                      // æœ€å¤§å¹¶å‘å—æ•°
        
        // å‹ç¼©é…ç½®
        bool enableCompression = false;                        // æ•°æ®å‹ç¼©
        std::string compressionAlgorithm = "lz4";            // å‹ç¼©ç®—æ³•
        
    } performanceOptimization;
    
    // 5. è´¨é‡æ§åˆ¶å‚æ•°
    struct QualityControl {
        bool enableQualityCheck = true;                       // å¯ç”¨è´¨é‡æ£€æŸ¥
        double minDataQuality = 0.5;                         // æœ€ä½æ•°æ®è´¨é‡
        bool skipInvalidData = true;                          // è·³è¿‡æ— æ•ˆæ•°æ®
        bool enableDataValidation = true;                    // å¯ç”¨æ•°æ®éªŒè¯
        
        // æ’å€¼è´¨é‡æ§åˆ¶
        double maxInterpolationDistance = 10000.0;           // æœ€å¤§æ’å€¼è·ç¦»ï¼ˆç±³ï¼‰
        double interpolationQualityThreshold = 0.8;          // æ’å€¼è´¨é‡é˜ˆå€¼
        std::string interpolationMethod = "bilinear";         // æ’å€¼æ–¹æ³•
        
        // å¼‚å¸¸å€¼å¤„ç†
        bool enableOutlierDetection = true;                  // å¯ç”¨å¼‚å¸¸å€¼æ£€æµ‹
        double outlierThreshold = 3.0;                       // å¼‚å¸¸å€¼é˜ˆå€¼ï¼ˆæ ‡å‡†å·®å€æ•°ï¼‰
        
    } qualityControl;
};
```

#### 6.4.2 é«˜çº§åŠŸèƒ½è°ƒç”¨çš„æœ€ä¼˜ç­–ç•¥

```cpp
/**
 * @brief é«˜çº§åŠŸèƒ½è°ƒç”¨ä¼˜åŒ–å™¨
 * 
 * æ ¹æ®æ•°æ®ç‰¹å¾å’Œè¯·æ±‚ç±»å‹ï¼Œé€‰æ‹©æœ€ä¼˜çš„é«˜çº§åŠŸèƒ½ç»„åˆ
 */
class AdvancedFeatureOptimizer {
public:
    /**
     * @brief ä¼˜åŒ–ç­–ç•¥ç»“æœ
     */
    struct OptimizationStrategy {
        // æ¨èçš„è®¿é—®æ¨¡å¼
        enum class RecommendedAccessMode {
            DIRECT_MEMORY_ACCESS,      // ç›´æ¥å†…å­˜è®¿é—®ï¼ˆå°æ•°æ®ï¼‰
            CHUNKED_PROCESSING,        // åˆ†å—å¤„ç†ï¼ˆä¸­ç­‰æ•°æ®ï¼‰
            STREAMING_PROCESSING,      // æµå¼å¤„ç†ï¼ˆå¤§æ•°æ®ï¼‰
            MEMORY_MAPPED_ACCESS,      // å†…å­˜æ˜ å°„è®¿é—®ï¼ˆè¶…å¤§æ•°æ®ï¼‰
            PARALLEL_BATCH_PROCESSING  // å¹¶è¡Œæ‰¹å¤„ç†ï¼ˆå¤šæ–‡ä»¶ï¼‰
        } recommendedMode;
        
        // ä¼˜åŒ–çš„é…ç½®
        HighPerformanceReadingParameters optimizedParams;
        
        // é¢„æœŸæ€§èƒ½æå‡
        struct PerformanceGain {
            double expectedSpeedupFactor;                     // é¢„æœŸåŠ é€Ÿæ¯”
            double expectedMemoryReduction;                  // é¢„æœŸå†…å­˜å‡å°‘æ¯”ä¾‹
            double expectedIOReduction;                      // é¢„æœŸIOå‡å°‘æ¯”ä¾‹
            std::vector<std::string> enabledOptimizations;   // å¯ç”¨çš„ä¼˜åŒ–é¡¹
        } performanceGain;
        
        // å…·ä½“çš„è°ƒç”¨åºåˆ—
        std::vector<std::string> optimizedCallSequence;      // ä¼˜åŒ–çš„è°ƒç”¨åºåˆ—
    };
    
    /**
     * @brief ç”Ÿæˆæœ€ä¼˜è°ƒç”¨ç­–ç•¥
     */
    OptimizationStrategy generateOptimalStrategy(
        const IntelligentReaderParameters& params) {
        
        OptimizationStrategy strategy;
        
        // ğŸ¯ åŸºäºæ•°æ®é‡é€‰æ‹©è®¿é—®æ¨¡å¼
        double estimatedDataSizeMB = estimateDataSize(params);
        strategy.recommendedMode = selectAccessMode(estimatedDataSizeMB, params);
        
        // ğŸ¯ ä¼˜åŒ–å‚æ•°é…ç½®
        strategy.optimizedParams = optimizeParameters(params, strategy.recommendedMode);
        
        // ğŸ¯ ç”Ÿæˆè°ƒç”¨åºåˆ—
        strategy.optimizedCallSequence = generateCallSequence(strategy);
        
        // ğŸ¯ é¢„ä¼°æ€§èƒ½æå‡
        strategy.performanceGain = estimatePerformanceGain(strategy);
        
        return strategy;
    }
    
private:
    OptimizationStrategy::RecommendedAccessMode selectAccessMode(
        double dataSizeMB, const IntelligentReaderParameters& params) {
        
        // ğŸ¯ åŸºäºæ•°æ®å¤§å°çš„æ™ºèƒ½é€‰æ‹©
        if (dataSizeMB < 100) {
            // å°æ•°æ®ï¼šç›´æ¥å†…å­˜è®¿é—®
            return OptimizationStrategy::RecommendedAccessMode::DIRECT_MEMORY_ACCESS;
        } else if (dataSizeMB < 1000) {
            // ä¸­ç­‰æ•°æ®ï¼šåˆ†å—å¤„ç†
            return OptimizationStrategy::RecommendedAccessMode::CHUNKED_PROCESSING;
        } else if (dataSizeMB < 5000) {
            // å¤§æ•°æ®ï¼šæµå¼å¤„ç†
            return OptimizationStrategy::RecommendedAccessMode::STREAMING_PROCESSING;
        } else {
            // è¶…å¤§æ•°æ®ï¼šå†…å­˜æ˜ å°„æˆ–å¹¶è¡Œå¤„ç†
            if (params.dataAccessConfig.filePaths.size() > 1) {
                return OptimizationStrategy::RecommendedAccessMode::PARALLEL_BATCH_PROCESSING;
            } else {
                return OptimizationStrategy::RecommendedAccessMode::MEMORY_MAPPED_ACCESS;
            }
        }
    }
    
    std::vector<std::string> generateCallSequence(const OptimizationStrategy& strategy) {
        std::vector<std::string> sequence;
        
        // ğŸ¯ æ ¹æ®è®¿é—®æ¨¡å¼ç”Ÿæˆæœ€ä¼˜è°ƒç”¨åºåˆ—
        switch (strategy.recommendedMode) {
            case OptimizationStrategy::RecommendedAccessMode::DIRECT_MEMORY_ACCESS:
                sequence = {
                    "1. é…ç½®SIMDä¼˜åŒ–",
                    "2. å¯ç”¨æ™ºèƒ½ç¼“å­˜",
                    "3. è°ƒç”¨processDataRequestAsync()",
                    "4. åº”ç”¨è´¨é‡æ£€æŸ¥",
                    "5. è¿”å›ç»“æœ"
                };
                break;
                
            case OptimizationStrategy::RecommendedAccessMode::STREAMING_PROCESSING:
                sequence = {
                    "1. é…ç½®æµå¼å¤„ç†å‚æ•°",
                    "2. å¯ç”¨å†…å­˜ä¼˜åŒ–",
                    "3. åˆ›å»ºæµå¼å¤„ç†å™¨",
                    "4. è°ƒç”¨startAdvancedStreamingAsync()",
                    "5. åˆ†å—è´¨é‡æ£€æŸ¥",
                    "6. åˆå¹¶ç»“æœ"
                };
                break;
                
            case OptimizationStrategy::RecommendedAccessMode::PARALLEL_BATCH_PROCESSING:
                sequence = {
                    "1. é…ç½®å¹¶è¡Œå¤„ç†",
                    "2. åˆ›å»ºæ‰¹é‡è¯·æ±‚",
                    "3. å¯ç”¨å¼‚æ­¥å¤„ç†",
                    "4. è°ƒç”¨processBatchRequestsAsync()",
                    "5. å¹¶è¡Œè´¨é‡æ£€æŸ¥",
                    "6. åˆå¹¶å’Œèåˆç»“æœ"
                };
                break;
                
            default:
                sequence = {"æ ‡å‡†å¤„ç†æµç¨‹"};
                break;
        }
        
        return sequence;
    }
};
```

#### 6.4.3 å…·ä½“çš„é«˜çº§åŠŸèƒ½è°ƒç”¨å®ç°

```cpp
/**
 * @brief é«˜æ•ˆæ•°æ®è¯»å–æ‰§è¡Œå™¨
 * 
 * å®ç°å„ç§é«˜çº§åŠŸèƒ½çš„æœ€ä¼˜è°ƒç”¨æ–¹å¼
 */
class HighPerformanceDataReader {
public:
    /**
     * @brief æ‰§è¡Œé«˜æ€§èƒ½æ•°æ®è¯»å–
     */
    boost::future<IntelligentDataReader::ReadingResult> executeHighPerformanceReading(
        const IntelligentReaderParameters& params) {
        
        return boost::async([this, params]() -> IntelligentDataReader::ReadingResult {
            
            // ğŸ¯ ç”Ÿæˆæœ€ä¼˜ç­–ç•¥
            auto strategy = optimizer_->generateOptimalStrategy(params);
            
            // ğŸ¯ æ ¹æ®ç­–ç•¥æ‰§è¡Œç›¸åº”çš„é«˜çº§åŠŸèƒ½è°ƒç”¨
            switch (strategy.recommendedMode) {
                case AdvancedFeatureOptimizer::OptimizationStrategy::RecommendedAccessMode::DIRECT_MEMORY_ACCESS:
                    return executeDirectMemoryAccess(params, strategy);
                    
                case AdvancedFeatureOptimizer::OptimizationStrategy::RecommendedAccessMode::STREAMING_PROCESSING:
                    return executeAdvancedStreaming(params, strategy);
                    
                case AdvancedFeatureOptimizer::OptimizationStrategy::RecommendedAccessMode::PARALLEL_BATCH_PROCESSING:
                    return executeParallelBatchProcessing(params, strategy);
                    
                case AdvancedFeatureOptimizer::OptimizationStrategy::RecommendedAccessMode::MEMORY_MAPPED_ACCESS:
                    return executeMemoryMappedAccess(params, strategy);
                    
                default:
                    return executeChunkedProcessing(params, strategy);
            }
        });
    }
    
private:
    /**
     * @brief æ‰§è¡Œé«˜çº§æµå¼å¤„ç† - æœ€é«˜æ•ˆçš„å¤§æ•°æ®å¤„ç†æ–¹å¼
     */
    IntelligentDataReader::ReadingResult executeAdvancedStreaming(
        const IntelligentReaderParameters& params,
        const AdvancedFeatureOptimizer::OptimizationStrategy& strategy) {
        
        IntelligentDataReader::ReadingResult result;
        
        // ğŸ¯ é…ç½®é«˜çº§æµå¼å¤„ç†
        oscean::core_services::data_access::LargeFileReadConfig streamConfig;
        streamConfig.chunkSizeBytes = strategy.optimizedParams.performanceOptimization.streamingChunkSizeMB * 1024 * 1024;
        streamConfig.maxMemoryUsageBytes = strategy.optimizedParams.performanceOptimization.maxMemoryUsageMB * 1024 * 1024;
        streamConfig.enableProgressCallback = true;
        streamConfig.enableMemoryOptimization = strategy.optimizedParams.performanceOptimization.enableMemoryOptimization;
        streamConfig.enableParallelReading = (strategy.optimizedParams.performanceOptimization.maxConcurrentOperations > 1);
        
        // ğŸ¯ åˆ›å»ºé«˜æ€§èƒ½æµå¼å¤„ç†å™¨
        class HighPerformanceStreamProcessor : public oscean::core_services::data_access::IStreamProcessor {
        private:
            std::vector<double> accumulatedData_;
            std::mutex dataMutex_;
            std::atomic<size_t> chunksProcessed_{0};
            std::atomic<size_t> totalBytesProcessed_{0};
            
            // SIMDä¼˜åŒ–çš„æ•°æ®å¤„ç†
            std::shared_ptr<oscean::common_utils::simd::UnifiedSIMDManager> simdManager_;
            
        public:
            HighPerformanceStreamProcessor(
                std::shared_ptr<oscean::common_utils::simd::UnifiedSIMDManager> simd)
                : simdManager_(simd) {}
            
            bool processChunk(const std::vector<double>& chunk, 
                            const std::map<std::string, std::any>& chunkInfo) override {
                
                // ğŸ¯ ä½¿ç”¨SIMDä¼˜åŒ–çš„æ•°æ®å¤„ç†
                std::vector<double> processedChunk = chunk;
                if (simdManager_ && chunk.size() >= 256) {
                    // åº”ç”¨SIMDä¼˜åŒ–çš„æ•°æ®å˜æ¢
                    simdManager_->processVectorizedOperation(
                        chunk.data(), processedChunk.data(), chunk.size(), "data_validation");
                }
                
                // ğŸ¯ çº¿ç¨‹å®‰å…¨çš„æ•°æ®ç´¯ç§¯
                {
                    std::lock_guard<std::mutex> lock(dataMutex_);
                    accumulatedData_.insert(accumulatedData_.end(), 
                                          processedChunk.begin(), processedChunk.end());
                }
                
                chunksProcessed_++;
                totalBytesProcessed_ += chunk.size() * sizeof(double);
                
                return true; // ç»§ç»­å¤„ç†
            }
            
            void onStreamComplete() override {
                // æµå¼å¤„ç†å®Œæˆï¼Œå¯ä»¥è¿›è¡Œæœ€ç»ˆçš„SIMDä¼˜åŒ–
                if (simdManager_ && accumulatedData_.size() >= 1024) {
                    // æœ€ç»ˆçš„æ•°æ®ä¼˜åŒ–å¤„ç†
                    simdManager_->processVectorizedOperation(
                        accumulatedData_.data(), accumulatedData_.data(), 
                        accumulatedData_.size(), "final_optimization");
                }
            }
            
            void onStreamError(const std::string& error) override {
                throw std::runtime_error("é«˜æ€§èƒ½æµå¼å¤„ç†é”™è¯¯: " + error);
            }
            
            const std::vector<double>& getAccumulatedData() const { return accumulatedData_; }
            size_t getChunksProcessed() const { return chunksProcessed_.load(); }
            size_t getTotalBytesProcessed() const { return totalBytesProcessed_.load(); }
        };
        
        // ğŸ¯ åˆ›å»ºSIMDç®¡ç†å™¨
        auto simdManager = commonServices_->createSIMDManager();
        if (strategy.optimizedParams.performanceOptimization.enableSIMD) {
            simdManager->initialize(strategy.optimizedParams.performanceOptimization.simdImplementation);
        }
        
        auto streamProcessor = std::make_shared<HighPerformanceStreamProcessor>(simdManager);
        
        // ğŸ¯ æ‰§è¡Œé«˜çº§æµå¼è¯»å–
        for (const auto& filePath : params.dataAccessConfig.filePaths) {
            for (const auto& variableName : params.dataAccessConfig.variableNames) {
                
                try {
                    // å¯åŠ¨é«˜çº§æµå¼å¤„ç†
                    dataAccessService_->startAdvancedStreamingAsync(
                        filePath, variableName, streamProcessor, streamConfig
                    ).get();
                    
                    // åˆ›å»ºä¼˜åŒ–çš„ç»“æœ
                    auto gridData = std::make_shared<oscean::core_services::GridData>();
                    gridData->values = streamProcessor->getAccumulatedData();
                    gridData->variableName = variableName;
                    
                    result.data = gridData;
                    result.processingStats.dataPointsProcessed = gridData->values.size();
                    result.processingStats.bytesRead = streamProcessor->getTotalBytesProcessed();
                    result.processingStats.optimizationsUsed.push_back("AdvancedStreaming");
                    result.processingStats.optimizationsUsed.push_back("SIMDProcessing");
                    
                    break; // æˆåŠŸå¤„ç†ç¬¬ä¸€ä¸ªå˜é‡
                    
                } catch (const std::exception& e) {
                    result.errorMessage = "æµå¼å¤„ç†å¤±è´¥: " + std::string(e.what());
                    continue; // å°è¯•ä¸‹ä¸€ä¸ªå˜é‡
                }
            }
        }
        
        return result;
    }
    
    /**
     * @brief æ‰§è¡Œå¹¶è¡Œæ‰¹å¤„ç† - å¤šæ–‡ä»¶é«˜æ•ˆå¤„ç†
     */
    IntelligentDataReader::ReadingResult executeParallelBatchProcessing(
        const IntelligentReaderParameters& params,
        const AdvancedFeatureOptimizer::OptimizationStrategy& strategy) {
        
        IntelligentDataReader::ReadingResult result;
        
        // ğŸ¯ åˆ›å»ºä¼˜åŒ–çš„æ‰¹é‡è¯·æ±‚
        std::vector<oscean::core_services::data_access::api::UnifiedDataRequest> batchRequests;
        
        for (const auto& filePath : params.dataAccessConfig.filePaths) {
            for (const auto& variableName : params.dataAccessConfig.variableNames) {
                
                oscean::core_services::data_access::api::UnifiedDataRequest request;
                request.requestType = oscean::core_services::data_access::api::UnifiedRequestType::GRID_DATA;
                request.filePath = filePath;
                request.variableName = variableName;
                
                // ğŸ¯ åº”ç”¨ç©ºé—´ä¼˜åŒ–
                request.spatialBounds = strategy.optimizedParams.spatialOptimization.optimizedBounds;
                request.timeRange = strategy.optimizedParams.temporalOptimization.timeRange;
                request.includeMetadata = params.dataAccessConfig.includeMetadata;
                
                // ğŸ¯ é…ç½®é‡é‡‡æ ·å‚æ•°
                if (strategy.optimizedParams.spatialOptimization.targetResolutionMeters.has_value()) {
                    request.targetResolution = {strategy.optimizedParams.spatialOptimization.targetResolutionMeters.value()};
                    request.resampleAlgorithm = params.dataAccessConfig.resampleAlgorithm;
                }
                
                batchRequests.push_back(request);
            }
        }
        
        // ğŸ¯ æ‰§è¡Œé«˜æ€§èƒ½æ‰¹é‡å¤„ç†
        try {
            auto batchResponses = dataAccessService_->processBatchRequestsAsync(batchRequests).get();
            
            // ğŸ¯ ä½¿ç”¨SIMDä¼˜åŒ–åˆå¹¶ç»“æœ
            std::vector<std::shared_ptr<oscean::core_services::GridData>> gridDataList;
            
            for (const auto& response : batchResponses) {
                if (response.status == oscean::core_services::data_access::api::UnifiedResponseStatus::SUCCESS) {
                    if (std::holds_alternative<std::shared_ptr<oscean::core_services::GridData>>(response.data)) {
                        gridDataList.push_back(
                            std::get<std::shared_ptr<oscean::core_services::GridData>>(response.data));
                    }
                }
            }
            
            // ğŸ¯ é«˜æ•ˆæ•°æ®èåˆï¼ˆå¦‚æœæœ‰å¤šä¸ªæ•°æ®æºï¼‰
            if (!gridDataList.empty()) {
                if (gridDataList.size() == 1) {
                    result.data = gridDataList[0];
                } else {
                    // ä½¿ç”¨SIMDä¼˜åŒ–çš„æ•°æ®èåˆ
                    result.data = performSIMDOptimizedDataFusion(gridDataList, strategy);
                }
                
                result.processingStats.optimizationsUsed.push_back("ParallelBatchProcessing");
                result.processingStats.optimizationsUsed.push_back("SIMDDataFusion");
            }
            
        } catch (const std::exception& e) {
            result.success = false;
            result.errorMessage = "å¹¶è¡Œæ‰¹å¤„ç†å¤±è´¥: " + std::string(e.what());
        }
        
        return result;
    }
    
private:
    std::shared_ptr<AdvancedFeatureOptimizer> optimizer_;
    std::shared_ptr<oscean::core_services::data_access::IUnifiedDataAccessService> dataAccessService_;
    std::shared_ptr<oscean::common_utils::infrastructure::CommonServicesFactory> commonServices_;
    
    /**
     * @brief SIMDä¼˜åŒ–çš„æ•°æ®èåˆ
     */
    std::shared_ptr<oscean::core_services::GridData> performSIMDOptimizedDataFusion(
        const std::vector<std::shared_ptr<oscean::core_services::GridData>>& gridDataList,
        const AdvancedFeatureOptimizer::OptimizationStrategy& strategy) {
        
        // å®ç°SIMDä¼˜åŒ–çš„æ•°æ®èåˆç®—æ³•
        // è¿™é‡Œå¯ä»¥è°ƒç”¨SpatialOpsServiceçš„mosaicåŠŸèƒ½
        auto fusedData = std::make_shared<oscean::core_services::GridData>();
        
        // ç®€åŒ–å®ç°ï¼šå–ç¬¬ä¸€ä¸ªæ•°æ®ä½œä¸ºåŸºç¡€
        if (!gridDataList.empty()) {
            *fusedData = *gridDataList[0];
            fusedData->variableName = "fused_" + fusedData->variableName;
        }
        
        return fusedData;
    }
};
```

### 6.5 æ•°æ®ç½‘æ ¼å»ºç«‹ä¸å¡«å……çš„æ ¸å¿ƒæœºåˆ¶

ç¬¬ä¸‰æ­¥çš„æ ¸å¿ƒèŒè´£æ˜¯**æ•°æ®è¯»å–å’Œç½‘æ ¼å¡«å……**ï¼Œæœ€ç»ˆè¾“å‡ºæ ‡å‡†åŒ–çš„æ•°æ®ç½‘æ ¼ã€‚

#### 6.5.1 æ•°æ®ç½‘æ ¼å»ºç«‹æµç¨‹

```cpp
/**
 * @brief æ•°æ®ç½‘æ ¼å»ºç«‹å™¨ - ç¬¬ä¸‰æ­¥çš„æ ¸å¿ƒåŠŸèƒ½æ¨¡å—
 */
class DataGridBuilder {
public:
    /**
     * @brief ç½‘æ ¼å»ºç«‹ç»“æœ
     */
    struct GridBuildResult {
        // å»ºç«‹çš„ç½‘æ ¼ç»“æ„
        std::shared_ptr<oscean::core_services::GridData> gridData;
        
        // ç½‘æ ¼å…ƒä¿¡æ¯
        struct GridMetadata {
            double actualHorizontalResolution;          // å®é™…æ°´å¹³åˆ†è¾¨ç‡ï¼ˆç±³ï¼‰
            double actualVerticalResolution;            // å®é™…å‚ç›´åˆ†è¾¨ç‡ï¼ˆç±³ï¼‰
            std::string coordinateSystem;               // åæ ‡ç³»ç»Ÿ
            oscean::core_services::BoundingBox actualBounds; // å®é™…è¾¹ç•Œ
            
            // ç½‘æ ¼ç»´åº¦ä¿¡æ¯
            size_t gridWidth;                           // ç½‘æ ¼å®½åº¦ï¼ˆåˆ—æ•°ï¼‰
            size_t gridHeight;                          // ç½‘æ ¼é«˜åº¦ï¼ˆè¡Œæ•°ï¼‰
            size_t gridDepth;                           // ç½‘æ ¼æ·±åº¦ï¼ˆå±‚æ•°ï¼Œå¯é€‰ï¼‰
            size_t totalGridPoints;                     // æ€»ç½‘æ ¼ç‚¹æ•°
            
            // æ•°æ®å¡«å……ç»Ÿè®¡
            size_t filledPoints;                        // å·²å¡«å……ç‚¹æ•°
            size_t interpolatedPoints;                  // æ’å€¼ç‚¹æ•°
            size_t originalDataPoints;                  // åŸå§‹æ•°æ®ç‚¹æ•°
            double fillRatio;                           // å¡«å……æ¯”ä¾‹
            
        } gridMetadata;
        
        // æ•°æ®è´¨é‡ä¿¡æ¯
        struct DataQuality {
            double overallQuality;                      // æ•´ä½“è´¨é‡è¯„åˆ†
            std::vector<double> pointQualityScores;     // æ¯ä¸ªç½‘æ ¼ç‚¹çš„è´¨é‡è¯„åˆ†
            std::vector<bool> isInterpolated;           // æ ‡è®°å“ªäº›ç‚¹æ˜¯æ’å€¼çš„
            std::vector<bool> isOriginalData;           // æ ‡è®°å“ªäº›ç‚¹æ˜¯åŸå§‹æ•°æ®
            std::map<std::string, double> variableQuality; // å„å˜é‡è´¨é‡è¯„åˆ†
        } dataQuality;
        
        bool success = false;
        std::string errorMessage;
    };
    
    /**
     * @brief å»ºç«‹å¹¶å¡«å……æ•°æ®ç½‘æ ¼ - ç¬¬ä¸‰æ­¥ä¸»è¦åŠŸèƒ½
     */
    boost::future<GridBuildResult> buildAndFillDataGrid(
        const IntelligentReaderParameters& params) {
        
        return boost::async([this, params]() -> GridBuildResult {
            GridBuildResult result;
            
            try {
                // ğŸ¯ æ­¥éª¤1ï¼šå»ºç«‹ç›®æ ‡ç½‘æ ¼ç»“æ„
                result.gridData = createTargetGridStructure(params);
                
                // ğŸ¯ æ­¥éª¤2ï¼šè¯»å–åŸå§‹æ•°æ®
                auto rawDataCollection = readRawDataFromSources(params);
                
                // ğŸ¯ æ­¥éª¤3ï¼šæ•°æ®ç½‘æ ¼æ˜ å°„å’Œå¡«å……
                fillGridWithRawData(result.gridData, rawDataCollection, params);
                
                // ğŸ¯ æ­¥éª¤4ï¼šæ’å€¼å¡«å……ç©ºç™½ç½‘æ ¼ç‚¹ï¼ˆå¦‚æœéœ€è¦ï¼‰
                if (needsInterpolation(params)) {
                    performGridInterpolation(result.gridData, params);
                }
                
                // ğŸ¯ æ­¥éª¤5ï¼šç”Ÿæˆç½‘æ ¼å…ƒä¿¡æ¯å’Œè´¨é‡è¯„ä¼°
                generateGridMetadata(result, params);
                evaluateGridDataQuality(result, params);
                
                result.success = true;
                
            } catch (const std::exception& e) {
                result.success = false;
                result.errorMessage = e.what();
            }
            
            return result;
        });
    }
    
private:
    /**
     * @brief æ­¥éª¤1ï¼šåˆ›å»ºç›®æ ‡ç½‘æ ¼ç»“æ„
     */
    std::shared_ptr<oscean::core_services::GridData> createTargetGridStructure(
        const IntelligentReaderParameters& params) {
        
        auto gridData = std::make_shared<oscean::core_services::GridData>();
        
        // ğŸ¯ ä»ç¬¬äºŒæ­¥è·å–çš„ç½‘æ ¼é…ç½®
        const auto& gridConfig = params.gridConfig;
        const auto& spatialBounds = params.spatialMetadata.processedSpatial.queryBounds;
        
        // ğŸ¯ è®¡ç®—ç½‘æ ¼ç»´åº¦
        double targetResolution = gridConfig.targetHorizontalResolution.value_or(1000.0); // é»˜è®¤1km
        
        // è®¡ç®—ç½‘æ ¼å¤§å°
        double boundsWidth = spatialBounds.maxLongitude - spatialBounds.minLongitude;
        double boundsHeight = spatialBounds.maxLatitude - spatialBounds.minLatitude;
        
        // è½¬æ¢ä¸ºç±³ï¼ˆç²—ç•¥è®¡ç®—ï¼Œå®é™…åº”è€ƒè™‘æŠ•å½±ï¼‰
        double widthMeters = boundsWidth * 111320.0; // 1åº¦çº¦111.32km
        double heightMeters = boundsHeight * 110540.0; // çº¬åº¦1åº¦çº¦110.54km
        
        gridData->width = static_cast<size_t>(std::ceil(widthMeters / targetResolution));
        gridData->height = static_cast<size_t>(std::ceil(heightMeters / targetResolution));
        
        // ğŸ¯ åˆå§‹åŒ–ç½‘æ ¼æ•°æ®æ•°ç»„
        size_t totalPoints = gridData->width * gridData->height;
        gridData->values.resize(totalPoints, std::numeric_limits<double>::quiet_NaN());
        
        // ğŸ¯ è®¾ç½®ç½‘æ ¼åœ°ç†å‚è€ƒä¿¡æ¯
        gridData->bounds = spatialBounds;
        gridData->coordinateSystem = params.spatialMetadata.processedSpatial.targetCRS;
        
        // ğŸ¯ è®¡ç®—ç½‘æ ¼çš„åœ°ç†å˜æ¢å‚æ•°
        gridData->geoTransform = {
            spatialBounds.minLongitude,                    // å·¦ä¸Šè§’Xåæ ‡
            boundsWidth / gridData->width,                 // Xæ–¹å‘åƒç´ å¤§å°
            0.0,                                          // Xæ–¹å‘æ—‹è½¬
            spatialBounds.maxLatitude,                    // å·¦ä¸Šè§’Yåæ ‡
            0.0,                                          // Yæ–¹å‘æ—‹è½¬
            -boundsHeight / gridData->height              // Yæ–¹å‘åƒç´ å¤§å°ï¼ˆè´Ÿå€¼ï¼Œå› ä¸ºYè½´å‘ä¸‹ï¼‰
        };
        
        return gridData;
    }
    
    /**
     * @brief æ­¥éª¤2ï¼šä»æ•°æ®æºè¯»å–åŸå§‹æ•°æ®
     */
    struct RawDataCollection {
        struct DataPoint {
            double longitude, latitude;                   // åœ°ç†åæ ‡
            std::optional<double> depth;                  // æ·±åº¦ï¼ˆå¯é€‰ï¼‰
            std::optional<std::chrono::system_clock::time_point> timestamp; // æ—¶é—´æˆ³ï¼ˆå¯é€‰ï¼‰
            std::map<std::string, double> variableValues; // å˜é‡å€¼
            double dataQuality = 1.0;                    // æ•°æ®è´¨é‡è¯„åˆ†
            std::string sourceFile;                      // æ¥æºæ–‡ä»¶
        };
        
        std::vector<DataPoint> dataPoints;               // æ‰€æœ‰æ•°æ®ç‚¹
        std::map<std::string, std::vector<size_t>> variableIndices; // å˜é‡ç´¢å¼•
        oscean::core_services::BoundingBox dataBounds;   // æ•°æ®å®é™…è¾¹ç•Œ
        size_t totalPointsRead = 0;                     // è¯»å–çš„æ€»ç‚¹æ•°
    };
    
    RawDataCollection readRawDataFromSources(const IntelligentReaderParameters& params) {
        RawDataCollection collection;
        
        // ğŸ¯ æ ¹æ®æ•°æ®æºæ¨¡å¼è¯»å–æ•°æ®
        for (const auto& filePath : params.dataAccessConfig.filePaths) {
            for (const auto& variableName : params.dataAccessConfig.variableNames) {
                
                // åˆ›å»ºæ•°æ®è¯»å–è¯·æ±‚
                oscean::core_services::data_access::api::UnifiedDataRequest request;
                request.requestType = oscean::core_services::data_access::api::UnifiedRequestType::GRID_DATA;
                request.filePath = filePath;
                request.variableName = variableName;
                request.spatialBounds = params.dataAccessConfig.spatialBounds;
                request.timeRange = params.dataAccessConfig.timeRange;
                request.includeMetadata = true;
                
                // ğŸ¯ æ‰§è¡Œæ•°æ®è¯»å–
                auto response = dataAccessService_->processDataRequestAsync(request).get();
                
                if (response.status == oscean::core_services::data_access::api::UnifiedResponseStatus::SUCCESS) {
                    // ğŸ¯ æå–ç½‘æ ¼æ•°æ®å¹¶è½¬æ¢ä¸ºç‚¹æ•°æ®
                    if (std::holds_alternative<std::shared_ptr<oscean::core_services::GridData>>(response.data)) {
                        auto sourceGrid = std::get<std::shared_ptr<oscean::core_services::GridData>>(response.data);
                        convertGridToDataPoints(sourceGrid, collection, variableName, filePath);
                    }
                }
            }
        }
        
        // ğŸ¯ è®¡ç®—æ•°æ®è¾¹ç•Œ
        calculateDataBounds(collection);
        
        return collection;
    }
    
    /**
     * @brief å°†æºç½‘æ ¼æ•°æ®è½¬æ¢ä¸ºæ•°æ®ç‚¹é›†åˆ
     */
    void convertGridToDataPoints(
        std::shared_ptr<oscean::core_services::GridData> sourceGrid,
        RawDataCollection& collection,
        const std::string& variableName,
        const std::string& sourceFile) {
        
        // ğŸ¯ éå†æºç½‘æ ¼çš„æ¯ä¸ªæœ‰æ•ˆæ•°æ®ç‚¹
        for (size_t row = 0; row < sourceGrid->height; ++row) {
            for (size_t col = 0; col < sourceGrid->width; ++col) {
                size_t index = row * sourceGrid->width + col;
                
                if (index < sourceGrid->values.size() && 
                    !std::isnan(sourceGrid->values[index])) {
                    
                    // ğŸ¯ è®¡ç®—è¯¥ç½‘æ ¼ç‚¹çš„åœ°ç†åæ ‡
                    double longitude = sourceGrid->geoTransform[0] + 
                                     col * sourceGrid->geoTransform[1];
                    double latitude = sourceGrid->geoTransform[3] + 
                                    row * sourceGrid->geoTransform[5];
                    
                    // ğŸ¯ åˆ›å»ºæ•°æ®ç‚¹
                    RawDataCollection::DataPoint dataPoint;
                    dataPoint.longitude = longitude;
                    dataPoint.latitude = latitude;
                    dataPoint.variableValues[variableName] = sourceGrid->values[index];
                    dataPoint.sourceFile = sourceFile;
                    dataPoint.dataQuality = 1.0; // åŸå§‹æ•°æ®è´¨é‡ä¸º1.0
                    
                    collection.dataPoints.push_back(dataPoint);
                    
                    // ğŸ¯ æ›´æ–°å˜é‡ç´¢å¼•
                    collection.variableIndices[variableName].push_back(collection.dataPoints.size() - 1);
                }
            }
        }
        
        collection.totalPointsRead = collection.dataPoints.size();
    }
    
    /**
     * @brief æ­¥éª¤3ï¼šå°†åŸå§‹æ•°æ®å¡«å……åˆ°ç›®æ ‡ç½‘æ ¼
     */
    void fillGridWithRawData(
        std::shared_ptr<oscean::core_services::GridData> targetGrid,
        const RawDataCollection& rawData,
        const IntelligentReaderParameters& params) {
        
        // ğŸ¯ ä¸ºæ¯ä¸ªåŸå§‹æ•°æ®ç‚¹æ‰¾åˆ°å¯¹åº”çš„ç›®æ ‡ç½‘æ ¼ä½ç½®
        for (const auto& dataPoint : rawData.dataPoints) {
            
            // ğŸ¯ è®¡ç®—æ•°æ®ç‚¹åœ¨ç›®æ ‡ç½‘æ ¼ä¸­çš„ä½ç½®
            auto gridPosition = calculateGridPosition(dataPoint, targetGrid);
            
            if (gridPosition.isValid) {
                size_t gridIndex = gridPosition.row * targetGrid->width + gridPosition.col;
                
                if (gridIndex < targetGrid->values.size()) {
                    
                    // ğŸ¯ å¤„ç†å¤šä¸ªå˜é‡çš„æƒ…å†µ
                    for (const auto& [variableName, value] : dataPoint.variableValues) {
                        
                        if (params.dataAccessConfig.variableNames.empty() || 
                            std::find(params.dataAccessConfig.variableNames.begin(),
                                    params.dataAccessConfig.variableNames.end(),
                                    variableName) != params.dataAccessConfig.variableNames.end()) {
                            
                            // ğŸ¯ å¦‚æœç½‘æ ¼ç‚¹è¿˜æ²¡æœ‰æ•°æ®ï¼Œç›´æ¥å¡«å……
                            if (std::isnan(targetGrid->values[gridIndex])) {
                                targetGrid->values[gridIndex] = value;
                                targetGrid->variableName = variableName; // è®¾ç½®ä¸»è¦å˜é‡å
                            } else {
                                // ğŸ¯ å¦‚æœå·²æœ‰æ•°æ®ï¼Œè¿›è¡Œæ•°æ®èåˆï¼ˆç®€å•å¹³å‡ï¼‰
                                targetGrid->values[gridIndex] = 
                                    (targetGrid->values[gridIndex] + value) / 2.0;
                            }
                        }
                    }
                }
            }
        }
    }
    
    /**
     * @brief ç½‘æ ¼ä½ç½®è®¡ç®—ç»“æœ
     */
    struct GridPosition {
        size_t row, col;
        bool isValid = false;
        double distanceToCenter = 0.0; // åˆ°ç½‘æ ¼ä¸­å¿ƒçš„è·ç¦»
    };
    
    /**
     * @brief è®¡ç®—æ•°æ®ç‚¹åœ¨ç›®æ ‡ç½‘æ ¼ä¸­çš„ä½ç½®
     */
    GridPosition calculateGridPosition(
        const RawDataCollection::DataPoint& dataPoint,
        std::shared_ptr<oscean::core_services::GridData> targetGrid) {
        
        GridPosition position;
        
        // ğŸ¯ æ£€æŸ¥æ•°æ®ç‚¹æ˜¯å¦åœ¨ç›®æ ‡ç½‘æ ¼èŒƒå›´å†…
        if (dataPoint.longitude < targetGrid->bounds.minLongitude ||
            dataPoint.longitude > targetGrid->bounds.maxLongitude ||
            dataPoint.latitude < targetGrid->bounds.minLatitude ||
            dataPoint.latitude > targetGrid->bounds.maxLatitude) {
            return position; // isValid = false
        }
        
        // ğŸ¯ è®¡ç®—ç½‘æ ¼è¡Œåˆ—ç´¢å¼•
        double relativeX = dataPoint.longitude - targetGrid->geoTransform[0];
        double relativeY = dataPoint.latitude - targetGrid->geoTransform[3];
        
        int col = static_cast<int>(relativeX / targetGrid->geoTransform[1]);
        int row = static_cast<int>(relativeY / targetGrid->geoTransform[5]);
        
        // ğŸ¯ è¾¹ç•Œæ£€æŸ¥
        if (col >= 0 && col < static_cast<int>(targetGrid->width) &&
            row >= 0 && row < static_cast<int>(targetGrid->height)) {
            
            position.col = static_cast<size_t>(col);
            position.row = static_cast<size_t>(row);
            position.isValid = true;
            
            // ğŸ¯ è®¡ç®—åˆ°ç½‘æ ¼ä¸­å¿ƒçš„è·ç¦»
            double gridCenterX = targetGrid->geoTransform[0] + (col + 0.5) * targetGrid->geoTransform[1];
            double gridCenterY = targetGrid->geoTransform[3] + (row + 0.5) * targetGrid->geoTransform[5];
            
            double dx = dataPoint.longitude - gridCenterX;
            double dy = dataPoint.latitude - gridCenterY;
            position.distanceToCenter = std::sqrt(dx * dx + dy * dy);
        }
        
        return position;
    }
    
    /**
     * @brief æ­¥éª¤4ï¼šæ’å€¼å¡«å……ç©ºç™½ç½‘æ ¼ç‚¹
     */
    void performGridInterpolation(
        std::shared_ptr<oscean::core_services::GridData> targetGrid,
        const IntelligentReaderParameters& params) {
        
        if (!params.interpolationConfig.has_value()) {
            return; // ä¸éœ€è¦æ’å€¼
        }
        
        const auto& interpConfig = params.interpolationConfig.value();
        
        // ğŸ¯ æ‰¾å‡ºæ‰€æœ‰éœ€è¦æ’å€¼çš„ç½‘æ ¼ç‚¹
        std::vector<size_t> emptyGridIndices;
        std::vector<size_t> filledGridIndices;
        
        for (size_t i = 0; i < targetGrid->values.size(); ++i) {
            if (std::isnan(targetGrid->values[i])) {
                emptyGridIndices.push_back(i);
            } else {
                filledGridIndices.push_back(i);
            }
        }
        
        // ğŸ¯ å¯¹æ¯ä¸ªç©ºç™½ç½‘æ ¼ç‚¹è¿›è¡Œæ’å€¼
        for (size_t emptyIndex : emptyGridIndices) {
            
            // è®¡ç®—ç©ºç™½ç‚¹çš„åœ°ç†åæ ‡
            size_t row = emptyIndex / targetGrid->width;
            size_t col = emptyIndex % targetGrid->width;
            
            double longitude = targetGrid->geoTransform[0] + (col + 0.5) * targetGrid->geoTransform[1];
            double latitude = targetGrid->geoTransform[3] + (row + 0.5) * targetGrid->geoTransform[5];
            
            // ğŸ¯ æ‰§è¡Œæ’å€¼è®¡ç®—
            double interpolatedValue = performSinglePointInterpolation(
                longitude, latitude, targetGrid, filledGridIndices, interpConfig);
            
            if (!std::isnan(interpolatedValue)) {
                targetGrid->values[emptyIndex] = interpolatedValue;
            }
        }
    }
    
    /**
     * @brief å•ç‚¹æ’å€¼è®¡ç®—
     */
    double performSinglePointInterpolation(
        double targetLon, double targetLat,
        std::shared_ptr<oscean::core_services::GridData> targetGrid,
        const std::vector<size_t>& filledGridIndices,
        const PointInterpolationConfig& interpConfig) {
        
        // ğŸ¯ æ”¶é›†æ’å€¼æ‰€éœ€çš„é‚»è¿‘ç‚¹
        struct NeighborPoint {
            double longitude, latitude;
            double value;
            double distance;
            double weight;
        };
        
        std::vector<NeighborPoint> neighbors;
        
        // ğŸ¯ åœ¨æŒ‡å®šæœç´¢åŠå¾„å†…æŸ¥æ‰¾é‚»è¿‘ç‚¹
        for (size_t filledIndex : filledGridIndices) {
            size_t row = filledIndex / targetGrid->width;
            size_t col = filledIndex % targetGrid->width;
            
            double longitude = targetGrid->geoTransform[0] + (col + 0.5) * targetGrid->geoTransform[1];
            double latitude = targetGrid->geoTransform[3] + (row + 0.5) * targetGrid->geoTransform[5];
            
            // è®¡ç®—è·ç¦»
            double dx = targetLon - longitude;
            double dy = targetLat - latitude;
            double distance = std::sqrt(dx * dx + dy * dy);
            
            // ğŸ¯ åœ¨æœç´¢åŠå¾„å†…ä¸”ä¸è¶…è¿‡æœ€å¤§æœç´¢ç‚¹æ•°
            if (distance <= interpConfig.searchRadiusMeters && 
                neighbors.size() < interpConfig.maxSearchPoints) {
                
                NeighborPoint neighbor;
                neighbor.longitude = longitude;
                neighbor.latitude = latitude;
                neighbor.value = targetGrid->values[filledIndex];
                neighbor.distance = distance;
                
                // ğŸ¯ è®¡ç®—æƒé‡ï¼ˆåè·ç¦»æƒé‡ï¼‰
                if (distance > 0) {
                    neighbor.weight = 1.0 / std::pow(distance, interpConfig.distanceWeightPower);
                } else {
                    neighbor.weight = 1.0; // å®Œå…¨é‡åˆçš„ç‚¹
                }
                
                neighbors.push_back(neighbor);
            }
        }
        
        // ğŸ¯ æ‰§è¡Œæ’å€¼è®¡ç®—
        if (neighbors.empty()) {
            return std::numeric_limits<double>::quiet_NaN();
        }
        
        // ğŸ¯ æ ¹æ®æ’å€¼æ–¹æ³•è®¡ç®—ç»“æœ
        switch (interpConfig.method) {
            case PointInterpolationConfig::InterpolationMethod::NEAREST_NEIGHBOR:
                return performNearestNeighborInterpolation(neighbors);
                
            case PointInterpolationConfig::InterpolationMethod::INVERSE_DISTANCE:
                return performInverseDistanceInterpolation(neighbors);
                
            case PointInterpolationConfig::InterpolationMethod::BILINEAR:
                return performBilinearInterpolation(neighbors, targetLon, targetLat);
                
            default:
                return performInverseDistanceInterpolation(neighbors); // é»˜è®¤æ–¹æ³•
        }
    }
    
    /**
     * @brief åè·ç¦»æƒé‡æ’å€¼
     */
    double performInverseDistanceInterpolation(const std::vector<NeighborPoint>& neighbors) {
        double weightedSum = 0.0;
        double totalWeight = 0.0;
        
        for (const auto& neighbor : neighbors) {
            weightedSum += neighbor.value * neighbor.weight;
            totalWeight += neighbor.weight;
        }
        
        return totalWeight > 0 ? weightedSum / totalWeight : std::numeric_limits<double>::quiet_NaN();
    }
    
    /**
     * @brief æœ€è¿‘é‚»æ’å€¼
     */
    double performNearestNeighborInterpolation(const std::vector<NeighborPoint>& neighbors) {
        if (neighbors.empty()) {
            return std::numeric_limits<double>::quiet_NaN();
        }
        
        // æ‰¾åˆ°è·ç¦»æœ€è¿‘çš„ç‚¹
        auto nearest = std::min_element(neighbors.begin(), neighbors.end(),
            [](const NeighborPoint& a, const NeighborPoint& b) {
                return a.distance < b.distance;
            });
        
        return nearest->value;
    }
    
    /**
     * @brief åŒçº¿æ€§æ’å€¼ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰
     */
    double performBilinearInterpolation(
        const std::vector<NeighborPoint>& neighbors,
        double targetLon, double targetLat) {
        
        // ç®€åŒ–å®ç°ï¼šå¦‚æœé‚»è¿‘ç‚¹å°‘äº4ä¸ªï¼Œå›é€€åˆ°åè·ç¦»æƒé‡æ’å€¼
        if (neighbors.size() < 4) {
            return performInverseDistanceInterpolation(neighbors);
        }
        
        // è¿™é‡Œåº”è¯¥å®ç°çœŸæ­£çš„åŒçº¿æ€§æ’å€¼ç®—æ³•
        // ä¸ºç®€åŒ–ï¼Œæš‚æ—¶ä½¿ç”¨åè·ç¦»æƒé‡æ’å€¼
        return performInverseDistanceInterpolation(neighbors);
    }
    
private:
    std::shared_ptr<oscean::core_services::data_access::IUnifiedDataAccessService> dataAccessService_;
    std::shared_ptr<oscean::common_utils::infrastructure::CommonServicesFactory> commonServices_;
};
```

#### 6.5.2 æ•°æ®ç½‘æ ¼å¡«å……çš„å…³é”®æ­¥éª¤

**ğŸ—ï¸ æ­¥éª¤1ï¼šå»ºç«‹ç›®æ ‡ç½‘æ ¼ç»“æ„**
- æ ¹æ®ç¬¬äºŒæ­¥çš„ç½‘æ ¼é…ç½®åˆ›å»ºç›®æ ‡ç½‘æ ¼
- è®¡ç®—ç½‘æ ¼ç»´åº¦ï¼ˆå®½åº¦ã€é«˜åº¦ã€æ·±åº¦ï¼‰
- è®¾ç½®åœ°ç†å˜æ¢å‚æ•°å’Œåæ ‡ç³»ç»Ÿ
- åˆå§‹åŒ–ç½‘æ ¼æ•°æ®æ•°ç»„ï¼ˆå¡«å……NaNå€¼ï¼‰

**ğŸ“– æ­¥éª¤2ï¼šè¯»å–åŸå§‹æ•°æ®**
- ä»æŒ‡å®šæ•°æ®æºè¯»å–åŸå§‹æ•°æ®
- å°†ç½‘æ ¼æ•°æ®è½¬æ¢ä¸ºæ•°æ®ç‚¹é›†åˆ
- ä¿ç•™æ•°æ®çš„åœ°ç†åæ ‡å’Œå˜é‡å€¼
- è®°å½•æ•°æ®è´¨é‡å’Œæ¥æºä¿¡æ¯

**ğŸ¯ æ­¥éª¤3ï¼šæ•°æ®ç½‘æ ¼æ˜ å°„å’Œå¡«å……**
- ä¸ºæ¯ä¸ªåŸå§‹æ•°æ®ç‚¹è®¡ç®—ç›®æ ‡ç½‘æ ¼ä½ç½®
- å°†æ•°æ®ç‚¹å€¼å¡«å……åˆ°å¯¹åº”çš„ç½‘æ ¼å•å…ƒ
- å¤„ç†å¤šä¸ªæ•°æ®ç‚¹æ˜ å°„åˆ°åŒä¸€ç½‘æ ¼å•å…ƒçš„æƒ…å†µ
- è®°å½•å¡«å……ç»Ÿè®¡ä¿¡æ¯

**ğŸ”„ æ­¥éª¤4ï¼šæ’å€¼å¡«å……ç©ºç™½ç½‘æ ¼ç‚¹**
- è¯†åˆ«éœ€è¦æ’å€¼çš„ç©ºç™½ç½‘æ ¼ç‚¹
- ä¸ºæ¯ä¸ªç©ºç™½ç‚¹æŸ¥æ‰¾é‚»è¿‘çš„æœ‰æ•ˆæ•°æ®ç‚¹
- æ ¹æ®é…ç½®çš„æ’å€¼æ–¹æ³•è®¡ç®—æ’å€¼ç»“æœ
- åº”ç”¨è´¨é‡æ§åˆ¶å’Œè·ç¦»é™åˆ¶

**ğŸ“Š æ­¥éª¤5ï¼šç”Ÿæˆç½‘æ ¼å…ƒä¿¡æ¯**
- è®¡ç®—å®é™…åˆ†è¾¨ç‡å’Œè¾¹ç•Œ
- ç»Ÿè®¡å¡«å……æ¯”ä¾‹å’Œæ’å€¼æ¯”ä¾‹
- è¯„ä¼°æ•´ä½“æ•°æ®è´¨é‡
- ç”Ÿæˆå¤„ç†å†å²è®°å½•

### 6.6 ç¬¬ä¸‰æ­¥æ€»ç»“

ç¬¬ä¸‰æ­¥çš„æ ¸å¿ƒèŒè´£æ˜¯**æ•°æ®è¯»å–å’Œç½‘æ ¼å¡«å……**ï¼Œæœ€ç»ˆè¾“å‡ºï¼š

#### ğŸ¯ **ä¸»è¦è¾“å‡º**
1. **æ ‡å‡†åŒ–æ•°æ®ç½‘æ ¼**ï¼šåŒ…å«åœ°ç†å‚è€ƒä¿¡æ¯çš„è§„åˆ™ç½‘æ ¼
2. **ç½‘æ ¼å…ƒæ•°æ®**ï¼šåˆ†è¾¨ç‡ã€è¾¹ç•Œã€åæ ‡ç³»ç»Ÿã€å¡«å……ç»Ÿè®¡
3. **æ•°æ®è´¨é‡ä¿¡æ¯**ï¼šè´¨é‡è¯„åˆ†ã€æ’å€¼æ ‡è®°ã€å¤„ç†å†å²

#### ğŸ”§ **æ ¸å¿ƒåŠŸèƒ½æ¨¡å—**
1. **ç½‘æ ¼ç»“æ„å»ºç«‹å™¨**ï¼šåˆ›å»ºç›®æ ‡ç½‘æ ¼æ¡†æ¶
2. **æ•°æ®è¯»å–å™¨**ï¼šä»å¤šç§æ•°æ®æºè¯»å–åŸå§‹æ•°æ®
3. **ç½‘æ ¼å¡«å……å™¨**ï¼šå°†æ•°æ®ç‚¹æ˜ å°„åˆ°ç½‘æ ¼å•å…ƒ
4. **æ’å€¼å¤„ç†å™¨**ï¼šå¡«å……ç©ºç™½ç½‘æ ¼ç‚¹
5. **è´¨é‡è¯„ä¼°å™¨**ï¼šè¯„ä¼°ç½‘æ ¼æ•°æ®è´¨é‡

#### âš¡ **æ€§èƒ½ä¼˜åŒ–é‡ç‚¹**
1. **SIMDå‘é‡åŒ–**ï¼šæ’å€¼è®¡ç®—ã€æ•°æ®å˜æ¢çš„å‘é‡åŒ–å¤„ç†
2. **æ™ºèƒ½ç¼“å­˜**ï¼šç½‘æ ¼æ•°æ®å’Œæ’å€¼ç»“æœçš„ç¼“å­˜
3. **å¹¶è¡Œå¤„ç†**ï¼šå¤šæ–‡ä»¶å¹¶è¡Œè¯»å–ã€å¹¶è¡Œæ’å€¼è®¡ç®—
4. **å†…å­˜ä¼˜åŒ–**ï¼šæµå¼å¤„ç†å¤§ç½‘æ ¼ã€é›¶æ‹·è´æ•°æ®ä¼ è¾“

## 7. å®æ–½è®¡åˆ’

### 7.1 ç¬¬ä¸€é˜¶æ®µï¼šæ ¸å¿ƒæ¡†æ¶å®ç°ï¼ˆ2å‘¨ï¼‰
- [ ] å®Œå–„å·¥ä½œæµå¼•æ“é›†æˆ
- [ ] å®ç°å¢å¼ºçš„å‚æ•°ç»“æ„
- [ ] å»ºç«‹æ™ºèƒ½æ’å€¼å†³ç­–é€»è¾‘

### 7.2 ç¬¬äºŒé˜¶æ®µï¼šæ™ºèƒ½è¯»å–ç­–ç•¥ï¼ˆ2å‘¨ï¼‰  
- [ ] å®ç°æ•°æ®åº“å…ƒæ•°æ®æå–
- [ ] å®Œå–„CRSå¤„ç†é€»è¾‘
- [ ] ä¼˜åŒ–ç©ºé—´ç²¾åº¦æ§åˆ¶

### 7.3 ç¬¬ä¸‰é˜¶æ®µï¼šæ€§èƒ½ä¼˜åŒ–ï¼ˆ1å‘¨ï¼‰
- [ ] å¹¶è¡Œå¤„ç†ä¼˜åŒ–
- [ ] å†…å­˜ç®¡ç†ä¼˜åŒ–
- [ ] é”™è¯¯å¤„ç†å’Œæ¢å¤æœºåˆ¶

### 7.4 ç¬¬å››é˜¶æ®µï¼šæµ‹è¯•å’Œæ–‡æ¡£ï¼ˆ1å‘¨ï¼‰
- [ ] å®Œæ•´çš„å•å…ƒæµ‹è¯•
- [ ] é›†æˆæµ‹è¯•
- [ ] APIæ–‡æ¡£å’Œç”¨æˆ·æŒ‡å—

## 8. æ€»ç»“

æœ¬æ–¹æ¡ˆé€šè¿‡ç»Ÿä¸€çš„å·¥ä½œæµå¼•æ“ã€æ™ºèƒ½æ’å€¼å†³ç­–ã€ç²¾ç¡®çš„ç©ºé—´ç²¾åº¦æ§åˆ¶å’Œçµæ´»çš„å‚æ•°é…ç½®ï¼Œå®ç°äº†ä¸€ä¸ªé«˜åº¦è‡ªåŠ¨åŒ–å’Œæ™ºèƒ½åŒ–çš„æ•°æ®å¤„ç†å·¥ä½œæµç³»ç»Ÿã€‚ç³»ç»Ÿèƒ½å¤Ÿï¼š

1. **æ™ºèƒ½å†³ç­–**ï¼šè‡ªåŠ¨åˆ†æç”¨æˆ·éœ€æ±‚å’Œæ•°æ®ç‰¹å¾ï¼Œåšå‡ºæœ€ä¼˜çš„å¤„ç†å†³ç­–
2. **ç²¾åº¦æ§åˆ¶**ï¼šç‹¬ç«‹æ§åˆ¶æ°´å¹³å’Œå‚ç›´ç²¾åº¦ï¼Œæ”¯æŒåŸå§‹å’ŒæŒ‡å®šç²¾åº¦æ¨¡å¼
3. **é«˜æ•ˆå¤„ç†**ï¼šåŸºäºæ•°æ®ç‰¹å¾é€‰æ‹©æœ€ä¼˜çš„è¯»å–å’Œå¤„ç†ç­–ç•¥
4. **ç»Ÿä¸€ç®¡ç†**ï¼šé€šè¿‡å·¥ä½œæµå¼•æ“æä¾›ç»Ÿä¸€çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†
5. **çµæ´»é…ç½®**ï¼šä¸°å¯Œçš„å‚æ•°é…ç½®æ”¯æŒå„ç§å¤æ‚çš„æ•°æ®å¤„ç†éœ€æ±‚

è¯¥æ–¹æ¡ˆä¸ºæµ·æ´‹ç¯å¢ƒæ•°æ®å¤„ç†æä¾›äº†å¼ºå¤§è€Œçµæ´»çš„æŠ€æœ¯åŸºç¡€ã€‚ 