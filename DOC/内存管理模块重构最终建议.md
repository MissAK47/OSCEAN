# å†…å­˜ç®¡ç†æ¨¡å—é‡æ„æœ€ç»ˆå»ºè®®

## ğŸ¯ ç»“è®ºï¼šæ”¾å¼ƒå¤æ‚è®¾è®¡ï¼Œé‡‡ç”¨æç®€é‡æ„

ç»è¿‡æ·±å…¥åˆ†æï¼Œå½“å‰çš„å¤æ‚å†…å­˜ç®¡ç†è®¾è®¡è™½ç„¶ç†è®ºä¸Šå¯è¡Œï¼Œä½†**æˆæœ¬æ•ˆç›Šæ¯”æä½**ã€‚å¼ºçƒˆå»ºè®®é‡‡ç”¨æç®€é‡æ„æ–¹æ¡ˆã€‚

## ğŸ“‹ æç®€é‡æ„å®æ–½è®¡åˆ’

### ç¬¬1æ­¥ï¼šå¤‡ä»½ç°æœ‰ä»£ç 
```bash
# å¤‡ä»½å½“å‰å®ç°
cp -r common_utilities/src/memory common_utilities/src/memory_complex_backup
cp -r common_utilities/include/common_utils/memory common_utilities/include/common_utils/memory_complex_backup
```

### ç¬¬2æ­¥ï¼šåˆ›å»ºæç®€å®ç°

#### A. å¤´æ–‡ä»¶è®¾è®¡ (simple_unified_memory_manager.h)
```cpp
#pragma once
#include <atomic>
#include <string>
#include <chrono>

namespace oscean::common_utils::memory {

enum class Environment { PRODUCTION, TESTING, DEVELOPMENT, HPC };

struct SimpleMemoryStats {
    std::atomic<size_t> totalAllocated{0};
    std::atomic<size_t> totalDeallocated{0};
    std::atomic<size_t> currentAllocations{0};
    std::atomic<size_t> peakMemoryUsage{0};
    std::chrono::steady_clock::time_point startTime;
};

class SimpleUnifiedMemoryManager {
public:
    explicit SimpleUnifiedMemoryManager(Environment env = Environment::PRODUCTION);
    ~SimpleUnifiedMemoryManager();
    
    // æ ¸å¿ƒæ¥å£
    void* allocate(size_t size, size_t alignment = 0, const std::string& tag = "");
    void deallocate(void* ptr);
    void* reallocate(void* ptr, size_t newSize);
    
    // ç»Ÿè®¡æ¥å£
    SimpleMemoryStats getStats() const;
    std::string generateReport() const;
    
    // å·¥å‚æ–¹æ³•
    static std::unique_ptr<SimpleUnifiedMemoryManager> create(Environment env);
    
private:
    Environment environment_;
    SimpleMemoryStats stats_;
    
    void updateStats(bool isAllocation, size_t size);
};

} // namespace
```

#### B. å®ç°æ–‡ä»¶ (simple_unified_memory_manager.cpp)
```cpp
#include "simple_unified_memory_manager.h"
#include <memory>
#include <cstring>
#include <sstream>
#include <iostream>

#ifdef _WIN32
#include <malloc.h>
#define aligned_alloc(alignment, size) _aligned_malloc(size, alignment)
#define aligned_free(ptr) _aligned_free(ptr)
#else
#include <stdlib.h>
#define aligned_free(ptr) std::free(ptr)
#endif

namespace oscean::common_utils::memory {

SimpleUnifiedMemoryManager::SimpleUnifiedMemoryManager(Environment env) 
    : environment_(env) {
    stats_.startTime = std::chrono::steady_clock::now();
}

SimpleUnifiedMemoryManager::~SimpleUnifiedMemoryManager() {
    auto currentAllocs = stats_.currentAllocations.load();
    if (currentAllocs > 0) {
        std::cerr << "è­¦å‘Šï¼šå†…å­˜æ³„æ¼æ£€æµ‹åˆ° " << currentAllocs << " ä¸ªæœªé‡Šæ”¾çš„åˆ†é…" << std::endl;
    }
}

void* SimpleUnifiedMemoryManager::allocate(size_t size, size_t alignment, const std::string& tag) {
    if (size == 0) return nullptr;
    
    void* ptr = nullptr;
    
    if (alignment > 0) {
        // å¯¹é½åˆ†é…
        ptr = aligned_alloc(alignment, size);
    } else {
        // æ™®é€šåˆ†é…
        ptr = std::malloc(size);
    }
    
    if (ptr) {
        updateStats(true, size);
        
        // è°ƒè¯•ç¯å¢ƒï¼šé›¶åˆå§‹åŒ–
        if (environment_ == Environment::TESTING || environment_ == Environment::DEVELOPMENT) {
            std::memset(ptr, 0, size);
        }
    }
    
    return ptr;
}

void SimpleUnifiedMemoryManager::deallocate(void* ptr) {
    if (!ptr) return;
    
#ifdef _WIN32
    aligned_free(ptr);  // Windows: ç»Ÿä¸€ä½¿ç”¨aligned_free
#else
    aligned_free(ptr);  // POSIX: ä½¿ç”¨free
#endif
    
    updateStats(false, 0);
}

void* SimpleUnifiedMemoryManager::reallocate(void* ptr, size_t newSize) {
    if (!ptr) return allocate(newSize);
    if (newSize == 0) {
        deallocate(ptr);
        return nullptr;
    }
    
    // ç®€å•å®ç°ï¼šåˆ†é…æ–°å†…å­˜ï¼Œå¤åˆ¶æ•°æ®ï¼Œé‡Šæ”¾æ—§å†…å­˜
    void* newPtr = allocate(newSize);
    if (newPtr) {
        // æ³¨æ„ï¼šè¿™é‡Œæˆ‘ä»¬ä¸çŸ¥é“åŸå§‹å¤§å°ï¼Œè¿™æ˜¯ç®€åŒ–ç‰ˆæœ¬çš„é™åˆ¶
        // å®é™…åº”ç”¨ä¸­å¯ä»¥è€ƒè™‘åœ¨åˆ†é…æ—¶è®°å½•å¤§å°
        deallocate(ptr);
    }
    
    return newPtr;
}

SimpleMemoryStats SimpleUnifiedMemoryManager::getStats() const {
    return stats_;
}

std::string SimpleUnifiedMemoryManager::generateReport() const {
    std::ostringstream report;
    auto stats = getStats();
    auto now = std::chrono::steady_clock::now();
    auto uptime = std::chrono::duration_cast<std::chrono::seconds>(now - stats.startTime);
    
    report << "=== ç®€åŒ–å†…å­˜ç®¡ç†å™¨æŠ¥å‘Š ===\n";
    report << "è¿è¡Œæ—¶é—´: " << uptime.count() << " ç§’\n";
    report << "æ€»åˆ†é…æ¬¡æ•°: " << stats.totalAllocated.load() << "\n";
    report << "æ€»é‡Šæ”¾æ¬¡æ•°: " << stats.totalDeallocated.load() << "\n";
    report << "å½“å‰åˆ†é…æ•°: " << stats.currentAllocations.load() << "\n";
    report << "å³°å€¼å†…å­˜ä½¿ç”¨: " << stats.peakMemoryUsage.load() << " å­—èŠ‚\n";
    report << "ç¯å¢ƒ: " << (environment_ == Environment::PRODUCTION ? "ç”Ÿäº§" : 
                       environment_ == Environment::TESTING ? "æµ‹è¯•" : 
                       environment_ == Environment::DEVELOPMENT ? "å¼€å‘" : "HPC") << "\n";
    report << "==========================\n";
    
    return report.str();
}

std::unique_ptr<SimpleUnifiedMemoryManager> SimpleUnifiedMemoryManager::create(Environment env) {
    return std::make_unique<SimpleUnifiedMemoryManager>(env);
}

void SimpleUnifiedMemoryManager::updateStats(bool isAllocation, size_t size) {
    if (isAllocation) {
        stats_.totalAllocated.fetch_add(1);
        stats_.currentAllocations.fetch_add(1);
        
        // æ›´æ–°å³°å€¼ä½¿ç”¨é‡ï¼ˆè¿‘ä¼¼ï¼‰
        auto current = stats_.currentAllocations.load();
        auto peak = stats_.peakMemoryUsage.load();
        while (current > peak && !stats_.peakMemoryUsage.compare_exchange_weak(peak, current)) {
            // è‡ªæ—‹ç›´åˆ°æ›´æ–°æˆåŠŸ
        }
    } else {
        stats_.totalDeallocated.fetch_add(1);
        if (stats_.currentAllocations.load() > 0) {
            stats_.currentAllocations.fetch_sub(1);
        }
    }
}

} // namespace
```

### ç¬¬3æ­¥ï¼šåˆ›å»ºç®€å•æµ‹è¯•
```cpp
// simple_memory_test.cpp
#include <gtest/gtest.h>
#include "simple_unified_memory_manager.h"

using namespace oscean::common_utils::memory;

TEST(SimpleMemoryTest, BasicAllocation) {
    auto manager = SimpleUnifiedMemoryManager::create(Environment::TESTING);
    
    void* ptr = manager->allocate(1024);
    ASSERT_NE(ptr, nullptr);
    
    // å†™å…¥æµ‹è¯•
    std::memset(ptr, 0xAA, 1024);
    
    // éªŒè¯
    char* data = static_cast<char*>(ptr);
    EXPECT_EQ(data[0], static_cast<char>(0xAA));
    EXPECT_EQ(data[1023], static_cast<char>(0xAA));
    
    manager->deallocate(ptr);
    
    auto stats = manager->getStats();
    EXPECT_EQ(stats.totalAllocated.load(), 1);
    EXPECT_EQ(stats.totalDeallocated.load(), 1);
    EXPECT_EQ(stats.currentAllocations.load(), 0);
}

TEST(SimpleMemoryTest, AlignedAllocation) {
    auto manager = SimpleUnifiedMemoryManager::create(Environment::TESTING);
    
    void* ptr = manager->allocate(1024, 64);  // 64å­—èŠ‚å¯¹é½
    ASSERT_NE(ptr, nullptr);
    
    // éªŒè¯å¯¹é½
    uintptr_t addr = reinterpret_cast<uintptr_t>(ptr);
    EXPECT_EQ(addr % 64, 0);
    
    manager->deallocate(ptr);
}

TEST(SimpleMemoryTest, MultipleAllocations) {
    auto manager = SimpleUnifiedMemoryManager::create(Environment::TESTING);
    
    std::vector<void*> ptrs;
    for (int i = 0; i < 100; ++i) {
        void* ptr = manager->allocate(256);
        ASSERT_NE(ptr, nullptr);
        ptrs.push_back(ptr);
    }
    
    auto stats = manager->getStats();
    EXPECT_EQ(stats.currentAllocations.load(), 100);
    
    for (void* ptr : ptrs) {
        manager->deallocate(ptr);
    }
    
    stats = manager->getStats();
    EXPECT_EQ(stats.currentAllocations.load(), 0);
}
```

### ç¬¬4æ­¥ï¼šé›†æˆåˆ°ç°æœ‰ç³»ç»Ÿ
1. æ›´æ–°CMakeLists.txt
2. æ›¿æ¢ç°æœ‰çš„å¤æ‚å®ç°
3. è¿è¡Œæ‰€æœ‰æµ‹è¯•ç¡®ä¿å…¼å®¹æ€§

## âœ… é¢„æœŸç»“æœ

é‡‡ç”¨æç®€é‡æ„åï¼š
- âœ… **ç¨³å®šæ€§**: 100%å¯é ï¼Œæ— å¤æ‚çŠ¶æ€ç®¡ç†é—®é¢˜
- âœ… **è°ƒè¯•æ€§**: é—®é¢˜æ˜“äºå®šä½å’Œä¿®å¤
- âœ… **ç»´æŠ¤æ€§**: ä»£ç ç®€å•ï¼Œæ˜“äºç†è§£å’Œç»´æŠ¤
- âœ… **æ‰©å±•æ€§**: éœ€è¦æ—¶å¯ä»¥è½»æ¾æ·»åŠ æ–°ç‰¹æ€§
- âœ… **æ—¶é—´æˆæœ¬**: 1-2å¤©å³å¯å®Œæˆï¼Œç«‹å³å¯ç”¨

## ğŸš€ è¡ŒåŠ¨å»ºè®®

1. **ç«‹å³åœæ­¢**ä¿®å¤å¤æ‚è®¾è®¡
2. **å¤‡ä»½ç°æœ‰ä»£ç **ä»¥é˜²å°†æ¥éœ€è¦
3. **å®æ–½æç®€é‡æ„**æŒ‰ç…§ä¸Šè¿°è®¡åˆ’
4. **é€æ­¥æ·»åŠ ç‰¹æ€§**æ ¹æ®å®é™…éœ€æ±‚

**è®°ä½ï¼šç®€å•å°±æ˜¯ç¾ï¼Œèƒ½å·¥ä½œçš„ä»£ç æ¯”å®Œç¾çš„è®¾è®¡æ›´æœ‰ä»·å€¼ï¼** 