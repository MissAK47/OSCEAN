# å…ƒæ•°æ®æ¨¡å—å…¨é¢åŠŸèƒ½æ€§ä¸æ¶æ„æ€§åˆ†æè¯„ä¼°æŠ¥å‘Š (åŸºäºä¸‰æ¨¡å—è”åŠ¨åˆ†æ)

## ğŸ“‹ æ‰§è¡Œæ‘˜è¦ - åŸºäºèŒè´£è¾¹ç•Œçš„é‡æ–°å®šä¹‰

åŸºäºå¯¹ `common_utilities`ã€`CRSæœåŠ¡`ã€`data_accessæœåŠ¡`ã€`metadata_service` å››ä¸ªæ¨¡å—çš„æ·±å…¥åˆ†æï¼Œå‘ç°äº†**ä¸¥é‡çš„èŒè´£é‡å **å’Œ**å…³é”®åŠŸèƒ½ç¼ºå¤±**é—®é¢˜ã€‚ä¸‰ä¸ªæ¨¡å—å¿…é¡»å®Œå…¨è§£è€¦ï¼Œå„å¸å…¶èŒã€‚

### ğŸš¨ **å…³é”®å‘ç°æ±‡æ€» - åŸºäºå››æ¨¡å—è”åŠ¨åˆ†æ**

| æ¨¡å— | æ ¸å¿ƒèŒè´£ | å½“å‰é—®é¢˜ | å½±å“è¯„ä¼° |
|-----|---------|---------|---------|
| **Common Utilities** | é€šç”¨åŸºç¡€è®¾æ–½ï¼ˆæ—¶é—´ç±»å‹ã€å¼‚æ­¥æ¡†æ¶ã€ç¼“å­˜ã€æ—¥å¿—ï¼‰ | âœ… èŒè´£æ¸…æ™°ï¼Œæä¾›æŠ½è±¡æ¥å£ | ğŸŸ¢ ç¬¦åˆè®¾è®¡ |
| **Data Access** | å…·ä½“æ–‡ä»¶æ ¼å¼çš„æ•°æ®è¯»å–å’Œ**æ ¼å¼ä¸“ç”¨æ—¶é—´è§£æ** | âŒ æ—¶é—´è§£æåŠŸèƒ½å®Œå¤‡ï¼Œä½†å…ƒæ•°æ®æå–æ··ä¹± | ğŸ”´ èŒè´£æ¨¡ç³Š |
| **CRS Service** | åæ ‡ç³»è½¬æ¢å’Œç©ºé—´è®¡ç®— | âœ… èŒè´£æ¸…æ™°ï¼Œboost::futureæ¥å£ | ğŸŸ¢ ç¬¦åˆè®¾è®¡ |
| **Metadata Service** | **å…ƒä¿¡æ¯æå–ã€å­˜å‚¨ã€æ£€ç´¢ã€æŸ¥è¯¢** | âŒ æ ¸å¿ƒåŠŸèƒ½ä¸¥é‡ç¼ºå¤±ï¼Œå•åº“æ¨¡å¼ | ğŸ”´ åŠŸèƒ½ä¸å®Œæ•´ |

## ğŸ” ç¬¬ä¸€éƒ¨åˆ†ï¼šèŒè´£è¾¹ç•Œé‡æ–°å®šä¹‰

### 1.1 **Common Utilitiesçš„æ­£ç¡®èŒè´£** âœ…

**å·²æ˜ç¡®çš„åŠŸèƒ½**ï¼š
```cpp
// é€šç”¨æ—¶é—´ç±»å‹å’Œæ¥å£ - ä¸åŒ…å«æ ¼å¼ä¸“ç”¨è§£æ
namespace oscean::common_utils::time {
    struct CalendarTime;            // é€šç”¨æ—¶é—´ç±»å‹
    struct TimeRange;               // æ—¶é—´èŒƒå›´
    struct TimeResolutionInfo;      // æ—¶é—´åˆ†è¾¨ç‡ä¿¡æ¯
    struct TimeIndex;               // æ—¶é—´ç´¢å¼•ç»“æ„
    class ITimeMetadataExtractor;   // æŠ½è±¡æ—¶é—´æå–å™¨æ¥å£
    class CalendarConverter;        // æ—¥å†è½¬æ¢å™¨
}

// ğŸ”´ é‡è¦å‘ç°ï¼šç¼–è¯‘æœŸæ£€æŸ¥é˜²æ­¢æ ¼å¼ä¸“ç”¨ä»£ç 
#ifdef NETCDF_TIME_PARSER_INCLUDED
    #error "âŒ Commonå±‚ç¦æ­¢åŒ…å«NetCDFä¸“ç”¨æ—¶é—´è§£æä»£ç ï¼"
#endif
```

**å…³é”®ç‰¹ç‚¹**ï¼š
- âœ… åªæä¾›**æŠ½è±¡ç±»å‹**å’Œ**æ¥å£å®šä¹‰**
- âœ… ä¸¥æ ¼ç¦æ­¢æ ¼å¼ä¸“ç”¨å®ç°
- âœ… æä¾›ç»Ÿä¸€çš„å¼‚æ­¥æ¡†æ¶å’ŒåŸºç¡€è®¾æ–½

### 1.2 **Data Access Serviceçš„æ­£ç¡®èŒè´£** âœ…

**å·²å®ç°çš„æ—¶é—´å¤„ç†åŠŸèƒ½**ï¼š
```cpp
// NetCDFæ—¶é—´è§£æå™¨ - å±äºData Accesså±‚
namespace oscean::core_services::data_access::readers::netcdf::parsing {
    class TimeProcessor {
        Result<CalendarTime> convertToTimePoint(double timeValue, int varid);
        Result<TimeResolutionInfo> analyzeTimeResolutionAsync() const;
    };
    
    class CFConventions {
        Result<bool> isTimeVariable(int ncid, int varid);
        Result<std::string> getCalendar(int ncid, int varid);
    };
    
    struct TimeSpecificInfo {
        std::string calendar;
        std::string referenceDateString;
        TimeUnit::Type timeUnit;
        bool hasRegularSpacing;
        std::vector<double> values;
    };
}
```

**å…³é”®å‘ç°**ï¼š
- âœ… **Data Accesså·²å…·å¤‡å®Œæ•´çš„NCæ–‡ä»¶æ—¶é—´è§£æèƒ½åŠ›**
- âœ… æ”¯æŒéæ ‡å‡†æ—¶é—´æ ¼å¼è½¬æ¢ (`seconds since 1970-01-01`)
- âœ… æ”¯æŒæ—¶é—´åˆ†è¾¨ç‡è¯†åˆ« (ç§’ã€åˆ†ã€æ—¶ã€æ—¥ã€æœˆã€å¹´)
- âœ… æ”¯æŒCFæ—¶é—´æ ‡å‡†å’Œå¤šç§æ—¥å†ç±»å‹

### 1.3 **Metadata Serviceçš„åº”æœ‰èŒè´£** âŒ

**è®¾è®¡è¦æ±‚ä½†ç¼ºå¤±çš„åŠŸèƒ½**ï¼š
```cpp
// å…ƒæ•°æ®æœåŠ¡åº”ä¸“æ³¨äºå…ƒä¿¡æ¯ç®¡ç†ï¼Œä¸ç›´æ¥è§£ææ–‡ä»¶
namespace oscean::core_services::metadata {
    
    // ğŸ”´ ç¼ºå¤±ï¼šå¤šåº“æ¨¡å¼æ”¯æŒ
    class MultiDatabaseManager {
        // æµ·æ´‹ç¯å¢ƒåŠ¨æ€æ•°æ®åº“
        std::shared_ptr<IMetadataStorage> oceanEnvironmentDB_;
        // åœ°å½¢åº•è´¨æ•°æ®åº“  
        std::shared_ptr<IMetadataStorage> topographyDB_;
        // è¾¹ç•Œçº¿æ•°æ®åº“
        std::shared_ptr<IMetadataStorage> boundaryDB_;
        // å£°çº³ä¼ æ’­æŸå¤±æ•°æ®åº“
        std::shared_ptr<IMetadataStorage> sonarPropagationDB_;
    };
    
    // ğŸ”´ ç¼ºå¤±ï¼šæ ‡å‡†åŒ–å…ƒæ•°æ®æå–æ¥å£
    class StandardizedMetadataExtractor {
        Future<MetadataExtractionResult> extractFromDataAccess(
            const std::string& filePath,
            const std::string& dataType // "ocean", "topography", "boundary", "sonar"
        );
    };
}
```

## ğŸ” ç¬¬äºŒéƒ¨åˆ†ï¼šå…ƒæ•°æ®æ¨¡å—å…³é”®ç¼ºå¤±åŠŸèƒ½åˆ†æ

### 2.1 **âŒ å¤šåº“æ¨¡å¼æ”¯æŒå®Œå…¨ç¼ºå¤±**

**å½“å‰çŠ¶æ€**ï¼š
```cpp
// å½“å‰åªæ”¯æŒå•ä¸€SQLiteæ•°æ®åº“
class SQLiteStorage : public IDatasetMetadataRegistryBackend {
    sqlite3* db_ = nullptr;  // å•ä¸€æ•°æ®åº“è¿æ¥
    std::string dbPath_;     // å•ä¸€æ•°æ®åº“æ–‡ä»¶
};
```

**ç”¨æˆ·éœ€æ±‚**ï¼š
> æˆ‘ä»¬å…·æœ‰æµ·æ´‹ç¯å¢ƒåŠ¨æ€æ•°æ®ã€åœ°å½¢åº•è´¨ã€è¾¹ç•Œçº¿ç­‰å¤šç§é™æ€æ•°æ®ï¼ŒåŒæ—¶æˆ‘ä»¬è¿˜è¦æ”¯æŒä»¥åæ ‡ä¸ºä¸­å¿ƒçš„å£°çº³ä¼ æ’­æŸå¤±æ•°æ®ncæ–‡ä»¶

**ä¿®æ­£è¦æ±‚**ï¼š
```cpp
// å¤šåº“æ¨¡å¼è®¾è®¡
enum class DataType {
    OCEAN_ENVIRONMENT,     // æµ·æ´‹ç¯å¢ƒåŠ¨æ€æ•°æ®
    TOPOGRAPHY_BATHYMETRY, // åœ°å½¢åº•è´¨æ•°æ®
    BOUNDARY_LINES,        // è¾¹ç•Œçº¿æ•°æ®
    SONAR_PROPAGATION     // å£°çº³ä¼ æ’­æŸå¤±æ•°æ®
};

class MultiDatabaseMetadataManager {
    std::map<DataType, std::shared_ptr<IMetadataStorage>> databases_;
    
    Future<AsyncResult<void>> storeMetadata(
        const MetadataEntry& entry,
        DataType dataType
    );
    
    Future<AsyncResult<std::vector<MetadataEntry>>> queryAcrossAllDatabases(
        const MetadataQueryCriteria& criteria
    );
};
```

### 2.2 **âŒ æ—¶é—´å…ƒæ•°æ®å¤„ç†èŒè´£æ··ä¹±**

**èŒè´£è¾¹ç•Œé—®é¢˜**ï¼š
- âŒ **Metadata Serviceä¸åº”ç›´æ¥è§£æNCæ–‡ä»¶æ—¶é—´**
- âœ… **åº”è°ƒç”¨Data Access Serviceè·å–è§£æç»“æœ**
- âŒ **å½“å‰æ··åˆäº†æå–å’Œå­˜å‚¨èŒè´£**

**æ­£ç¡®çš„è°ƒç”¨é“¾**ï¼š
```cpp
// æ­£ç¡®çš„èŒè´£åˆ†å·¥
namespace oscean::core_services::metadata {

class MetadataOrchestrator {
public:
    Future<AsyncResult<DatasetMetadataEntry>> extractAndStoreMetadata(
        const std::string& filePath,
        DataType dataType
    ) {
        // 1. è°ƒç”¨Data Access Serviceè¿›è¡Œæ–‡ä»¶è§£æï¼ˆä¸æ˜¯è‡ªå·±è§£æï¼‰
        auto fileMetadata = dataAccessService_->extractFileMetadataAsync(filePath);
        
        // 2. è°ƒç”¨CRS Serviceè¿›è¡Œåæ ‡è½¬æ¢ï¼ˆå¦‚éœ€è¦ï¼‰
        if (requiresCrsTransformation(fileMetadata.crs)) {
            auto transformedBbox = crsService_->transformBoundingBoxAsync(
                fileMetadata.spatialCoverage, targetCrs_);
        }
        
        // 3. è½¬æ¢ä¸ºæ ‡å‡†åŒ–å…ƒæ•°æ®æ ¼å¼ï¼ˆè¿™æ˜¯Metadata Serviceçš„èŒè´£ï¼‰
        auto standardizedEntry = convertToStandardizedMetadata(fileMetadata, dataType);
        
        // 4. å­˜å‚¨åˆ°å¯¹åº”çš„æ•°æ®åº“ï¼ˆå¤šåº“æ¨¡å¼ï¼‰
        return storeToDatabase(standardizedEntry, dataType);
    }

private:
    std::shared_ptr<IRawDataAccessService> dataAccessService_;
    std::shared_ptr<ICrsService> crsService_;
    std::shared_ptr<MultiDatabaseManager> databaseManager_;
};

}
```

### 2.3 **âŒ ç©ºé—´åˆ†è¾¨ç‡æŸ¥è¯¢ä¼˜åŒ–ç¼ºå¤±**

**ç”¨æˆ·éœ€æ±‚**ï¼š
> æ”¯æŒç©ºé—´åˆ†è¾¨ç‡çš„æŸ¥è¯¢

**å½“å‰æ•°æ®åº“Schemaé—®é¢˜**ï¼š
```sql
-- âŒ å½“å‰ç¼ºå°‘ç©ºé—´åˆ†è¾¨ç‡å­—æ®µå’Œç´¢å¼•
CREATE TABLE files (
    -- ç¼ºå°‘ç©ºé—´åˆ†è¾¨ç‡ç›¸å…³å­—æ®µ
    bbox_min_x REAL,
    bbox_max_x REAL,
    -- ...
);
```

**ä¿®æ­£è¦æ±‚**ï¼š
```sql
-- âœ… ä¼˜åŒ–åçš„å¤šåº“Schemaè®¾è®¡
-- æµ·æ´‹ç¯å¢ƒåŠ¨æ€æ•°æ®åº“
CREATE TABLE ocean_environment_metadata (
    id TEXT PRIMARY KEY,
    file_path TEXT NOT NULL,
    
    -- ç©ºé—´ä¿¡æ¯
    spatial_resolution_x REAL,  -- Xæ–¹å‘ç©ºé—´åˆ†è¾¨ç‡ï¼ˆç±³ï¼‰
    spatial_resolution_y REAL,  -- Yæ–¹å‘ç©ºé—´åˆ†è¾¨ç‡ï¼ˆç±³ï¼‰
    spatial_resolution_category TEXT, -- "high"(<=100m), "medium"(100m-1km), "low"(>1km)
    
    -- æ—¶é—´ä¿¡æ¯ï¼ˆä½¿ç”¨Commonçš„æ ‡å‡†æ—¶é—´ç±»å‹ï¼‰
    time_resolution_seconds INTEGER,
    time_coverage_start INTEGER,
    time_coverage_end INTEGER,
    time_quality_score REAL DEFAULT 1.0,
    
    -- æµ·æ´‹ä¸“ç”¨å­—æ®µ
    ocean_variables TEXT,        -- æµ·æ´‹å˜é‡åˆ—è¡¨ï¼ˆJSONï¼‰
    depth_levels INTEGER,        -- æ·±åº¦å±‚æ•°
    max_depth REAL,             -- æœ€å¤§æ·±åº¦
    
    UNIQUE(file_path)
);

-- å£°çº³ä¼ æ’­æŸå¤±æ•°æ®åº“ï¼ˆåæ ‡ä¸­å¿ƒï¼‰
CREATE TABLE sonar_propagation_metadata (
    id TEXT PRIMARY KEY,
    file_path TEXT NOT NULL,
    
    -- ä¸­å¿ƒåæ ‡
    center_longitude REAL NOT NULL,
    center_latitude REAL NOT NULL,
    center_depth REAL DEFAULT 0,
    
    -- ä¼ æ’­èŒƒå›´
    propagation_radius_m REAL,  -- ä¼ æ’­åŠå¾„ï¼ˆç±³ï¼‰
    frequency_hz REAL,          -- å£°çº³é¢‘ç‡
    
    -- ç©ºé—´åˆ†è¾¨ç‡
    radial_resolution_m REAL,   -- å¾„å‘åˆ†è¾¨ç‡
    angular_resolution_deg REAL, -- è§’åº¦åˆ†è¾¨ç‡
    
    UNIQUE(file_path)
);

-- ç©ºé—´åˆ†è¾¨ç‡æŸ¥è¯¢ç´¢å¼•
CREATE INDEX idx_ocean_spatial_resolution ON ocean_environment_metadata(spatial_resolution_category, spatial_resolution_x);
CREATE INDEX idx_sonar_propagation_range ON sonar_propagation_metadata(center_longitude, center_latitude, propagation_radius_m);
```

## ğŸ” ç¬¬ä¸‰éƒ¨åˆ†ï¼šé€‚é…ä¿®æ­£æ–¹æ¡ˆ

### 3.1 **æ ¸å¿ƒæ¶æ„ä¿®æ­£ - åŸºäºèŒè´£æ¸…æ™°åŒ–**

```cpp
// æ–‡ä»¶: include/core_services/metadata/unified_metadata_service.h
#pragma once

#include "common_utils/time/time_types.h"
#include "common_utils/async/async_types.h"
#include "core_services/data_access/i_raw_data_access_service.h"
#include "core_services/crs/i_crs_service.h"

namespace oscean::core_services::metadata {

/**
 * @brief æ•°æ®ç±»å‹æšä¸¾ - æ”¯æŒå¤šåº“æ¨¡å¼
 */
enum class DataType {
    OCEAN_ENVIRONMENT,     // æµ·æ´‹ç¯å¢ƒåŠ¨æ€æ•°æ®
    TOPOGRAPHY_BATHYMETRY, // åœ°å½¢åº•è´¨æ•°æ®  
    BOUNDARY_LINES,        // è¾¹ç•Œçº¿æ•°æ®
    SONAR_PROPAGATION,     // å£°çº³ä¼ æ’­æŸå¤±æ•°æ®ï¼ˆåæ ‡ä¸­å¿ƒï¼‰
    UNKNOWN
};

/**
 * @brief æ ‡å‡†åŒ–å…ƒæ•°æ®æ¡ç›® - é€‚åº”å¤šç§æ•°æ®ç±»å‹
 */
struct StandardizedMetadataEntry {
    std::string id;
    std::string filePath;
    DataType dataType;
    
    // é€šç”¨ç©ºé—´ä¿¡æ¯
    BoundingBox spatialCoverage;
    double spatialResolutionX;  // ç±³
    double spatialResolutionY;  // ç±³
    std::string resolutionCategory; // "high", "medium", "low"
    
    // é€šç”¨æ—¶é—´ä¿¡æ¯ï¼ˆä½¿ç”¨Commonæ ‡å‡†ç±»å‹ï¼‰
    common_utils::time::TimeRange timeCoverage;
    common_utils::time::TimeResolutionInfo timeResolution;
    double timeQualityScore;
    
    // ç±»å‹ä¸“ç”¨ä¿¡æ¯ï¼ˆJSONå­˜å‚¨ï¼‰
    std::map<std::string, std::string> typeSpecificMetadata;
    
    // ç³»ç»Ÿä¿¡æ¯
    std::chrono::system_clock::time_point lastIndexedTime;
    size_t fileSize;
    std::string checksum;
};

/**
 * @brief å¤šåº“å…ƒæ•°æ®ç®¡ç†å™¨ - æ ¸å¿ƒèŒè´£ç±»
 */
class MultiDatabaseMetadataManager {
public:
    /**
     * @brief åˆå§‹åŒ–å¤šä¸ªæ•°æ®åº“
     */
    Future<AsyncResult<void>> initializeAsync(
        const std::map<DataType, std::string>& databasePaths
    );
    
    /**
     * @brief å­˜å‚¨å…ƒæ•°æ®åˆ°å¯¹åº”æ•°æ®åº“
     */
    Future<AsyncResult<void>> storeMetadataAsync(
        const StandardizedMetadataEntry& entry
    );
    
    /**
     * @brief è·¨åº“æŸ¥è¯¢å…ƒæ•°æ®
     */
    Future<AsyncResult<std::vector<StandardizedMetadataEntry>>> queryMetadataAsync(
        const MetadataQueryCriteria& criteria,
        const std::set<DataType>& targetDataTypes = {} // ç©ºè¡¨ç¤ºæŸ¥è¯¢æ‰€æœ‰åº“
    );
    
    /**
     * @brief ç©ºé—´åˆ†è¾¨ç‡èŒƒå›´æŸ¥è¯¢
     */
    Future<AsyncResult<std::vector<StandardizedMetadataEntry>>> queryBySpatialResolutionAsync(
        double minResolutionM,
        double maxResolutionM,
        const std::set<DataType>& targetDataTypes = {}
    );
    
    /**
     * @brief å£°çº³ä¼ æ’­æŸå¤±ä¸“ç”¨æŸ¥è¯¢ï¼ˆåæ ‡ä¸­å¿ƒï¼‰
     */
    Future<AsyncResult<std::vector<StandardizedMetadataEntry>>> querySonarDataByCenterAsync(
        double centerLon,
        double centerLat, 
        double searchRadiusM
    );

private:
    std::map<DataType, std::shared_ptr<IMetadataStorage>> databases_;
    std::shared_ptr<common_utils::async::IAsyncExecutor> asyncExecutor_;
};

/**
 * @brief å…ƒæ•°æ®ç¼–æ’å™¨ - åè°ƒä¸‰ä¸ªæœåŠ¡çš„äº¤äº’
 */
class MetadataOrchestrator {
public:
    MetadataOrchestrator(
        std::shared_ptr<IRawDataAccessService> dataAccessService,
        std::shared_ptr<ICrsService> crsService,
        std::shared_ptr<MultiDatabaseMetadataManager> databaseManager
    );
    
    /**
     * @brief å®Œæ•´çš„å…ƒæ•°æ®æå–å’Œå­˜å‚¨æµç¨‹
     */
    Future<AsyncResult<std::string>> processFileAsync(
        const std::string& filePath,
        DataType dataType,
        const MetadataExtractionOptions& options = {}
    );
    
    /**
     * @brief æ‰¹é‡å¤„ç†ç›®å½•
     */
    Future<StreamingResult<std::string>> processDirectoryAsync(
        const std::string& directoryPath,
        DataType dataType,
        bool recursive = true
    );

private:
    std::shared_ptr<IRawDataAccessService> dataAccessService_;
    std::shared_ptr<ICrsService> crsService_;
    std::shared_ptr<MultiDatabaseMetadataManager> databaseManager_;
    
    /**
     * @brief è½¬æ¢Data Accessç»“æœä¸ºæ ‡å‡†åŒ–å…ƒæ•°æ®
     */
    StandardizedMetadataEntry convertToStandardized(
        const FileMetadata& fileMetadata,
        DataType dataType
    );
    
    /**
     * @brief ç¡®å®šæ•°æ®ç±»å‹ï¼ˆåŸºäºæ–‡ä»¶è·¯å¾„ã€å†…å®¹ç­‰ï¼‰
     */
    DataType determineDataType(const std::string& filePath);
};

/**
 * @brief ç»Ÿä¸€å…ƒæ•°æ®æœåŠ¡æ¥å£ - ç¬¦åˆè®¾è®¡æ–‡æ¡£
 */
class IUnifiedMetadataService {
public:
    virtual ~IUnifiedMetadataService() = default;
    
    // === å¤šåº“æ¨¡å¼çš„æ ¸å¿ƒæ¥å£ ===
    
    /**
     * @brief æ³¨å†Œæ•°æ®æ–‡ä»¶ï¼ˆè‡ªåŠ¨ç¡®å®šæ•°æ®ç±»å‹ï¼‰
     */
    virtual Future<AsyncResult<std::string>> registerDataFileAsync(
        const std::string& filePath,
        const std::optional<DataType>& explicitType = std::nullopt
    ) = 0;
    
    /**
     * @brief æ‰¹é‡æ³¨å†Œç›®å½•ï¼ˆæ”¯æŒæ··åˆæ•°æ®ç±»å‹ï¼‰
     */
    virtual Future<StreamingResult<std::string>> registerDirectoryAsync(
        const std::string& directoryPath,
        bool recursive = true
    ) = 0;
    
    /**
     * @brief è·¨åº“æŸ¥è¯¢ - æ”¯æŒç©ºé—´åˆ†è¾¨ç‡è¿‡æ»¤
     */
    virtual Future<AsyncResult<std::vector<StandardizedMetadataEntry>>> queryMetadataAsync(
        const MetadataQueryCriteria& criteria,
        const std::optional<std::pair<double,double>>& spatialResolutionRange = std::nullopt,
        const std::set<DataType>& targetDataTypes = {}
    ) = 0;
    
    /**
     * @brief å£°çº³æ•°æ®ä¸“ç”¨æŸ¥è¯¢
     */
    virtual Future<AsyncResult<std::vector<StandardizedMetadataEntry>>> querySonarDataAsync(
        double centerLon,
        double centerLat,
        double searchRadiusM,
        const std::optional<std::pair<double,double>>& frequencyRange = std::nullopt
    ) = 0;
    
    // === æ•°æ®åº“ç®¡ç†æ¥å£ ===
    
    /**
     * @brief è·å–å„åº“ç»Ÿè®¡ä¿¡æ¯
     */
    virtual Future<AsyncResult<std::map<DataType, DatabaseStats>>> getDatabaseStatsAsync() = 0;
    
    /**
     * @brief æ•°æ®åº“ç»´æŠ¤ï¼ˆæ¸…ç†ã€é‡å»ºç´¢å¼•ç­‰ï¼‰
     */
    virtual Future<AsyncResult<void>> performMaintenanceAsync(
        const std::set<DataType>& targetDatabases = {}
    ) = 0;
};

} // namespace oscean::core_services::metadata
```

### 3.2 **æ—¶é—´å¤„ç†æ­£ç¡®çš„èŒè´£åˆ†å·¥**

```cpp
// æ–‡ä»¶: src/impl/time_metadata_adapter.cpp
// Metadata Serviceä¸­çš„æ—¶é—´é€‚é…å™¨ - ä¸ç›´æ¥è§£æï¼Œåªè½¬æ¢æ ¼å¼

namespace oscean::core_services::metadata::impl {

/**
 * @brief æ—¶é—´å…ƒæ•°æ®é€‚é…å™¨ - å°†Data Accessç»“æœè½¬æ¢ä¸ºCommonæ ‡å‡†ç±»å‹
 */
class TimeMetadataAdapter {
public:
    /**
     * @brief å°†Data Accessçš„æ—¶é—´ä¿¡æ¯è½¬æ¢ä¸ºCommonæ ‡å‡†ç±»å‹
     */
    static common_utils::time::TimeRange convertTimeRange(
        const FileMetadata& fileMetadata
    ) {
        // ä¸ç›´æ¥è§£ææ–‡ä»¶ï¼Œä½¿ç”¨Data Accessæä¾›çš„ç»“æœ
        common_utils::time::CalendarTime startTime;
        startTime.timePoint = std::chrono::system_clock::from_time_t(
            fileMetadata.temporalCoverage.startTime
        );
        startTime.calendarType = "gregorian";
        
        common_utils::time::CalendarTime endTime;
        endTime.timePoint = std::chrono::system_clock::from_time_t(
            fileMetadata.temporalCoverage.endTime
        );
        endTime.calendarType = "gregorian";
        
        return common_utils::time::TimeRange{startTime, endTime};
    }
    
    /**
     * @brief è®¡ç®—æ—¶é—´åˆ†è¾¨ç‡ä¿¡æ¯
     */
    static common_utils::time::TimeResolutionInfo calculateTimeResolution(
        const FileMetadata& fileMetadata
    ) {
        common_utils::time::TimeResolutionInfo resInfo;
        
        // åŸºäºData Accessæä¾›çš„æ—¶é—´ç‚¹è®¡ç®—åˆ†è¾¨ç‡
        if (fileMetadata.timePoints.size() >= 2) {
            auto interval = fileMetadata.timePoints[1] - fileMetadata.timePoints[0];
            resInfo.nominalResolution = std::chrono::seconds(interval);
            resInfo.isRegular = true; // å¯è¿›ä¸€æ­¥åˆ†æ
        }
        
        return resInfo;
    }
    
    /**
     * @brief è¯„ä¼°æ—¶é—´è´¨é‡
     */
    static double assessTimeQuality(const FileMetadata& fileMetadata) {
        double qualityScore = 1.0;
        
        // åŸºäºæ—¶é—´ç‚¹è§„å¾‹æ€§è¯„ä¼°
        if (fileMetadata.timePoints.size() < 2) {
            qualityScore *= 0.5;
        }
        
        // åŸºäºæ—¶é—´èŒƒå›´åˆç†æ€§è¯„ä¼°
        auto timeSpan = fileMetadata.temporalCoverage.endTime - 
                       fileMetadata.temporalCoverage.startTime;
        if (timeSpan <= 0) {
            qualityScore *= 0.3;
        }
        
        return qualityScore;
    }
};

} // namespace oscean::core_services::metadata::impl
```

## ğŸ¯ å®æ–½è®¡åˆ’

### Phase 1: æ¶æ„é‡æ„ (1å‘¨)
- [ ] å®ç°å¤šåº“æ¨¡å¼`MultiDatabaseMetadataManager`
- [ ] åˆ›å»º`MetadataOrchestrator`åè°ƒä¸‰æœåŠ¡äº¤äº’  
- [ ] å®ç°`TimeMetadataAdapter`æ­£ç¡®åˆ†å·¥

### Phase 2: æ•°æ®åº“é‡æ„ (1å‘¨)  
- [ ] è®¾è®¡å››ç§æ•°æ®ç±»å‹çš„ä¸“ç”¨Schema
- [ ] å®ç°ç©ºé—´åˆ†è¾¨ç‡æŸ¥è¯¢ä¼˜åŒ–
- [ ] æ·»åŠ å£°çº³ä¼ æ’­æŸå¤±ä¸“ç”¨ç´¢å¼•

### Phase 3: æ¥å£ç»Ÿä¸€ (1å‘¨)
- [ ] å®ç°`IUnifiedMetadataService`ç»Ÿä¸€æ¥å£
- [ ] é›†æˆä¸‰ä¸ªæœåŠ¡çš„å¼‚æ­¥è°ƒç”¨é“¾
- [ ] æ·»åŠ æµå¼å¤„ç†æ”¯æŒ

### Phase 4: æµ‹è¯•éªŒè¯ (1å‘¨)
- [ ] å¤šåº“æ¨¡å¼åŠŸèƒ½æµ‹è¯•
- [ ] è·¨æœåŠ¡åä½œæµ‹è¯•  
- [ ] æ€§èƒ½åŸºå‡†æµ‹è¯•

## ğŸ“Š éªŒæ”¶æ ‡å‡†

### èŒè´£è¾¹ç•ŒéªŒæ”¶
- [ ] Metadata Serviceä¸ç›´æ¥è§£ææ–‡ä»¶æ ¼å¼
- [ ] æ—¶é—´è§£æ100%å§”æ‰˜ç»™Data Access Service
- [ ] åæ ‡è½¬æ¢100%å§”æ‰˜ç»™CRS Service
- [ ] Common Utilitiesåªæä¾›æŠ½è±¡ç±»å‹

### å¤šåº“æ¨¡å¼éªŒæ”¶
- [ ] æ”¯æŒå››ç§æ•°æ®ç±»å‹ç‹¬ç«‹å­˜å‚¨
- [ ] è·¨åº“æŸ¥è¯¢åŠŸèƒ½å®Œå¤‡
- [ ] ç©ºé—´åˆ†è¾¨ç‡æŸ¥è¯¢ä¼˜åŒ–
- [ ] å£°çº³æ•°æ®åæ ‡ä¸­å¿ƒæŸ¥è¯¢

### æ€§èƒ½éªŒæ”¶  
- [ ] å¤šåº“æŸ¥è¯¢æ€§èƒ½ > å•åº“æ¨¡å¼æ€§èƒ½
- [ ] ç©ºé—´åˆ†è¾¨ç‡æŸ¥è¯¢å“åº”æ—¶é—´ < 100ms
- [ ] æ”¯æŒTBçº§æ•°æ®çš„æµå¼å¤„ç†

---

## ğŸ“ ç»“è®º

å…ƒæ•°æ®æ¨¡å—éœ€è¦**èŒè´£é‡æ–°å®šä¹‰**å’Œ**å¤šåº“æ¶æ„é‡æ„**ï¼Œä¸æ˜¯ç®€å•çš„æ¥å£é€‚é…ã€‚æ ¸å¿ƒæ˜¯å»ºç«‹æ­£ç¡®çš„æ¨¡å—åä½œæ¨¡å¼ï¼š**Data Accessè´Ÿè´£è§£æï¼ŒCRSè´Ÿè´£è½¬æ¢ï¼ŒMetadataè´Ÿè´£å­˜å‚¨å’ŒæŸ¥è¯¢**ï¼ŒCommonæä¾›ç»Ÿä¸€æŠ½è±¡ã€‚è¿™å°†å½»åº•è§£å†³èŒè´£é‡å é—®é¢˜ï¼Œå®ç°çœŸæ­£çš„æ¨¡å—åŒ–è®¾è®¡ã€‚ 

## ğŸ” ç¬¬å››éƒ¨åˆ†ï¼šæ™ºèƒ½ç´¢å¼•ä¸ä¼ æ„Ÿå™¨è”åˆæŸ¥è¯¢éœ€æ±‚

### 4.1 **âŒ æ™ºèƒ½ç´¢å¼•ç³»ç»Ÿå®Œå…¨ç¼ºå¤±**

**ç”¨æˆ·éœ€æ±‚**ï¼š
> å…ƒæ•°æ®ç´¢å¼•éœ€è¦å®ç°ç©ºé—´ã€æ—¶é—´ã€ç»´åº¦ã€å˜é‡çš„æ™ºèƒ½ç´¢å¼•ä¸æŸ¥è¯¢ï¼Œå¹¶ä¸”è‡ªåŠ¨å¯¹æ•°æ®çš„æ—¶é—´ã€ç©ºé—´å’Œå˜é‡è¯†åˆ«ç»Ÿè®¡

**å½“å‰çŠ¶æ€**ï¼š
```cpp
// âŒ å½“å‰åªæœ‰åŸºç¡€çš„æ–‡ä»¶ç´¢å¼•ï¼Œç¼ºä¹æ™ºèƒ½åˆ†æ
class SQLiteStorage {
    // ä»…æœ‰ç®€å•çš„æ–‡ä»¶è·¯å¾„å’ŒåŸºæœ¬å…ƒæ•°æ®å­˜å‚¨
    sqlite3* db_ = nullptr;
};
```

**ä¿®æ­£è¦æ±‚ - å››ç»´æ™ºèƒ½ç´¢å¼•ç³»ç»Ÿ**ï¼š
```cpp
// æ–‡ä»¶: include/core_services/metadata/intelligent_indexing_system.h
#pragma once

#include "common_utils/time/time_types.h"
#include "common_utils/async/async_types.h"

namespace oscean::core_services::metadata {

/**
 * @brief å››ç»´æ™ºèƒ½ç´¢å¼•ç®¡ç†å™¨
 */
class IntelligentIndexManager {
public:
    /**
     * @brief ç©ºé—´æ™ºèƒ½ç´¢å¼• - å¤šå±‚æ¬¡ç©ºé—´åˆ’åˆ†
     */
    struct SpatialIndex {
        // å…¨çƒç½‘æ ¼åˆ†çº§ç´¢å¼• (0.1Â°, 1Â°, 10Â°)
        std::map<int, std::map<std::pair<int,int>, std::vector<std::string>>> globalGridIndex_;
        
        // ç©ºé—´åˆ†è¾¨ç‡åˆ†çº§ç´¢å¼•
        std::map<std::string, std::vector<std::string>> resolutionIndex_; // "high", "medium", "low"
        
        // R-Treeç©ºé—´ç´¢å¼•ï¼ˆç²¾ç¡®èŒƒå›´æŸ¥è¯¢ï¼‰
        std::unique_ptr<class RTreeIndex> rtreeIndex_;
    };
    
    /**
     * @brief æ—¶é—´æ™ºèƒ½ç´¢å¼• - å¤šç²’åº¦æ—¶é—´åˆ†æ
     */
    struct TemporalIndex {
        // æ—¶é—´åˆ†è¾¨ç‡åˆ†çº§ç´¢å¼•
        std::map<std::chrono::seconds, std::vector<std::string>> timeResolutionIndex_;
        
        // æ—¶é—´è´¨é‡åˆ†çº§ç´¢å¼•
        std::map<double, std::vector<std::string>> timeQualityIndex_;
        
        // æ—¶é—´è¦†ç›–èŒƒå›´ç´¢å¼•ï¼ˆå¹´ã€æœˆã€æ—¥çº§åˆ«ï¼‰
        std::map<int, std::map<int, std::map<int, std::vector<std::string>>>> dateCoverageIndex_;
        
        // å®æ—¶æ•°æ® vs å†å²æ•°æ®ç´¢å¼•
        std::map<bool, std::vector<std::string>> realTimeIndex_;
    };
    
    /**
     * @brief ç»´åº¦æ™ºèƒ½ç´¢å¼• - æ•°æ®ç»´åº¦åˆ†æ
     */
    struct DimensionalIndex {
        // æŒ‰ç»´åº¦æ•°é‡åˆ†ç±» (2D, 3D, 4Dç­‰)
        std::map<int, std::vector<std::string>> dimensionCountIndex_;
        
        // æŒ‰ç½‘æ ¼å¤§å°åˆ†ç±»
        std::map<std::pair<int,int>, std::vector<std::string>> gridSizeIndex_;
        
        // å‚ç›´å±‚æ•°ç´¢å¼•ï¼ˆæµ·æ´‹æ•°æ®ä¸“ç”¨ï¼‰
        std::map<int, std::vector<std::string>> depthLevelsIndex_;
        
        // æ•°æ®å¯†åº¦ç´¢å¼•ï¼ˆç¨€ç–/å¯†é›†ï¼‰
        std::map<std::string, std::vector<std::string>> dataDensityIndex_;
    };
    
    /**
     * @brief å˜é‡æ™ºèƒ½ç´¢å¼• - ç§‘å­¦å˜é‡åˆ†ç±»
     */
    struct VariableIndex {
        // å˜é‡ç±»å‹åˆ†ç±» (ç‰©ç†ã€åŒ–å­¦ã€ç”Ÿç‰©ç­‰)
        std::map<std::string, std::vector<std::string>> variableTypeIndex_;
        
        // æ ‡å‡†åç§°ç´¢å¼• (CF Convention)
        std::map<std::string, std::vector<std::string>> standardNameIndex_;
        
        // å•ä½ç³»ç»Ÿç´¢å¼• (SI, CGSç­‰)
        std::map<std::string, std::vector<std::string>> unitSystemIndex_;
        
        // å˜é‡æ•°é‡åˆ†çº§ç´¢å¼•
        std::map<int, std::vector<std::string>> variableCountIndex_;
        
        // å¤šå˜é‡å…³è”ç´¢å¼•ï¼ˆå˜é‡ç»„åˆï¼‰
        std::map<std::set<std::string>, std::vector<std::string>> variableCombinationIndex_;
    };
    
    /**
     * @brief å¼‚æ­¥æ„å»ºæ™ºèƒ½ç´¢å¼•
     */
    boost::future<AsyncResult<void>> buildIntelligentIndicesAsync(
        const std::vector<StandardizedMetadataEntry>& entries
    );
    
    /**
     * @brief å››ç»´è”åˆæŸ¥è¯¢
     */
    boost::future<AsyncResult<std::vector<std::string>>> queryByFourDimensionsAsync(
        const SpatialQueryCriteria& spatialCriteria,
        const TemporalQueryCriteria& temporalCriteria,
        const DimensionalQueryCriteria& dimensionalCriteria,
        const VariableQueryCriteria& variableCriteria
    );
    
    /**
     * @brief è‡ªåŠ¨æ•°æ®ç»Ÿè®¡åˆ†æ
     */
    boost::future<AsyncResult<DataStatisticsReport>> generateStatisticsReportAsync();

private:
    SpatialIndex spatialIndex_;
    TemporalIndex temporalIndex_;
    DimensionalIndex dimensionalIndex_;
    VariableIndex variableIndex_;
    
    std::shared_ptr<common_utils::async::IAsyncExecutor> asyncExecutor_;
};

/**
 * @brief æ•°æ®ç»Ÿè®¡æŠ¥å‘Š
 */
struct DataStatisticsReport {
    // ç©ºé—´è¦†ç›–ç»Ÿè®¡
    struct SpatialStats {
        BoundingBox globalCoverage;
        double averageResolution;
        std::map<std::string, int> resolutionDistribution;
        int totalSpatialFiles;
    } spatialStats;
    
    // æ—¶é—´è¦†ç›–ç»Ÿè®¡
    struct TemporalStats {
        common_utils::time::TimeRange globalTimeRange;
        std::map<std::chrono::seconds, int> resolutionDistribution;
        double averageTimeQuality;
        int realTimeDataCount;
        int historicalDataCount;
    } temporalStats;
    
    // å˜é‡ç»Ÿè®¡
    struct VariableStats {
        std::map<std::string, int> variableFrequency;
        std::map<std::string, int> standardNameFrequency;
        std::map<std::string, int> unitFrequency;
        int totalUniqueVariables;
    } variableStats;
    
    // ç»´åº¦ç»Ÿè®¡
    struct DimensionalStats {
        std::map<int, int> dimensionDistribution;
        std::map<std::pair<int,int>, int> gridSizeDistribution;
        double averageDataDensity;
    } dimensionalStats;
};

} // namespace oscean::core_services::metadata
```

### 4.2 **âŒ ä¼ æ„Ÿå™¨è”åˆç´¢å¼•ç³»ç»Ÿç¼ºå¤±**

**ç”¨æˆ·éœ€æ±‚**ï¼š
> å¯¹äºä¼ æ’­æŸå¤±æ•°æ®åº“ï¼Œé™¤äº†ä¸­å¿ƒç‚¹åæ ‡ç´¢å¼•å¤–ï¼Œè¿˜éœ€è¦æ”¯æŒå¹³å°IDã€ä¼ æ„Ÿå™¨IDä»¥åŠä¼ æ„Ÿå™¨å·¥ä½œæ¨¡å¼IDå’Œæ—¶é—´çš„è”åˆç´¢å¼•æŸ¥è¯¢

**ä¿®æ­£è¦æ±‚ - ä¼ æ„Ÿå™¨æ™ºèƒ½ç´¢å¼•ç³»ç»Ÿ**ï¼š
```cpp
// æ–‡ä»¶: include/core_services/metadata/sensor_indexing_system.h
#pragma once

namespace oscean::core_services::metadata {

/**
 * @brief ä¼ æ„Ÿå™¨è”åˆç´¢å¼•ç®¡ç†å™¨ - å£°çº³ä¼ æ’­æŸå¤±ä¸“ç”¨
 */
class SensorIndexManager {
public:
    /**
     * @brief ä¼ æ„Ÿå™¨å…ƒæ•°æ®æ‰©å±•
     */
    struct SensorMetadataEntry : public StandardizedMetadataEntry {
        // å¹³å°ä¿¡æ¯
        std::string platformId;           // å¹³å°ID (èˆ¹èˆ¶ã€æ½œå™¨ã€æµ®æ ‡ç­‰)
        std::string platformType;         // å¹³å°ç±»å‹
        std::string platformName;         // å¹³å°åç§°
        
        // ä¼ æ„Ÿå™¨ä¿¡æ¯
        std::string sensorId;             // ä¼ æ„Ÿå™¨ID
        std::string sensorType;           // ä¼ æ„Ÿå™¨ç±»å‹ (å£°çº³ã€æ°´å¬å™¨ç­‰)
        std::string sensorModel;          // ä¼ æ„Ÿå™¨å‹å·
        std::string manufacturerName;     // åˆ¶é€ å•†
        
        // å·¥ä½œæ¨¡å¼ä¿¡æ¯
        std::string workingModeId;        // å·¥ä½œæ¨¡å¼ID
        std::string workingModeName;      // å·¥ä½œæ¨¡å¼åç§°
        std::string operationFrequency;   // å·¥ä½œé¢‘ç‡
        std::string beamPattern;          // æ³¢æŸå›¾æ¡ˆ
        double transmitPower;             // å‘å°„åŠŸç‡
        double receiverSensitivity;       // æ¥æ”¶çµæ•åº¦
        
        // éƒ¨ç½²ä¿¡æ¯
        common_utils::time::TimeRange deploymentPeriod; // éƒ¨ç½²æ—¶é—´æ®µ
        double deploymentDepth;           // éƒ¨ç½²æ·±åº¦
        std::string deploymentStatus;     // éƒ¨ç½²çŠ¶æ€ (active, maintenance, retired)
        
        // ä¼ æ’­æŸå¤±ä¸“ç”¨
        double maxPropagationRange;       // æœ€å¤§ä¼ æ’­è·ç¦»
        std::vector<double> frequencyBands; // é¢‘å¸¦èŒƒå›´
        std::string propagationModel;     // ä¼ æ’­æ¨¡å‹ç±»å‹
        std::map<std::string, double> environmentalConditions; // ç¯å¢ƒæ¡ä»¶
    };
    
    /**
     * @brief å¤šç»´è”åˆç´¢å¼•ç»“æ„
     */
    struct MultiDimensionalSensorIndex {
        // å¹³å°ç´¢å¼•
        std::map<std::string, std::vector<std::string>> platformIdIndex_;
        std::map<std::string, std::vector<std::string>> platformTypeIndex_;
        
        // ä¼ æ„Ÿå™¨ç´¢å¼•
        std::map<std::string, std::vector<std::string>> sensorIdIndex_;
        std::map<std::string, std::vector<std::string>> sensorTypeIndex_;
        std::map<std::string, std::vector<std::string>> sensorModelIndex_;
        
        // å·¥ä½œæ¨¡å¼ç´¢å¼•
        std::map<std::string, std::vector<std::string>> workingModeIdIndex_;
        std::map<std::string, std::vector<std::string>> operationFrequencyIndex_;
        
        // æ—¶ç©ºè”åˆç´¢å¼•
        std::map<std::string, 
                 std::map<common_utils::time::TimeRange, 
                          std::map<std::pair<double,double>, std::vector<std::string>>>> 
                 spatioTemporalIndex_;
        
        // å¤åˆç´¢å¼• (å¹³å°+ä¼ æ„Ÿå™¨+æ¨¡å¼+æ—¶é—´)
        std::map<std::tuple<std::string, std::string, std::string, int64_t>, 
                 std::vector<std::string>> compositeIndex_;
    };
    
    /**
     * @brief ä¼ æ„Ÿå™¨è”åˆæŸ¥è¯¢æ¥å£
     */
    boost::future<AsyncResult<std::vector<SensorMetadataEntry>>> queryBySensorCriteriaAsync(
        const SensorQueryCriteria& criteria
    );
    
    /**
     * @brief å¹³å°ä¼ æ„Ÿå™¨ç»„åˆæŸ¥è¯¢
     */
    boost::future<AsyncResult<std::vector<SensorMetadataEntry>>> queryByPlatformSensorComboAsync(
        const std::vector<std::string>& platformIds,
        const std::vector<std::string>& sensorIds,
        const std::vector<std::string>& workingModeIds,
        const common_utils::time::TimeRange& timeRange
    );
    
    /**
     * @brief ä¼ æ’­è¦†ç›–åˆ†ææŸ¥è¯¢
     */
    boost::future<AsyncResult<PropagationCoverageAnalysis>> analyzePropagationCoverageAsync(
        const std::string& platformId,
        const common_utils::time::TimeRange& analysisTimeRange,
        double targetRange
    );

private:
    MultiDimensionalSensorIndex sensorIndex_;
    std::shared_ptr<common_utils::async::IAsyncExecutor> asyncExecutor_;
};

/**
 * @brief ä¼ æ„Ÿå™¨æŸ¥è¯¢æ¡ä»¶
 */
struct SensorQueryCriteria {
    // åŸºç¡€æŸ¥è¯¢æ¡ä»¶
    std::optional<std::vector<std::string>> platformIds;
    std::optional<std::vector<std::string>> sensorIds;
    std::optional<std::vector<std::string>> workingModeIds;
    std::optional<common_utils::time::TimeRange> timeRange;
    
    // é«˜çº§æŸ¥è¯¢æ¡ä»¶
    std::optional<std::pair<double,double>> frequencyRange;
    std::optional<std::pair<double,double>> transmitPowerRange;
    std::optional<std::pair<double,double>> propagationRangeFilter;
    std::optional<std::string> deploymentStatus;
    
    // ç©ºé—´æŸ¥è¯¢æ¡ä»¶
    std::optional<BoundingBox> spatialExtent;
    std::optional<std::pair<double,double>> centerPoint; // ä¸­å¿ƒç‚¹åæ ‡
    std::optional<double> searchRadius;
    
    // æ’åºå’Œåˆ†é¡µ
    std::optional<std::string> sortBy; // "time", "platform", "sensor", "range"
    std::optional<bool> ascending;
    std::optional<size_t> limit;
    std::optional<size_t> offset;
};

/**
 * @brief ä¼ æ’­è¦†ç›–åˆ†æç»“æœ
 */
struct PropagationCoverageAnalysis {
    std::string platformId;
    common_utils::time::TimeRange analysisTimeRange;
    
    struct CoverageStatistics {
        double totalCoveredArea;          // æ€»è¦†ç›–é¢ç§¯
        double averagePropagationRange;   // å¹³å‡ä¼ æ’­è·ç¦»
        double maxPropagationRange;       // æœ€å¤§ä¼ æ’­è·ç¦»
        int totalMeasurements;            // æ€»æµ‹é‡æ¬¡æ•°
        std::map<std::string, double> frequencyRangeCoverage; // å„é¢‘å¸¦è¦†ç›–æƒ…å†µ
    } statistics;
    
    std::vector<std::pair<common_utils::time::CalendarTime, double>> timeSeriesRange;
    std::map<std::string, std::vector<double>> environmentalImpacts;
};

} // namespace oscean::core_services::metadata
```

### 4.3 **ä¼˜åŒ–åçš„å¤šåº“Schemaè®¾è®¡ - æ”¯æŒæ™ºèƒ½ç´¢å¼•**

```sql
-- å£°çº³ä¼ æ’­æŸå¤±æ•°æ®åº“ (æ‰©å±•ç‰ˆæœ¬)
CREATE TABLE sonar_propagation_metadata (
    id TEXT PRIMARY KEY,
    file_path TEXT NOT NULL,
    
    -- ä¸­å¿ƒåæ ‡ä¿¡æ¯
    center_longitude REAL NOT NULL,
    center_latitude REAL NOT NULL,
    center_depth REAL DEFAULT 0,
    
    -- å¹³å°ä¿¡æ¯
    platform_id TEXT NOT NULL,
    platform_type TEXT,
    platform_name TEXT,
    
    -- ä¼ æ„Ÿå™¨ä¿¡æ¯
    sensor_id TEXT NOT NULL,
    sensor_type TEXT,
    sensor_model TEXT,
    manufacturer_name TEXT,
    
    -- å·¥ä½œæ¨¡å¼ä¿¡æ¯
    working_mode_id TEXT NOT NULL,
    working_mode_name TEXT,
    operation_frequency REAL,
    beam_pattern TEXT,
    transmit_power REAL,
    receiver_sensitivity REAL,
    
    -- éƒ¨ç½²ä¿¡æ¯
    deployment_start INTEGER,
    deployment_end INTEGER,
    deployment_depth REAL,
    deployment_status TEXT DEFAULT 'active',
    
    -- ä¼ æ’­æŸå¤±ä¸“ç”¨å­—æ®µ
    max_propagation_range REAL,
    frequency_bands TEXT, -- JSONæ•°ç»„
    propagation_model TEXT,
    environmental_conditions TEXT, -- JSONå¯¹è±¡
    
    -- æ—¶é—´å’Œç©ºé—´ä¿¡æ¯
    time_coverage_start INTEGER,
    time_coverage_end INTEGER,
    spatial_resolution_radial REAL,
    spatial_resolution_angular REAL,
    
    UNIQUE(file_path)
);

-- ä¼ æ„Ÿå™¨è”åˆç´¢å¼• (å¤šç»´å¤åˆç´¢å¼•)
CREATE INDEX idx_platform_sensor_mode_time ON sonar_propagation_metadata(
    platform_id, sensor_id, working_mode_id, time_coverage_start
);

CREATE INDEX idx_sensor_frequency_range ON sonar_propagation_metadata(
    sensor_id, operation_frequency, max_propagation_range
);

CREATE INDEX idx_spatial_temporal_coverage ON sonar_propagation_metadata(
    center_longitude, center_latitude, time_coverage_start, time_coverage_end
);

CREATE INDEX idx_deployment_status_period ON sonar_propagation_metadata(
    deployment_status, deployment_start, deployment_end
);

-- å››ç»´æ™ºèƒ½ç´¢å¼•æ”¯æŒè¡¨
CREATE TABLE intelligent_spatial_index (
    grid_level INTEGER,
    grid_x INTEGER,
    grid_y INTEGER,
    file_ids TEXT, -- JSONæ•°ç»„
    resolution_category TEXT,
    data_density REAL,
    PRIMARY KEY(grid_level, grid_x, grid_y)
);

CREATE TABLE intelligent_temporal_index (
    year INTEGER,
    month INTEGER,
    day INTEGER,
    time_resolution_seconds INTEGER,
    time_quality_score REAL,
    file_ids TEXT, -- JSONæ•°ç»„
    PRIMARY KEY(year, month, day, time_resolution_seconds)
);

CREATE TABLE intelligent_variable_index (
    variable_type TEXT,
    standard_name TEXT,
    units TEXT,
    file_ids TEXT, -- JSONæ•°ç»„
    frequency_count INTEGER,
    PRIMARY KEY(variable_type, standard_name, units)
);

CREATE TABLE intelligent_dimensional_index (
    dimension_count INTEGER,
    grid_width INTEGER,
    grid_height INTEGER,
    depth_levels INTEGER,
    file_ids TEXT, -- JSONæ•°ç»„
    data_density_category TEXT,
    PRIMARY KEY(dimension_count, grid_width, grid_height, depth_levels)
);
```

## ğŸ¯ **ç¬¬äº”éƒ¨åˆ†ï¼šå®Œæ•´é‡æ„æ€»ç»“ä¸å½’çº³**

### ğŸ“‹ **5.1 å…ƒæ•°æ®æ¨¡å—åŠŸèƒ½åˆ—è¡¨ (å®Œæ•´ç‰ˆ)**

#### **ğŸ”§ æ ¸å¿ƒåŠŸèƒ½æ¨¡å—**
1. **å¤šåº“å…ƒæ•°æ®ç®¡ç†**
   - æµ·æ´‹ç¯å¢ƒåŠ¨æ€æ•°æ®åº“ç®¡ç†
   - åœ°å½¢åº•è´¨æ•°æ®åº“ç®¡ç†  
   - è¾¹ç•Œçº¿æ•°æ®åº“ç®¡ç†
   - å£°çº³ä¼ æ’­æŸå¤±æ•°æ®åº“ç®¡ç†

2. **æ™ºèƒ½ç´¢å¼•ç³»ç»Ÿ**
   - å››ç»´æ™ºèƒ½ç´¢å¼• (ç©ºé—´ã€æ—¶é—´ã€ç»´åº¦ã€å˜é‡)
   - ä¼ æ„Ÿå™¨è”åˆç´¢å¼• (å¹³å°+ä¼ æ„Ÿå™¨+æ¨¡å¼+æ—¶é—´)
   - R-Treeç©ºé—´ç´¢å¼•ä¼˜åŒ–
   - å¤šç²’åº¦æ—¶é—´ç´¢å¼•

3. **å…ƒæ•°æ®ç¼–æ’æœåŠ¡**
   - è·¨æœåŠ¡åè°ƒ (Data Access + CRS + Metadata)
   - æ ‡å‡†åŒ–å…ƒæ•°æ®è½¬æ¢
   - å¼‚æ­¥æµå¼å¤„ç†
   - æ‰¹é‡ç›®å½•æ‰«æ

4. **æŸ¥è¯¢åˆ†ææœåŠ¡**
   - è·¨åº“è”åˆæŸ¥è¯¢
   - ç©ºé—´åˆ†è¾¨ç‡æ™ºèƒ½æŸ¥è¯¢
   - ä¼ æ„Ÿå™¨ç»„åˆæŸ¥è¯¢
   - ä¼ æ’­è¦†ç›–åˆ†æ
   - æ•°æ®ç»Ÿè®¡åˆ†æ

#### **ğŸ¯ ä¸“ç”¨åŠŸèƒ½æ¨¡å—**
5. **å£°çº³æ•°æ®ä¸“ç”¨åŠŸèƒ½**
   - åæ ‡ä¸­å¿ƒç´¢å¼•æŸ¥è¯¢
   - å¹³å°ä¼ æ„Ÿå™¨è”åˆæŸ¥è¯¢
   - å·¥ä½œæ¨¡å¼å…³è”åˆ†æ
   - ä¼ æ’­èŒƒå›´è¦†ç›–åˆ†æ

6. **æ•°æ®è´¨é‡è¯„ä¼°**
   - æ—¶é—´è´¨é‡è‡ªåŠ¨è¯„åˆ†
   - ç©ºé—´è¦†ç›–å®Œæ•´æ€§æ£€æŸ¥
   - å˜é‡æ ‡å‡†ç¬¦åˆæ€§éªŒè¯
   - æ•°æ®å¯†åº¦åˆ†æ

7. **ç»Ÿè®¡æŠ¥å‘Šç”Ÿæˆ**
   - å…¨å±€æ•°æ®è¦†ç›–ç»Ÿè®¡
   - å˜é‡åˆ†å¸ƒé¢‘ç‡åˆ†æ
   - æ—¶é—´åˆ†è¾¨ç‡åˆ†å¸ƒç»Ÿè®¡
   - ä¼ æ„Ÿå™¨æ´»è·ƒåº¦æŠ¥å‘Š

### ğŸ“‹ **5.2 é‡æ„å†…å®¹åˆ—è¡¨ (è¯¦ç»†ç‰ˆ)**

#### **ğŸ”¥ æ¶æ„çº§é‡æ„**
1. **æœåŠ¡èŒè´£é‡æ–°å®šä¹‰**
   - âœ… ç§»é™¤æ–‡ä»¶æ ¼å¼è§£æèŒè´£ â†’ å§”æ‰˜ç»™Data Access Service
   - âœ… ç§»é™¤åæ ‡è½¬æ¢èŒè´£ â†’ å§”æ‰˜ç»™CRS Service  
   - âœ… ä¸“æ³¨å…ƒä¿¡æ¯å­˜å‚¨ã€æ£€ç´¢ã€æŸ¥è¯¢ã€åˆ†æ

2. **å¤šåº“æ¶æ„å®ç°**
   - âœ… `MultiDatabaseMetadataManager` å®ç°
   - âœ… æ•°æ®ç±»å‹è‡ªåŠ¨è¯†åˆ«ä¸è·¯ç”±
   - âœ… è·¨åº“äº‹åŠ¡ç®¡ç†
   - âœ… æ•°æ®åº“è¿æ¥æ± ä¼˜åŒ–

3. **æ™ºèƒ½ç´¢å¼•æ¶æ„**
   - âœ… `IntelligentIndexManager` å››ç»´ç´¢å¼•
   - âœ… `SensorIndexManager` ä¼ æ„Ÿå™¨è”åˆç´¢å¼•
   - âœ… è‡ªåŠ¨ç´¢å¼•æ„å»ºä¸ç»´æŠ¤
   - âœ… ç´¢å¼•æ€§èƒ½ç›‘æ§

#### **ğŸ”§ æ¥å£çº§é‡æ„**
4. **ç»Ÿä¸€å¼‚æ­¥æ¥å£ (å¼ºåˆ¶BOOST::FUTURE)**
   - âœ… å®Œå…¨ç§»é™¤ `std::future` ä½¿ç”¨
   - âœ… ç»Ÿä¸€ä½¿ç”¨ `boost::future<AsyncResult<T>>`
   - âœ… æµå¼å¤„ç†æ¥å£ `boost::future<StreamingResult<T>>`
   - âœ… é”™è¯¯å¤„ç†ç»Ÿä¸€åŒ–

5. **å·¥å‚æ¨¡å¼å®ç°**
   - âœ… `UnifiedMetadataServiceFactory` ä¸»å·¥å‚
   - âœ… `MultiDatabaseManagerFactory` æ•°æ®åº“å·¥å‚
   - âœ… `IntelligentIndexFactory` ç´¢å¼•å·¥å‚
   - âœ… ä¾èµ–æ³¨å…¥æ”¯æŒ

6. **ä¸å…¶ä»–æœåŠ¡æ¥å£é€‚é…**
   - âœ… Data Access Serviceæ¥å£å ä½ (å¾…å…¶é‡æ„å®Œæˆ)
   - âœ… CRS Serviceå®Œæ•´é›†æˆ (å·²é‡æ„)
   - âœ… Common Utilitieså®Œæ•´é›†æˆ (å·²é‡æ„)

#### **ğŸ—„ï¸ æ•°æ®å±‚é‡æ„**
7. **æ•°æ®åº“Schemaé‡æ–°è®¾è®¡**
   - âœ… å››ç§æ•°æ®ç±»å‹ä¸“ç”¨Schema
   - âœ… è§„èŒƒåŒ–å˜é‡å­˜å‚¨è®¾è®¡
   - âœ… æ™ºèƒ½ç´¢å¼•è¡¨ç»“æ„
   - âœ… ä¼ æ„Ÿå™¨è”åˆç´¢å¼•ä¼˜åŒ–

8. **å­˜å‚¨åç«¯ä¼˜åŒ–**
   - âœ… SQLiteå¤šåº“æ¨¡å¼æ”¯æŒ
   - âœ… è¿æ¥æ± ç®¡ç†
   - âœ… äº‹åŠ¡ä¼˜åŒ–
   - âœ… æ‰¹é‡æ“ä½œä¼˜åŒ–

### ğŸ“‹ **5.3 æ¥å£æ¨¡å¼ç»Ÿä¸€è§„èŒƒ**

#### **ğŸ”„ å¼‚æ­¥æ¥å£æ¨¡å¼ (å¼ºåˆ¶BOOST::FUTURE)**
```cpp
// âœ… æ ‡å‡†å¼‚æ­¥æ¥å£æ¨¡å¼
namespace oscean::core_services::metadata {

// åŸºç¡€å¼‚æ­¥ç»“æœç±»å‹
template<typename T>
using Future = boost::future<T>;

template<typename T>
using AsyncResult = common_utils::async::AsyncResult<T>;

template<typename T>
using StreamingResult = common_utils::async::StreamingResult<T>;

// æ‰€æœ‰æœåŠ¡æ¥å£å¿…é¡»éµå¾ªæ­¤æ¨¡å¼
class IUnifiedMetadataService {
    // âœ… å•ä¸€ç»“æœå¼‚æ­¥æ¥å£
    virtual Future<AsyncResult<std::string>> registerDataFileAsync(...) = 0;
    
    // âœ… æ‰¹é‡ç»“æœå¼‚æ­¥æ¥å£  
    virtual Future<AsyncResult<std::vector<T>>> queryMetadataAsync(...) = 0;
    
    // âœ… æµå¼ç»“æœå¼‚æ­¥æ¥å£
    virtual Future<StreamingResult<T>> processDirectoryAsync(...) = 0;
};

} // namespace oscean::core_services::metadata
```

#### **ğŸ­ å·¥å‚æ¨¡å¼å®ç°è§„èŒƒ**
```cpp
// âœ… ä¸»æœåŠ¡å·¥å‚
class UnifiedMetadataServiceFactory {
public:
    static std::unique_ptr<UnifiedMetadataServiceFactory> create(
        std::shared_ptr<common_utils::infrastructure::CommonServicesFactory> commonServices
    );
    
    Future<AsyncResult<std::shared_ptr<IUnifiedMetadataService>>> createServiceAsync(
        const MetadataServiceConfiguration& config
    );
    
    // ä¾èµ–æ³¨å…¥æ”¯æŒ
    void setDataAccessService(std::shared_ptr<IRawDataAccessService> service);
    void setCrsService(std::shared_ptr<ICrsService> service);
};

// âœ… å­æ¨¡å—å·¥å‚
class MultiDatabaseManagerFactory {
    static Future<AsyncResult<std::shared_ptr<MultiDatabaseMetadataManager>>> createAsync(
        const std::map<DataType, std::string>& databasePaths
    );
};

class IntelligentIndexFactory {
    static Future<AsyncResult<std::shared_ptr<IntelligentIndexManager>>> createAsync(
        std::shared_ptr<MultiDatabaseMetadataManager> databaseManager
    );
};
```

#### **ğŸ“ ä¸å…¶ä»–æœåŠ¡æ¥å£é€‚é…**

**âœ… ä¸CRS Serviceæ¥å£ (å·²é‡æ„å®Œæˆ)**
```cpp
// CRS Serviceå·²é‡æ„ï¼Œç›´æ¥ä½¿ç”¨boost::futureæ¥å£
std::shared_ptr<ICrsService> crsService_;

auto transformResult = crsService_->transformBoundingBoxAsync(
    fileMetadata.spatialCoverage, 
    targetCrs
);
```

**ğŸ”„ ä¸Data Access Serviceæ¥å£ (å ä½ä¿ç•™)**
```cpp
// Data Access Serviceå°šæœªé‡æ„ï¼Œæ¥å£å ä½
class DataAccessServiceAdapter {
public:
    // å ä½æ¥å£ - å¾…Data Access Serviceé‡æ„åæ›´æ–°
    Future<AsyncResult<FileMetadata>> extractFileMetadataAsync(
        const std::string& filePath
    ) {
        // ä¸´æ—¶é€‚é…é€»è¾‘ï¼Œè°ƒç”¨å½“å‰æ¥å£å¹¶è½¬æ¢ä¸ºboost::future
        auto currentResult = dataAccessService_->extractFileMetadataAsync(filePath);
        
        // è½¬æ¢é€»è¾‘ (ç®€åŒ–ç¤ºä¾‹)
        boost::promise<AsyncResult<FileMetadata>> promise;
        auto future = promise.get_future();
        
        // å¼‚æ­¥è½¬æ¢å½“å‰ç»“æœ
        asyncExecutor_->post([promise = std::move(promise), currentResult]() mutable {
            try {
                auto result = currentResult.get();
                if (result) {
                    promise.set_value(AsyncResult<FileMetadata>::success(*result));
                } else {
                    promise.set_value(AsyncResult<FileMetadata>::failure("File not found"));
                }
            } catch (const std::exception& e) {
                promise.set_value(AsyncResult<FileMetadata>::failure(e.what()));
            }
        });
        
        return future;
    }

private:
    std::shared_ptr<IRawDataAccessService> dataAccessService_; // å½“å‰æ¥å£
    std::shared_ptr<common_utils::async::IAsyncExecutor> asyncExecutor_;
};
```

**âœ… ä¸Common Utilitiesé›†æˆ (å·²é‡æ„å®Œæˆ)**
```cpp
// Common Utilitieså·²é‡æ„ï¼Œå…¨é¢é›†æˆ
std::shared_ptr<common_utils::async::IAsyncExecutor> asyncExecutor_;
std::shared_ptr<common_utils::logging::ILogger> logger_;
std::shared_ptr<common_utils::performance::IPerformanceMonitor> performanceMonitor_;
std::shared_ptr<common_utils::infrastructure::ICache<K,V>> cache_;
```

### ğŸ“‹ **5.4 å®æ–½ä¼˜å…ˆçº§ä¸æ—¶é—´å®‰æ’**

#### **Phase 1: æ ¸å¿ƒæ¶æ„é‡æ„ (2å‘¨)**
1. å®ç°å¤šåº“æ¶æ„ `MultiDatabaseMetadataManager`
2. å®ç°æœåŠ¡ç¼–æ’å™¨ `MetadataOrchestrator`  
3. åˆ›å»ºç»Ÿä¸€å·¥å‚ç³»ç»Ÿ
4. å¼ºåˆ¶ç»Ÿä¸€boost::futureæ¥å£

#### **Phase 2: æ™ºèƒ½ç´¢å¼•ç³»ç»Ÿ (2å‘¨)**  
5. å®ç°å››ç»´æ™ºèƒ½ç´¢å¼• `IntelligentIndexManager`
6. å®ç°ä¼ æ„Ÿå™¨è”åˆç´¢å¼• `SensorIndexManager`
7. æ•°æ®åº“Schemaé‡æ„å’Œè¿ç§»
8. ç´¢å¼•æ„å»ºå’Œç»´æŠ¤æœºåˆ¶

#### **Phase 3: æŸ¥è¯¢åˆ†æä¼˜åŒ– (1å‘¨)**
9. å®ç°è·¨åº“è”åˆæŸ¥è¯¢æ¥å£
10. å®ç°ç©ºé—´åˆ†è¾¨ç‡æ™ºèƒ½æŸ¥è¯¢
11. å®ç°ä¼ æ„Ÿå™¨ç»„åˆæŸ¥è¯¢
12. æ•°æ®ç»Ÿè®¡åˆ†æåŠŸèƒ½

#### **Phase 4: æµ‹è¯•ä¸æ€§èƒ½ä¼˜åŒ– (1å‘¨)**
13. å®Œæ•´çš„å•å…ƒæµ‹è¯•è¦†ç›–
14. è·¨æœåŠ¡é›†æˆæµ‹è¯•  
15. æ€§èƒ½åŸºå‡†æµ‹è¯•å’Œä¼˜åŒ–
16. æ–‡æ¡£å®Œå–„å’Œéƒ¨ç½²éªŒè¯

### ğŸ¯ **éªŒæ”¶æ ‡å‡†æ€»ç»“**

#### **æ¥å£ç»Ÿä¸€æ€§éªŒæ”¶**
- [ ] 100% ä½¿ç”¨ `boost::future` (0% std::future)
- [ ] 100% ä½¿ç”¨ `AsyncResult` é”™è¯¯å¤„ç†
- [ ] 100% å®ç°å·¥å‚æ¨¡å¼åˆ›å»º
- [ ] 100% é›†æˆCommon UtilitiesåŸºç¡€è®¾æ–½

#### **åŠŸèƒ½å®Œæ•´æ€§éªŒæ”¶**  
- [ ] æ”¯æŒå››ç§æ•°æ®ç±»å‹å¤šåº“å­˜å‚¨
- [ ] å®ç°å››ç»´æ™ºèƒ½ç´¢å¼•ç³»ç»Ÿ
- [ ] æ”¯æŒä¼ æ„Ÿå™¨è”åˆç´¢å¼•æŸ¥è¯¢
- [ ] å®ç°è‡ªåŠ¨æ•°æ®ç»Ÿè®¡åˆ†æ

#### **æ€§èƒ½ç›®æ ‡éªŒæ”¶**
- [ ] è·¨åº“æŸ¥è¯¢å“åº”æ—¶é—´ < 200ms
- [ ] ç©ºé—´åˆ†è¾¨ç‡æŸ¥è¯¢å“åº”æ—¶é—´ < 100ms  
- [ ] ä¼ æ„Ÿå™¨è”åˆæŸ¥è¯¢å“åº”æ—¶é—´ < 150ms
- [ ] æ”¯æŒTBçº§æ•°æ®æµå¼å¤„ç†

#### **æ¶æ„æ¸…æ™°æ€§éªŒæ”¶**
- [ ] ä¸Data Access ServiceèŒè´£å®Œå…¨åˆ†ç¦»
- [ ] ä¸CRS Serviceåä½œæ— ç¼é›†æˆ
- [ ] æœåŠ¡é—´æ¥å£è°ƒç”¨é“¾è·¯æ¸…æ™°
- [ ] æ— é‡å¤åŠŸèƒ½å®ç°

---

## ğŸ“ **æœ€ç»ˆç»“è®º**

å…ƒæ•°æ®æ¨¡å—éœ€è¦è¿›è¡Œ**å…¨é¢æ¶æ„é‡æ„**ï¼Œå®ç°ï¼š

1. **èŒè´£è¾¹ç•Œé‡æ–°å®šä¹‰** - ä¸“æ³¨å…ƒä¿¡æ¯ç®¡ç†ï¼Œä¸é‡å¤å…¶ä»–æœåŠ¡åŠŸèƒ½
2. **å¤šåº“æ¶æ„æ”¯æŒ** - å››ç§æ•°æ®ç±»å‹åˆ†åº“å­˜å‚¨å’Œç®¡ç†  
3. **æ™ºèƒ½ç´¢å¼•ç³»ç»Ÿ** - å››ç»´ç´¢å¼•+ä¼ æ„Ÿå™¨è”åˆç´¢å¼•
4. **å¼ºåˆ¶æ¥å£ç»Ÿä¸€** - 100% boost::future + å·¥å‚æ¨¡å¼
5. **è·¨æœåŠ¡åä½œä¼˜åŒ–** - ç¼–æ’å™¨æ¨¡å¼åè°ƒä¸‰ä¸ªæœåŠ¡

è¿™å°†å½»åº•è§£å†³èŒè´£é‡å ã€åŠŸèƒ½ç¼ºå¤±ã€æ¥å£ä¸ä¸€è‡´ç­‰é—®é¢˜ï¼Œå»ºç«‹çœŸæ­£æ¨¡å—åŒ–ã€é«˜æ€§èƒ½ã€æ˜“æ‰©å±•çš„å…ƒæ•°æ®ç®¡ç†æ¶æ„ã€‚ 