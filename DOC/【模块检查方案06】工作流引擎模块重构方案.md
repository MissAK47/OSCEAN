# ã€æ¨¡å—æ£€æŸ¥æ–¹æ¡ˆ06ã€‘å·¥ä½œæµå¼•æ“æ¨¡å—é‡æ„æ–¹æ¡ˆ

## ğŸ“‹ 1. å…³é”®é—®é¢˜å‘ç°ï¼šboostå´©æºƒä¸æ•°æ®æµå¤„ç†é”™è¯¯

### 1.1 **âŒ é—®é¢˜ä¸€ï¼šboostå´©æºƒæ ¹æœ¬åŸå› **

#### **å‘ç°çš„ç¬¦å·å†²çªå’Œæ··ç”¨é—®é¢˜**
```cpp
// âŒ æ–‡ä»¶: workflow_engine.h:3-17
// å®šä¹‰boostå®ä½†å®é™…ä½¿ç”¨std::futureï¼Œé€ æˆç¬¦å·å†²çª
#ifndef BOOST_THREAD_PROVIDES_FUTURE
#define BOOST_THREAD_PROVIDES_FUTURE
#endif
// ... æ›´å¤šboostå®å®šä¹‰

#include <boost/thread/future.hpp>  // å¼•å…¥boostä½†ä¸ä½¿ç”¨

// âŒ ä½†å®é™…æ¥å£ä½¿ç”¨std::future
std::future<WorkflowContext> submitWorkflow(...);  // åº”è¯¥æ˜¯boost::future
```

#### **å´©æºƒçš„æŠ€æœ¯åŸå› **
1. **ç¬¦å·å†²çª**ï¼šboostå®å®šä¹‰å½±å“std::futureçš„ç¼–è¯‘
2. **å†…å­˜ç®¡ç†å†²çª**ï¼šboostå’Œstdçš„futureå†…å­˜æ¨¡å‹ä¸å…¼å®¹
3. **çº¿ç¨‹è°ƒåº¦å†²çª**ï¼šboost::threadä¸std::threadæ··ç”¨å¯¼è‡´æ­»é”

### 1.2 **âŒ é—®é¢˜äºŒï¼šæ•°æ®ç®¡ç†å·¥ä½œæµå¤„ç†ä¸¥é‡é”™è¯¯**

#### **æ— æ³•æ§åˆ¶çš„å¹¶å‘çˆ†ç‚¸**
```cpp
// âŒ æ–‡ä»¶: data_management_workflow.cpp:219-250
std::vector<std::future<...>> futures;

for (const auto& filePath : discoveryResult.candidateFiles) {  // å¯èƒ½æ•°åƒä¸ªæ–‡ä»¶
    futures.emplace_back(std::async(std::launch::async, [...]() {  // æ— é™åˆ¶åˆ›å»ºçº¿ç¨‹
        return std::make_pair(filePath, this->validateFile(filePath));
    }));
    
    if (futures.size() >= config_.maxConcurrentFiles) {  // ä¾‹å¦‚>=10
        for (auto& future : futures) {
            auto result = future.get();  // âŒ åŒæ­¥ç­‰å¾…ç ´åå¹¶å‘æ€§
        }
        futures.clear();  // âŒ ä¸¢å¤±ç»“æœ
    }
}
```

**âŒ ä¸¥é‡åæœ**ï¼š
- å¤„ç†1000ä¸ªæ–‡ä»¶æ—¶åˆ›å»º1000ä¸ªçº¿ç¨‹ï¼Œç³»ç»Ÿå´©æºƒ
- å†…å­˜æ— é™åˆ¶å¢é•¿
- æ— æ³•æ­£ç¡®æ”¶é›†å’Œåˆå¹¶å¤„ç†ç»“æœ
- æ²¡æœ‰é”™è¯¯æ¢å¤æœºåˆ¶

### 1.3 **âŒ é—®é¢˜ä¸‰ï¼šä¾èµ–æœåŠ¡è°ƒç”¨æ–¹å¼é”™è¯¯**

#### **ç›´æ¥è°ƒç”¨é€ æˆé˜»å¡**
```cpp
// âŒ é”™è¯¯çš„æœåŠ¡è°ƒç”¨æ–¹å¼
auto metadata = dataAccessService_->getFileMetadata(filePath);  // é˜»å¡è°ƒç”¨
if (!metadata.has_value()) {
    // å¤„ç†å¤±è´¥
}
```

**âŒ é—®é¢˜**ï¼šæ²¡æœ‰ä½¿ç”¨æœåŠ¡çš„å¼‚æ­¥æ¥å£ï¼Œé€ æˆå·¥ä½œæµçº¿ç¨‹é˜»å¡ã€‚

## ğŸ¯ 2. é‡æ„ç›®æ ‡ï¼šå½»åº•è§£å†³boostå…¼å®¹æ€§ä¸å·¥ä½œæµæ­£ç¡®æ€§

### 2.1 **æ ¸å¿ƒé‡æ„åŸåˆ™**
1. **å½»åº•æ¶ˆé™¤boost/stdæ··ç”¨**ï¼šè¦ä¹ˆå…¨ç”¨boostï¼Œè¦ä¹ˆå…¨ç”¨std
2. **æ­£ç¡®å®ç°å¹¶å‘æ§åˆ¶**ï¼šä½¿ç”¨çº¿ç¨‹æ± è€Œéæ— é™åˆ¶åˆ›å»ºçº¿ç¨‹
3. **å¼‚æ­¥æœåŠ¡è°ƒç”¨**ï¼šæ­£ç¡®ä½¿ç”¨æ ¸å¿ƒæœåŠ¡çš„å¼‚æ­¥æ¥å£
4. **å®Œæ•´é”™è¯¯å¤„ç†**ï¼šå¤„ç†æ‰€æœ‰å¯èƒ½çš„å¼‚å¸¸å’Œé”™è¯¯åœºæ™¯
5. **èµ„æºç®¡ç†**ï¼šç¡®ä¿å†…å­˜å’Œæ–‡ä»¶å¥æŸ„æ­£ç¡®é‡Šæ”¾

### 2.2 **è§£å†³æ–¹æ¡ˆAï¼šå®Œå…¨ä½¿ç”¨stdï¼ˆæ¨èï¼‰**
åŸºäºç¨³å®šæ€§è€ƒè™‘ï¼Œå»ºè®®å®Œå…¨ä½¿ç”¨std::futureï¼Œç§»é™¤æ‰€æœ‰boostä¾èµ–ã€‚

### 2.3 **è§£å†³æ–¹æ¡ˆBï¼šå®Œå…¨ä½¿ç”¨boostï¼ˆå¤‡é€‰ï¼‰**
å¦‚æœéœ€è¦boostçš„é«˜çº§ç‰¹æ€§ï¼Œåˆ™å½»åº•åˆ‡æ¢åˆ°boostå®ç°ã€‚

## ğŸ”§ 3. æ–¹æ¡ˆAï¼šå®Œå…¨stdå®ç°ï¼ˆæ¨èæ–¹æ¡ˆï¼‰

### 3.1 é˜¶æ®µä¸€ï¼šç§»é™¤boostä¾èµ–ä¸ä¿®æ­£æ¥å£

#### **3.1.1 å¤´æ–‡ä»¶æ¸…ç†**
```cpp
// æ–‡ä»¶: include/workflow_engine/workflow_engine.h

#pragma once

// âœ… ç§»é™¤æ‰€æœ‰boostç›¸å…³å†…å®¹
#include "workflow_types.h"
#include "workflow_base.h"
#include <string>
#include <memory>
#include <map>
#include <functional>
#include <future>       // âœ… åªä½¿ç”¨std::future
#include <queue>
#include <mutex>
#include <shared_mutex>
#include <condition_variable>
#include <thread>
#include <atomic>

namespace workflow_engine {

/**
 * @brief å·¥ä½œæµå·¥å‚å‡½æ•°ç±»å‹
 */
using WorkflowFactory = std::function<std::unique_ptr<WorkflowBase>()>;

/**
 * @class WorkflowEngine
 * @brief é€šç”¨å·¥ä½œæµå¼•æ“ï¼ˆçº¯stdå®ç°ï¼‰
 */
class WorkflowEngine {
public:
    explicit WorkflowEngine(const WorkflowEngineConfig& config = WorkflowEngineConfig{});
    ~WorkflowEngine();

    bool start();
    void stop();
    
    bool registerWorkflow(const std::string& workflowType, WorkflowFactory factory);
    bool unregisterWorkflow(const std::string& workflowType);

    /**
     * @brief æäº¤å·¥ä½œæµæ‰§è¡Œ
     * @param workflowType å·¥ä½œæµç±»å‹
     * @param context å·¥ä½œæµä¸Šä¸‹æ–‡
     * @return å·¥ä½œæµæ‰§è¡Œçš„std::futureå¯¹è±¡
     */
    std::future<WorkflowContext> submitWorkflow(const std::string& workflowType, 
                                               WorkflowContext context);

    /**
     * @brief å¼‚æ­¥æ‰§è¡Œå·¥ä½œæµ
     * @param workflowType å·¥ä½œæµç±»å‹
     * @param context å·¥ä½œæµä¸Šä¸‹æ–‡
     * @param callback å®Œæˆå›è°ƒå‡½æ•°
     * @return å·¥ä½œæµID
     */
    std::string executeWorkflowAsync(const std::string& workflowType,
                                   WorkflowContext context,
                                   std::function<void(const WorkflowContext&)> callback = nullptr);

    WorkflowContext executeWorkflowSync(const std::string& workflowType, 
                                      WorkflowContext context);

    bool cancelWorkflow(const std::string& workflowId);
    std::optional<WorkflowContext> getWorkflowStatus(const std::string& workflowId);
    std::vector<WorkflowContext> getRunningWorkflows();
    
    struct EngineStatistics {
        int totalWorkflowsExecuted = 0;
        int currentRunningWorkflows = 0;
        int queuedWorkflows = 0;
        int successfulWorkflows = 0;
        int failedWorkflows = 0;
        int cancelledWorkflows = 0;
        double averageExecutionTime = 0.0;
    };
    EngineStatistics getStatistics() const;

    void setGlobalProgressCallback(ProgressCallback callback);
    bool isWorkflowRegistered(const std::string& workflowType) const;
    std::vector<std::string> getRegisteredWorkflowTypes() const;
    void cleanupCompletedWorkflows(std::chrono::minutes maxAge = std::chrono::minutes{60});

private:
    struct WorkflowTask {
        std::string workflowId;
        std::string workflowType;
        WorkflowContext context;
        std::promise<WorkflowContext> promise;                           // âœ… std::promise
        std::function<void(const WorkflowContext&)> callback;
        std::chrono::system_clock::time_point submitTime;
        std::unique_ptr<WorkflowBase> workflow;
    };

    // é…ç½®å’ŒçŠ¶æ€
    WorkflowEngineConfig config_;
    std::atomic<bool> running_{false};
    
    // å·¥ä½œæµå·¥å‚
    std::map<std::string, WorkflowFactory> workflowFactories_;
    mutable std::shared_mutex factoriesMutex_;
    
    // ä»»åŠ¡é˜Ÿåˆ—å’Œçº¿ç¨‹ç®¡ç†
    std::queue<std::unique_ptr<WorkflowTask>> taskQueue_;
    std::mutex queueMutex_;
    std::condition_variable queueCondition_;
    
    std::vector<std::thread> workerThreads_;                            // âœ… std::thread
    
    // è¿è¡Œä¸­çš„å·¥ä½œæµ
    std::map<std::string, std::unique_ptr<WorkflowTask>> runningWorkflows_;
    std::mutex runningMutex_;
    
    // å·²å®Œæˆçš„å·¥ä½œæµ
    std::map<std::string, WorkflowContext> completedWorkflows_;
    mutable std::shared_mutex completedMutex_;
    
    // ç»Ÿè®¡ä¿¡æ¯
    mutable std::mutex statisticsMutex_;
    EngineStatistics statistics_;
    
    // å…¨å±€å›è°ƒ
    ProgressCallback globalProgressCallback_;
    
    void workerThread();
    void executeTask(std::unique_ptr<WorkflowTask> task);
    std::string generateWorkflowId();
    void updateStatistics(WorkflowStatus result, std::chrono::milliseconds duration);
    void cleanupWorkerThreads();
};

} // namespace workflow_engine
```

#### **3.1.2 CMakeLists.txtä¿®æ­£**
```cmake
# æ–‡ä»¶: CMakeLists.txt

cmake_minimum_required(VERSION 3.16)
project(WorkflowEngine VERSION 3.0.0 LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_EXTENSIONS OFF)

# ç¼–è¯‘å™¨ç‰¹å®šè®¾ç½®
if(MSVC)
    add_compile_options(/W4 /EHsc)
    add_compile_definitions(_CRT_SECURE_NO_WARNINGS)
else()
    add_compile_options(-Wall -Wextra -Wpedantic)
endif()

# è®¾ç½®åŒ…å«ç›®å½•
include_directories(
    ${CMAKE_CURRENT_SOURCE_DIR}/include
    ${CMAKE_CURRENT_SOURCE_DIR}/../core_service_interfaces/include
    ${CMAKE_CURRENT_SOURCE_DIR}/../common_utilities/include
    ${CMAKE_CURRENT_SOURCE_DIR}/../core_services_impl/metadata_service/include
    ${CMAKE_CURRENT_SOURCE_DIR}/../core_services_impl/data_access_service/include
    ${CMAKE_CURRENT_SOURCE_DIR}/../core_services_impl/crs_service/include
)

# âœ… åªæŸ¥æ‰¾çº¿ç¨‹åº“ï¼Œç§»é™¤boostä¾èµ–
find_package(Threads REQUIRED)

# æºæ–‡ä»¶
set(WORKFLOW_ENGINE_SOURCES
    src/workflow_types.cpp
    src/workflow_base.cpp
    src/workflow_engine.cpp
    src/data_management_workflow.cpp
)

# åˆ›å»ºé™æ€åº“
add_library(workflow_engine STATIC ${WORKFLOW_ENGINE_SOURCES})

# âœ… åªé“¾æ¥çº¿ç¨‹åº“
target_link_libraries(workflow_engine 
    PRIVATE 
    Threads::Threads
)

# æµ‹è¯•å¯æ‰§è¡Œæ–‡ä»¶ä¹Ÿç§»é™¤boostä¾èµ–
add_executable(workflow_test_existing tests/test_workflow_functionality.cpp)
target_link_libraries(workflow_test_existing 
    workflow_engine
    Threads::Threads
)

add_executable(workflow_integration_test tests/test_integration_full.cpp)
target_link_libraries(workflow_integration_test 
    workflow_engine
    Threads::Threads
)

add_executable(workflow_integration_with_services tests/test_integration_with_services.cpp)
target_link_libraries(workflow_integration_with_services 
    workflow_engine
    data_access_service
    crs_service
    Threads::Threads
)

add_executable(workflow_complete_integration tests/test_complete_integration.cpp)
target_link_libraries(workflow_complete_integration 
    workflow_engine
    data_access_service
    crs_service
    metadata_service
    Threads::Threads
)

# è®¾ç½®è¾“å‡ºç›®å½•
set_target_properties(workflow_engine PROPERTIES
    ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib
)

set_target_properties(workflow_test_existing PROPERTIES
    RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin
)

set_target_properties(workflow_integration_test PROPERTIES
    RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin
)

set_target_properties(workflow_integration_with_services PROPERTIES
    RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin
)

set_target_properties(workflow_complete_integration PROPERTIES
    RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin
)
```

### 3.2 é˜¶æ®µäºŒï¼šæ•°æ®ç®¡ç†å·¥ä½œæµæ­£ç¡®å¹¶å‘å®ç°

#### **3.2.1 çº¿ç¨‹æ± ç®¡æ§çš„å¹¶å‘å¤„ç†**
```cpp
// æ–‡ä»¶: src/data_management_workflow.cpp

#include "workflow_engine/workflows/data_management_workflow.h"
#include <iostream>
#include <filesystem>
#include <fstream>
#include <algorithm>
#include <future>         // âœ… åªä½¿ç”¨std
#include <chrono>
#include <regex>
#include <iomanip>
#include <sstream>
#include <thread>

namespace workflow_engine {
namespace workflows {

DataManagementWorkflow::DataManagementWorkflow(const DataManagementWorkflowConfig& config)
    : WorkflowBase("DataManagement"), config_(config) {
}

// âœ… æ­£ç¡®çš„å¼‚æ­¥æ•°æ®éªŒè¯å®ç°
WorkflowResult DataManagementWorkflow::executeDataValidation(WorkflowContext& context) {
    try {
        auto discoveryIt = context.results.find("dataDiscoveryResult");
        if (discoveryIt == context.results.end()) {
            addError(context, "æœªæ‰¾åˆ°æ•°æ®å‘ç°ç»“æœ");
            return WorkflowResult::Failed;
        }
        
        auto discoveryResult = std::any_cast<DataDiscoveryResult>(discoveryIt->second);
        
        DataValidationResult result;
        result.totalFilesChecked = discoveryResult.candidateFiles.size();
        
        addLog(context, "INFO", "å¼€å§‹éªŒè¯ " + std::to_string(result.totalFilesChecked) + " ä¸ªæ–‡ä»¶");
        
        // âœ… ä½¿ç”¨å—æ§çš„å¹¶å‘å¤„ç†
        if (executeDataValidationConcurrent(discoveryResult.candidateFiles, result, context) 
            != WorkflowResult::Success) {
            return WorkflowResult::Failed;
        }
        
        context.results["dataValidationResult"] = result;
        
        addLog(context, "INFO", "æ•°æ®éªŒè¯å®Œæˆ: " + 
               std::to_string(result.validFilesCount) + "/" + 
               std::to_string(result.totalFilesChecked) + " æ–‡ä»¶æœ‰æ•ˆ");
        
        return WorkflowResult::Success;
        
    } catch (const std::exception& e) {
        addError(context, "æ•°æ®éªŒè¯å¤±è´¥: " + std::string(e.what()));
        return WorkflowResult::Failed;
    }
}

WorkflowResult DataManagementWorkflow::executeDataValidationConcurrent(
    const std::vector<std::string>& filePaths,
    DataValidationResult& result,
    WorkflowContext& context) {
    
    const size_t maxConcurrent = config_.maxConcurrentFiles;
    const size_t totalFiles = filePaths.size();
    
    // âœ… å—æ§å¹¶å‘ï¼šåˆ†æ‰¹å¤„ç†
    for (size_t startIdx = 0; startIdx < totalFiles; startIdx += maxConcurrent) {
        if (shouldCancel(context)) {
            addWarning(context, "éªŒè¯è¿‡ç¨‹è¢«å–æ¶ˆ");
            return WorkflowResult::Failed;
        }
        
        size_t endIdx = std::min(startIdx + maxConcurrent, totalFiles);
        size_t batchSize = endIdx - startIdx;
        
        addLog(context, "INFO", "å¤„ç†æ‰¹æ¬¡ " + std::to_string(startIdx / maxConcurrent + 1) + 
               ", æ–‡ä»¶ " + std::to_string(startIdx + 1) + "-" + std::to_string(endIdx) + 
               "/" + std::to_string(totalFiles));
        
        // âœ… åˆ›å»ºå½“å‰æ‰¹æ¬¡çš„futures
        std::vector<std::future<std::pair<std::string, std::pair<bool, std::string>>>> batchFutures;
        batchFutures.reserve(batchSize);
        
        // å¯åŠ¨å½“å‰æ‰¹æ¬¡çš„ä»»åŠ¡
        for (size_t i = startIdx; i < endIdx; ++i) {
            const std::string& filePath = filePaths[i];
            
            batchFutures.emplace_back(
                std::async(std::launch::async, [this, filePath]() -> std::pair<std::string, std::pair<bool, std::string>> {
                    try {
                        auto validation = validateFile(filePath);
                        return std::make_pair(filePath, validation);
                    } catch (const std::exception& e) {
                        return std::make_pair(filePath, std::make_pair(false, 
                                            "éªŒè¯å¼‚å¸¸: " + std::string(e.what())));
                    }
                })
            );
        }
        
        // âœ… ç­‰å¾…å½“å‰æ‰¹æ¬¡å®Œæˆå¹¶æ”¶é›†ç»“æœ
        for (auto& future : batchFutures) {
            try {
                auto [filePath, validation] = future.get();
                auto [isValid, errorMsg] = validation;
                
                if (isValid) {
                    result.validFiles.push_back(filePath);
                    result.validFilesCount++;
                } else {
                    result.invalidFiles.push_back(filePath);
                    result.validationErrors[filePath] = errorMsg;
                    addWarning(context, "æ–‡ä»¶éªŒè¯å¤±è´¥: " + filePath + " - " + errorMsg);
                }
                
            } catch (const std::exception& e) {
                addError(context, "è·å–éªŒè¯ç»“æœå¤±è´¥: " + std::string(e.what()));
                // ç»§ç»­å¤„ç†å…¶ä»–æ–‡ä»¶
            }
        }
        
        // âœ… æŠ¥å‘Šè¿›åº¦
        double progress = static_cast<double>(endIdx) / totalFiles * 100.0;
        updateProgress(context, WorkflowStage::DataValidation, 
                      "å·²éªŒè¯ " + std::to_string(endIdx) + "/" + std::to_string(totalFiles) + 
                      " æ–‡ä»¶ (" + std::to_string(static_cast<int>(progress)) + "%)");
    }
    
    return WorkflowResult::Success;
}

// âœ… æ­£ç¡®çš„å¼‚æ­¥å…ƒæ•°æ®æå–å®ç°
WorkflowResult DataManagementWorkflow::executeMetadataExtraction(WorkflowContext& context) {
    try {
        auto validationIt = context.results.find("dataValidationResult");
        if (validationIt == context.results.end()) {
            addError(context, "æœªæ‰¾åˆ°æ•°æ®éªŒè¯ç»“æœ");
            return WorkflowResult::Failed;
        }
        
        auto validationResult = std::any_cast<DataValidationResult>(validationIt->second);
        
        MetadataExtractionResult result;
        result.totalFilesProcessed = validationResult.validFiles.size();
        
        addLog(context, "INFO", "å¼€å§‹æå– " + std::to_string(result.totalFilesProcessed) + " ä¸ªæ–‡ä»¶çš„å…ƒæ•°æ®");
        
        // âœ… ä½¿ç”¨å¼‚æ­¥æœåŠ¡è°ƒç”¨è¿›è¡Œå…ƒæ•°æ®æå–
        if (executeMetadataExtractionAsync(validationResult.validFiles, result, context) 
            != WorkflowResult::Success) {
            return WorkflowResult::Failed;
        }
        
        context.results["metadataExtractionResult"] = result;
        
        addLog(context, "INFO", "å…ƒæ•°æ®æå–å®Œæˆ: " + 
               std::to_string(result.successfulExtractions) + "/" + 
               std::to_string(result.totalFilesProcessed) + " æ–‡ä»¶æˆåŠŸ");
        
        return WorkflowResult::Success;
        
    } catch (const std::exception& e) {
        addError(context, "å…ƒæ•°æ®æå–å¤±è´¥: " + std::string(e.what()));
        return WorkflowResult::Failed;
    }
}

WorkflowResult DataManagementWorkflow::executeMetadataExtractionAsync(
    const std::vector<std::string>& validFiles,
    MetadataExtractionResult& result,
    WorkflowContext& context) {
    
    const size_t maxConcurrent = config_.maxConcurrentFiles;
    const size_t totalFiles = validFiles.size();
    
    // âœ… å—æ§å¹¶å‘å…ƒæ•°æ®æå–
    for (size_t startIdx = 0; startIdx < totalFiles; startIdx += maxConcurrent) {
        if (shouldCancel(context)) {
            addWarning(context, "å…ƒæ•°æ®æå–è¢«å–æ¶ˆ");
            return WorkflowResult::Failed;
        }
        
        size_t endIdx = std::min(startIdx + maxConcurrent, totalFiles);
        size_t batchSize = endIdx - startIdx;
        
        addLog(context, "INFO", "æå–å…ƒæ•°æ®æ‰¹æ¬¡ " + std::to_string(startIdx / maxConcurrent + 1) + 
               ", æ–‡ä»¶ " + std::to_string(startIdx + 1) + "-" + std::to_string(endIdx) + 
               "/" + std::to_string(totalFiles));
        
        // âœ… åˆ›å»ºå½“å‰æ‰¹æ¬¡çš„å¼‚æ­¥å…ƒæ•°æ®æå–ä»»åŠ¡
        std::vector<std::future<std::pair<std::string, std::optional<FileMetadata>>>> metadataFutures;
        metadataFutures.reserve(batchSize);
        
        // å¯åŠ¨å½“å‰æ‰¹æ¬¡çš„å…ƒæ•°æ®æå–ä»»åŠ¡
        for (size_t i = startIdx; i < endIdx; ++i) {
            const std::string& filePath = validFiles[i];
            
            metadataFutures.emplace_back(
                std::async(std::launch::async, [this, filePath]() -> std::pair<std::string, std::optional<FileMetadata>> {
                    try {
                        // âœ… æ­£ç¡®ä½¿ç”¨æ•°æ®è®¿é—®æœåŠ¡çš„å¼‚æ­¥æ¥å£
                        if (dataAccessService_) {
                            auto metadataFuture = dataAccessService_->getFileMetadataAsync(filePath);
                            auto metadata = metadataFuture.get();  // ç­‰å¾…å¼‚æ­¥ç»“æœ
                            return std::make_pair(filePath, metadata);
                        } else {
                            // âœ… å¤‡ç”¨ï¼šç®€åŒ–å…ƒæ•°æ®æå–
                            auto simpleMetadata = extractSimpleMetadata(filePath);
                            return std::make_pair(filePath, simpleMetadata);
                        }
                    } catch (const std::exception& e) {
                        // è®°å½•é”™è¯¯ä½†ä¸ä¸­æ–­æ•´ä¸ªè¿‡ç¨‹
                        return std::make_pair(filePath, std::nullopt);
                    }
                })
            );
        }
        
        // âœ… ç­‰å¾…å½“å‰æ‰¹æ¬¡å®Œæˆå¹¶æ”¶é›†å…ƒæ•°æ®ç»“æœ
        for (auto& future : metadataFutures) {
            try {
                auto [filePath, metadata] = future.get();
                
                if (metadata.has_value()) {
                    result.extractedMetadata[filePath] = metadata.value();
                    result.successfulExtractions++;
                    
                    // å­˜å‚¨åˆ°å…ƒæ•°æ®æœåŠ¡ï¼ˆå¦‚æœå¯ç”¨ï¼‰
                    if (metadataService_) {
                        try {
                            auto storeResult = metadataService_->storeFileMetadataAsync(filePath, metadata.value());
                            storeResult.get();  // ç­‰å¾…å­˜å‚¨å®Œæˆ
                        } catch (const std::exception& e) {
                            addWarning(context, "å…ƒæ•°æ®å­˜å‚¨å¤±è´¥: " + filePath + " - " + std::string(e.what()));
                        }
                    }
                } else {
                    result.extractionErrors[filePath] = "å…ƒæ•°æ®æå–å¤±è´¥";
                    addWarning(context, "å…ƒæ•°æ®æå–å¤±è´¥: " + filePath);
                }
                
            } catch (const std::exception& e) {
                addError(context, "è·å–å…ƒæ•°æ®ç»“æœå¤±è´¥: " + std::string(e.what()));
            }
        }
        
        // âœ… æŠ¥å‘Šè¿›åº¦
        double progress = static_cast<double>(endIdx) / totalFiles * 100.0;
        updateProgress(context, WorkflowStage::MetadataExtraction, 
                      "å·²æå– " + std::to_string(endIdx) + "/" + std::to_string(totalFiles) + 
                      " æ–‡ä»¶å…ƒæ•°æ® (" + std::to_string(static_cast<int>(progress)) + "%)");
    }
    
    return WorkflowResult::Success;
}

// âœ… ç®€åŒ–å…ƒæ•°æ®æå–çš„å¤‡ç”¨å®ç°
std::optional<FileMetadata> DataManagementWorkflow::extractSimpleMetadata(const std::string& filePath) {
    try {
        FileMetadata metadata;
        metadata.filePath = filePath;
        metadata.fileName = std::filesystem::path(filePath).filename().string();
        metadata.fileSize = std::filesystem::file_size(filePath);
        metadata.format = detectFileFormat(filePath);
        metadata.lastModified = std::chrono::system_clock::now();
        
        // åŸºæœ¬åœ°ç†ä¿¡æ¯æå–ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰
        if (metadata.format == "NetCDF") {
            extractNetCDFBasicInfo(filePath, metadata);
        } else if (metadata.format == "GeoTIFF") {
            extractGeoTIFFBasicInfo(filePath, metadata);
        }
        
        return metadata;
        
    } catch (const std::exception& e) {
        return std::nullopt;
    }
}

void DataManagementWorkflow::extractNetCDFBasicInfo(const std::string& filePath, FileMetadata& metadata) {
    // âœ… ç®€åŒ–çš„NetCDFä¿¡æ¯æå–
    try {
        // è¿™é‡Œå¯ä»¥ä½¿ç”¨NetCDFåº“è¿›è¡ŒåŸºæœ¬ä¿¡æ¯è¯»å–
        // æš‚æ—¶ä½¿ç”¨æ–‡ä»¶åè§£æç­‰ç®€å•æ–¹æ³•
        
        auto filename = std::filesystem::path(filePath).filename().string();
        
        // å°è¯•ä»æ–‡ä»¶åè§£ææ—¥æœŸä¿¡æ¯
        std::regex datePattern(R"((\d{4})(\d{2})(\d{2}))");
        std::smatch match;
        if (std::regex_search(filename, match, datePattern)) {
            // è§£æåˆ°æ—¥æœŸä¿¡æ¯
            metadata.temporalRange.startTime = std::chrono::system_clock::now();  // ç®€åŒ–å®ç°
            metadata.temporalRange.endTime = metadata.temporalRange.startTime;
        }
        
        // è®¾ç½®åŸºæœ¬èŒƒå›´ï¼ˆéœ€è¦å®é™…è¯»å–æ–‡ä»¶è·å–ï¼‰
        metadata.extent.minX = -180.0;
        metadata.extent.maxX = 180.0;
        metadata.extent.minY = -90.0;
        metadata.extent.maxY = 90.0;
        
    } catch (const std::exception& e) {
        // å¿½ç•¥è§£æé”™è¯¯ï¼Œä¿æŒåŸºæœ¬ä¿¡æ¯
    }
}

void DataManagementWorkflow::extractGeoTIFFBasicInfo(const std::string& filePath, FileMetadata& metadata) {
    // âœ… ç®€åŒ–çš„GeoTIFFä¿¡æ¯æå–
    try {
        // è¿™é‡Œå¯ä»¥ä½¿ç”¨GDALåº“è¿›è¡ŒåŸºæœ¬ä¿¡æ¯è¯»å–
        // æš‚æ—¶è®¾ç½®é»˜è®¤å€¼
        
        metadata.extent.minX = 0.0;
        metadata.extent.maxX = 1.0;
        metadata.extent.minY = 0.0;
        metadata.extent.maxY = 1.0;
        
    } catch (const std::exception& e) {
        // å¿½ç•¥è§£æé”™è¯¯
    }
}

} // namespace workflows
} // namespace workflow_engine
```

## ğŸ“Š 4. æ–¹æ¡ˆBï¼šå®Œå…¨boostå®ç°ï¼ˆå¤‡é€‰æ–¹æ¡ˆï¼‰

### 4.1 boostå®Œæ•´å®ç°
```cpp
// æ–‡ä»¶: include/workflow_engine/workflow_engine_boost.h

#pragma once

// âœ… æ­£ç¡®çš„boosté…ç½®
#define BOOST_THREAD_PROVIDES_FUTURE
#define BOOST_THREAD_PROVIDES_FUTURE_CONTINUATION
#define BOOST_THREAD_PROVIDES_FUTURE_WHEN_ALL_WHEN_ANY
#define BOOST_THREAD_PROVIDES_FUTURE_ASYNC

#include <boost/thread/future.hpp>
#include <boost/asio/thread_pool.hpp>
#include <boost/asio/post.hpp>

namespace workflow_engine {

class WorkflowEngineBoost {
public:
    explicit WorkflowEngineBoost(const WorkflowEngineConfig& config = WorkflowEngineConfig{});
    ~WorkflowEngineBoost();

    /**
     * @brief æäº¤å·¥ä½œæµæ‰§è¡Œï¼ˆboostç‰ˆæœ¬ï¼‰
     * @param workflowType å·¥ä½œæµç±»å‹
     * @param context å·¥ä½œæµä¸Šä¸‹æ–‡
     * @return boost::futureå¯¹è±¡
     */
    boost::future<WorkflowContext> submitWorkflow(const std::string& workflowType, 
                                                 WorkflowContext context);

    /**
     * @brief æ‰¹é‡æäº¤å·¥ä½œæµï¼ˆboosté«˜çº§ç‰¹æ€§ï¼‰
     * @param requests å¤šä¸ªå·¥ä½œæµè¯·æ±‚
     * @return æ‰€æœ‰å·¥ä½œæµçš„future
     */
    boost::future<std::vector<WorkflowContext>> submitWorkflowBatch(
        const std::vector<std::pair<std::string, WorkflowContext>>& requests);

private:
    WorkflowEngineConfig config_;
    std::unique_ptr<boost::asio::thread_pool> threadPool_;
    
    struct WorkflowTaskBoost {
        std::string workflowId;
        std::string workflowType;
        WorkflowContext context;
        boost::promise<WorkflowContext> promise;                      // âœ… boost::promise
        std::function<void(const WorkflowContext&)> callback;
        std::chrono::system_clock::time_point submitTime;
        std::unique_ptr<WorkflowBase> workflow;
    };
};

} // namespace workflow_engine
```

## ğŸ“‹ 5. é‡æ„æ£€æŸ¥æ¸…å•

### 5.1 boostå…¼å®¹æ€§ä¿®æ­£ âœ…
- [ ] **å®Œå…¨ç§»é™¤boostä¾èµ–**: åˆ é™¤æ‰€æœ‰boostå¤´æ–‡ä»¶å’Œå®å®šä¹‰
- [ ] **std::futureç»Ÿä¸€**: æ‰€æœ‰å¼‚æ­¥æ¥å£ä½¿ç”¨std::future/std::promise
- [ ] **CMakeListsæ¸…ç†**: ç§»é™¤Boost::threadé“¾æ¥ä¾èµ–
- [ ] **ç¼–è¯‘éªŒè¯**: ç¡®ä¿æ‰€æœ‰ç›®æ ‡ç¼–è¯‘é€šè¿‡ï¼Œæ— ç¬¦å·å†²çª

### 5.2 æ•°æ®ç®¡ç†å·¥ä½œæµæ­£ç¡®æ€§ âœ…
- [ ] **å—æ§å¹¶å‘**: å®ç°åŸºäºæ‰¹æ¬¡çš„å¹¶å‘æ§åˆ¶ï¼Œä¸å†æ— é™åˆ¶åˆ›å»ºçº¿ç¨‹
- [ ] **å¼‚æ­¥æœåŠ¡è°ƒç”¨**: æ­£ç¡®ä½¿ç”¨æ ¸å¿ƒæœåŠ¡çš„å¼‚æ­¥æ¥å£
- [ ] **ç»“æœæ”¶é›†**: å®Œæ•´æ”¶é›†å’Œåˆå¹¶æ‰€æœ‰æ‰¹æ¬¡çš„å¤„ç†ç»“æœ
- [ ] **é”™è¯¯å¤„ç†**: æ¯ä¸ªç¯èŠ‚éƒ½æœ‰å®Œæ•´çš„å¼‚å¸¸å¤„ç†å’Œæ¢å¤æœºåˆ¶
- [ ] **è¿›åº¦æŠ¥å‘Š**: å®æ—¶å‡†ç¡®æŠ¥å‘Šå¤„ç†è¿›åº¦

### 5.3 èµ„æºç®¡ç†ä¼˜åŒ– âœ…
- [ ] **å†…å­˜æ§åˆ¶**: æ‰¹æ¬¡å¤„ç†ç¡®ä¿å†…å­˜ä½¿ç”¨å¯æ§
- [ ] **çº¿ç¨‹æ± ä½¿ç”¨**: ä½¿ç”¨std::asyncçš„åˆç†çº¿ç¨‹æ± 
- [ ] **æ–‡ä»¶å¥æŸ„ç®¡ç†**: ç¡®ä¿æ–‡ä»¶æ“ä½œåæ­£ç¡®å…³é—­å¥æŸ„
- [ ] **å¼‚å¸¸å®‰å…¨**: æ‰€æœ‰èµ„æºåœ¨å¼‚å¸¸æƒ…å†µä¸‹æ­£ç¡®é‡Šæ”¾

### 5.4 æ€§èƒ½éªŒè¯ âœ…
- [ ] **å¹¶å‘æ€§èƒ½**: éªŒè¯æ–°çš„æ‰¹æ¬¡å¹¶å‘æ¨¡å¼æ€§èƒ½
- [ ] **å†…å­˜æ•ˆç‡**: éªŒè¯å†…å­˜ä½¿ç”¨ä¸å†æ— é™åˆ¶å¢é•¿
- [ ] **é”™è¯¯æ¢å¤**: éªŒè¯å¼‚å¸¸æƒ…å†µä¸‹çš„æ¢å¤èƒ½åŠ›
- [ ] **å¤§è§„æ¨¡æµ‹è¯•**: ä½¿ç”¨1000+æ–‡ä»¶æµ‹è¯•ç¨³å®šæ€§

---

**é‡æ„æ€»ç»“**: å·¥ä½œæµå¼•æ“çš„boostå´©æºƒé—®é¢˜æ ¹æºåœ¨äºstd/boostæ··ç”¨å¯¼è‡´çš„ç¬¦å·å†²çªã€‚æ¨èæ–¹æ¡ˆAå½»åº•ç§»é™¤boostä¾èµ–ï¼Œä½¿ç”¨çº¯stdå®ç°ï¼ŒåŒæ—¶ä¿®æ­£æ•°æ®ç®¡ç†å·¥ä½œæµçš„å¹¶å‘æ§åˆ¶é€»è¾‘ï¼Œå®ç°çœŸæ­£çš„å—æ§å¹¶å‘å¤„ç†ã€‚é‡æ„åå°†å½»åº•è§£å†³å´©æºƒé—®é¢˜ï¼Œå¹¶æä¾›æ­£ç¡®ã€é«˜æ•ˆã€ç¨³å®šçš„å·¥ä½œæµå¤„ç†èƒ½åŠ›ã€‚ 