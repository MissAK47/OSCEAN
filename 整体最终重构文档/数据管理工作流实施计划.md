# æ•°æ®ç®¡ç†å·¥ä½œæµå®æ–½è®¡åˆ’

## é¡¹ç›®æ¦‚è¿°

åŸºäºæ‚¨æå‡ºçš„å…³é”®éœ€æ±‚ï¼Œæˆ‘ä»¬éœ€è¦å®ç°ä¸€ä¸ªæ™ºèƒ½çš„æ•°æ®ç®¡ç†å·¥ä½œæµç³»ç»Ÿï¼Œé‡ç‚¹è§£å†³ä»¥ä¸‹æ ¸å¿ƒé—®é¢˜ï¼š

### ğŸ¯ æ ¸å¿ƒéœ€æ±‚
1. **ç½‘æ ¼ç²¾åº¦ç®¡ç†**ï¼šä¸åŒç²¾åº¦æ•°æ®çš„è‡ªåŠ¨è¯†åˆ«å’Œæ’å€¼è®¡ç®—æ”¯æŒ
2. **æ—¶é—´åˆ†è¾¨ç‡åˆ†ç±»**ï¼šå¹´å¹³å‡ã€æœˆå¹³å‡ã€æ—¥å¹³å‡ã€å°æ—¶ç­‰ä¸åŒæ—¶é—´åˆ†è¾¨ç‡çš„ç»Ÿä¸€ç®¡ç†
3. **æ•°æ®è¿ç»­æ€§ä¿è¯**ï¼šç¡®ä¿åˆ†æä¸­ä½¿ç”¨ç›¸åŒæ—¶é—´åˆ†è¾¨ç‡ä¸”æ—¶é—´è¿ç»­çš„æ•°æ®
4. **ç¼ºå¤±æ•°æ®å¤„ç†**ï¼šè‡ªåŠ¨æ£€æµ‹æ•°æ®ç¼ºå£å¹¶æä¾›å‰ç«¯æç¤ºä¿¡æ¯

### ğŸ—ï¸ æŠ€æœ¯æ¶æ„
```
æ¶¡æµåˆ†æåº”ç”¨
    â†“ æŸ¥è¯¢è¯·æ±‚ (æŒ‡å®šæ—¶é—´åˆ†è¾¨ç‡å’Œç²¾åº¦è¦æ±‚)
æ•°æ®ç®¡ç†å·¥ä½œæµå±‚
    â†“ æ™ºèƒ½æ•°æ®é€‰æ‹© + è¿ç»­æ€§éªŒè¯
å¢å¼ºçš„å…ƒæ•°æ®æœåŠ¡
    â†“ ç²¾åº¦æ„ŸçŸ¥ + æ—¶é—´åˆ†è¾¨ç‡ç®¡ç†
æ•°æ®åº“å­˜å‚¨å±‚ (åŒ…å«è´¨é‡å’Œè¿ç»­æ€§ä¿¡æ¯)
    â†“ æ–‡ä»¶ç³»ç»Ÿ
NetCDFæ•°æ®æ–‡ä»¶
```

## ç¬¬ä¸€é˜¶æ®µï¼šæ•°æ®åº“è®¾è®¡ä¸å…ƒæ•°æ®å¢å¼ºï¼ˆ2-3å‘¨ï¼‰

### 1.1 æ•°æ®åº“è¡¨ç»“æ„å®ç°

#### ä¼˜å…ˆçº§1ï¼šæ ¸å¿ƒè¡¨ç»“æ„
```sql
-- 1. å¢å¼ºæ–‡ä»¶è¡¨ï¼Œæ·»åŠ ç²¾åº¦å’Œåˆ†è¾¨ç‡ä¿¡æ¯
ALTER TABLE nc_files ADD COLUMN temporal_resolution TEXT;
ALTER TABLE nc_files ADD COLUMN temporal_resolution_seconds INTEGER;
ALTER TABLE nc_files ADD COLUMN spatial_resolution_lon REAL;
ALTER TABLE nc_files ADD COLUMN spatial_resolution_lat REAL;
ALTER TABLE nc_files ADD COLUMN spatial_resolution_meters REAL;
ALTER TABLE nc_files ADD COLUMN grid_type TEXT;
ALTER TABLE nc_files ADD COLUMN data_completeness REAL DEFAULT 1.0;
ALTER TABLE nc_files ADD COLUMN fill_value_ratio REAL DEFAULT 0.0;

-- 2. åˆ›å»ºæ—¶é—´åˆ†è¾¨ç‡å®šä¹‰è¡¨
CREATE TABLE temporal_resolution_definitions (
    resolution_id TEXT PRIMARY KEY,
    resolution_name TEXT NOT NULL,
    resolution_seconds INTEGER NOT NULL,
    resolution_hours REAL NOT NULL,
    category TEXT NOT NULL,
    description TEXT,
    sort_order INTEGER DEFAULT 0,
    is_regular BOOLEAN DEFAULT TRUE
);

-- 3. åˆ›å»ºç©ºé—´åˆ†è¾¨ç‡ç­‰çº§è¡¨
CREATE TABLE spatial_resolution_levels (
    level_id TEXT PRIMARY KEY,
    level_name TEXT NOT NULL,
    min_resolution_degrees REAL NOT NULL,
    max_resolution_degrees REAL NOT NULL,
    description TEXT,
    interpolation_method TEXT,
    quality_weight REAL DEFAULT 1.0
);

-- 4. åˆ›å»ºæ—¶é—´è¿ç»­æ€§è¡¨
CREATE TABLE temporal_continuity (
    continuity_id TEXT PRIMARY KEY,        -- è¿ç»­æ€§è®°å½•ID
    dataset_id TEXT NOT NULL,              -- æ•°æ®é›†ID
    temporal_resolution TEXT NOT NULL,     -- æ—¶é—´åˆ†è¾¨ç‡
    period_start INTEGER NOT NULL,         -- æœŸé—´å¼€å§‹æ—¶é—´
    period_end INTEGER NOT NULL,           -- æœŸé—´ç»“æŸæ—¶é—´
    expected_steps INTEGER NOT NULL,       -- æœŸæœ›çš„æ—¶é—´æ­¥æ•°
    actual_steps INTEGER NOT NULL,         -- å®é™…çš„æ—¶é—´æ­¥æ•°
    missing_steps INTEGER DEFAULT 0,       -- ç¼ºå¤±çš„æ—¶é—´æ­¥æ•°
    continuity_ratio REAL NOT NULL,        -- è¿ç»­æ€§æ¯”ä¾‹ (0-1)
    max_gap_hours INTEGER DEFAULT 0,       -- æœ€å¤§é—´éš™(å°æ—¶)
    status TEXT DEFAULT 'valid',           -- çŠ¶æ€ (valid, warning, critical)
    last_checked INTEGER NOT NULL,         -- æœ€åæ£€æŸ¥æ—¶é—´
    FOREIGN KEY (dataset_id) REFERENCES datasets(dataset_id)
);

-- 5. åˆ›å»ºæµ·æ´‹ç¯å¢ƒæ•°æ®ç±»å‹è¡¨ (åŸºäºå“¥ç™½å°¼CMEMSåˆ†ç±»)
CREATE TABLE ocean_data_types (
    type_id TEXT PRIMARY KEY,              -- æ•°æ®ç±»å‹ID
    type_name TEXT NOT NULL,               -- æ•°æ®ç±»å‹åç§°
    category TEXT NOT NULL,                -- ä¸»è¦ç±»åˆ« (physical, biogeochemical, sea_ice)
    subcategory TEXT,                      -- å­ç±»åˆ«
    description TEXT,                      -- æè¿°
    standard_variables TEXT,               -- æ ‡å‡†å˜é‡åˆ—è¡¨ (JSON)
    cmems_product_family TEXT,             -- CMEMSäº§å“æ—
    temporal_resolution_types TEXT,        -- æ”¯æŒçš„æ—¶é—´åˆ†è¾¨ç‡ç±»å‹ (JSON)
    spatial_coverage TEXT,                 -- ç©ºé—´è¦†ç›–èŒƒå›´ (global, regional, coastal)
    data_level TEXT,                       -- æ•°æ®çº§åˆ« (L3, L4, analysis, forecast)
    processing_level TEXT,                 -- å¤„ç†çº§åˆ« (raw, processed, reanalysis)
    quality_requirements TEXT,             -- è´¨é‡è¦æ±‚ (JSON)
    interpolation_suitable BOOLEAN DEFAULT TRUE, -- æ˜¯å¦é€‚åˆæ’å€¼
    created_time INTEGER NOT NULL,         -- åˆ›å»ºæ—¶é—´
    updated_time INTEGER NOT NULL          -- æ›´æ–°æ—¶é—´
);

-- æ’å…¥å“¥ç™½å°¼æµ·æ´‹æ•°æ®ç±»å‹å®šä¹‰
INSERT INTO ocean_data_types VALUES
-- ç‰©ç†æµ·æ´‹å­¦æ•°æ® (è“è‰²æµ·æ´‹)
('ocean_current', 'æµ·æ´‹æµåœº', 'physical', 'circulation', 
 'æµ·æ´‹è¡¨é¢å’Œæ¬¡è¡¨é¢æµé€Ÿæ•°æ®ï¼ŒåŒ…æ‹¬åœ°è½¬æµå’Œæ€»æµ', 
 '["u", "v", "w", "velocity_magnitude", "velocity_direction"]',
 'GLOBAL_ANALYSIS_FORECAST_PHY', 
 '["hourly", "daily", "monthly"]', 
 'global', 'L4', 'analysis_forecast', 
 '{"min_continuity": 0.9, "max_fill_ratio": 0.1}', 
 true, strftime('%s', 'now'), strftime('%s', 'now')),

('sea_surface_height', 'æµ·é¢é«˜åº¦', 'physical', 'sea_level', 
 'æµ·é¢é«˜åº¦å¼‚å¸¸å’Œç»å¯¹åŠ¨åŠ›åœ°å½¢æ•°æ®', 
 '["adt", "sla", "mdt", "geostrophic_velocity"]',
 'SEALEVEL_GLO_PHY_L4', 
 '["daily", "monthly"]', 
 'global', 'L4', 'reanalysis', 
 '{"min_continuity": 0.95, "max_fill_ratio": 0.05}', 
 true, strftime('%s', 'now'), strftime('%s', 'now')),

('sea_surface_temperature', 'æµ·é¢æ¸©åº¦', 'physical', 'temperature', 
 'æµ·é¢æ¸©åº¦å’Œæµ·é¢æ¸©åº¦å¼‚å¸¸æ•°æ®', 
 '["sst", "sst_anomaly", "sst_trend"]',
 'SST_GLO_PHY_L4', 
 '["daily", "monthly", "yearly"]', 
 'global', 'L4', 'reanalysis', 
 '{"min_continuity": 0.9, "max_fill_ratio": 0.1}', 
 true, strftime('%s', 'now'), strftime('%s', 'now')),

('ocean_temperature_salinity', 'æµ·æ´‹æ¸©ç›', 'physical', 'hydrography', 
 'ä¸‰ç»´æµ·æ´‹æ¸©åº¦å’Œç›åº¦åˆ†å¸ƒæ•°æ®', 
 '["temperature", "salinity", "potential_temperature", "practical_salinity"]',
 'GLOBAL_MULTIYEAR_PHY', 
 '["daily", "monthly"]', 
 'global', 'L4', 'reanalysis', 
 '{"min_continuity": 0.85, "max_fill_ratio": 0.15}', 
 true, strftime('%s', 'now'), strftime('%s', 'now')),

('ocean_mixed_layer', 'æµ·æ´‹æ··åˆå±‚', 'physical', 'mixed_layer', 
 'æ··åˆå±‚æ·±åº¦å’Œç›¸å…³ç‰©ç†å‚æ•°', 
 '["mixed_layer_depth", "mixed_layer_temperature", "stratification"]',
 'GLOBAL_MULTIYEAR_PHY', 
 '["daily", "monthly"]', 
 'global', 'L4', 'analysis', 
 '{"min_continuity": 0.8, "max_fill_ratio": 0.2}', 
 true, strftime('%s', 'now'), strftime('%s', 'now')),

('ocean_waves', 'æµ·æµª', 'physical', 'waves', 
 'æµ·æµªé«˜åº¦ã€å‘¨æœŸã€æ–¹å‘ç­‰å‚æ•°', 
 '["significant_wave_height", "wave_period", "wave_direction", "wave_energy"]',
 'GLOBAL_ANALYSIS_FORECAST_WAV', 
 '["hourly", "3hourly", "daily"]', 
 'global', 'L4', 'analysis_forecast', 
 '{"min_continuity": 0.9, "max_fill_ratio": 0.1}', 
 true, strftime('%s', 'now'), strftime('%s', 'now')),

-- ç”Ÿç‰©åœ°çƒåŒ–å­¦æ•°æ® (ç»¿è‰²æµ·æ´‹)
('ocean_biogeochemistry', 'æµ·æ´‹ç”Ÿç‰©åœ°çƒåŒ–å­¦', 'biogeochemical', 'nutrients', 
 'æµ·æ´‹è¥å…»ç›ã€æº¶è§£æ°§ã€pHç­‰ç”ŸåŒ–å‚æ•°', 
 '["nitrate", "phosphate", "silicate", "oxygen", "ph", "alkalinity"]',
 'GLOBAL_ANALYSIS_FORECAST_BGC', 
 '["daily", "monthly"]', 
 'global', 'L4', 'analysis_forecast', 
 '{"min_continuity": 0.8, "max_fill_ratio": 0.2}', 
 true, strftime('%s', 'now'), strftime('%s', 'now')),

('ocean_color', 'æµ·æ´‹é¢œè‰²', 'biogeochemical', 'optics', 
 'å¶ç»¿ç´ æµ“åº¦ã€åˆçº§ç”Ÿäº§åŠ›ã€é€æ˜åº¦ç­‰å…‰å­¦å‚æ•°', 
 '["chlorophyll_a", "primary_production", "kd490", "turbidity"]',
 'OCEANCOLOUR_GLO_BGC_L4', 
 '["daily", "monthly"]', 
 'global', 'L4', 'satellite_obs', 
 '{"min_continuity": 0.7, "max_fill_ratio": 0.3}', 
 false, strftime('%s', 'now'), strftime('%s', 'now')),

('ocean_carbon', 'æµ·æ´‹ç¢³å¾ªç¯', 'biogeochemical', 'carbon', 
 'æµ·æ´‹ç¢³é€šé‡ã€CO2åˆ†å‹ã€ç¢³é…¸ç›ç³»ç»Ÿå‚æ•°', 
 '["co2_flux", "pco2", "dic", "carbon_export"]',
 'GLOBAL_ANALYSIS_FORECAST_BGC', 
 '["monthly", "yearly"]', 
 'global', 'L4', 'analysis', 
 '{"min_continuity": 0.75, "max_fill_ratio": 0.25}', 
 true, strftime('%s', 'now'), strftime('%s', 'now')),

('marine_ecosystems', 'æµ·æ´‹ç”Ÿæ€ç³»ç»Ÿ', 'biogeochemical', 'ecosystem', 
 'æµ®æ¸¸æ¤ç‰©ã€æµ®æ¸¸åŠ¨ç‰©ã€é±¼ç±»ç”Ÿç‰©é‡ç­‰ç”Ÿæ€å‚æ•°', 
 '["phytoplankton", "zooplankton", "fish_biomass", "biodiversity_index"]',
 'GLOBAL_ANALYSIS_FORECAST_BGC', 
 '["monthly", "yearly"]', 
 'global', 'L4', 'analysis', 
 '{"min_continuity": 0.7, "max_fill_ratio": 0.3}', 
 false, strftime('%s', 'now'), strftime('%s', 'now')),

-- æµ·å†°æ•°æ® (ç™½è‰²æµ·æ´‹)
('sea_ice', 'æµ·å†°', 'sea_ice', 'ice_coverage', 
 'æµ·å†°æµ“åº¦ã€åšåº¦ã€æ¼‚ç§»ç­‰å‚æ•°', 
 '["ice_concentration", "ice_thickness", "ice_drift", "ice_age"]',
 'SEAICE_GLO_PHY_L4', 
 '["daily", "monthly"]', 
 'polar', 'L4', 'analysis_forecast', 
 '{"min_continuity": 0.85, "max_fill_ratio": 0.15}', 
 true, strftime('%s', 'now'), strftime('%s', 'now')),

('sea_ice_edge', 'æµ·å†°è¾¹ç¼˜', 'sea_ice', 'ice_edge', 
 'æµ·å†°è¾¹ç¼˜ä½ç½®å’Œå˜åŒ–è¶‹åŠ¿', 
 '["ice_edge_position", "ice_edge_velocity", "ice_extent"]',
 'SEAICE_GLO_PHY_L4', 
 '["daily", "monthly"]', 
 'polar', 'L4', 'analysis', 
 '{"min_continuity": 0.9, "max_fill_ratio": 0.1}', 
 true, strftime('%s', 'now'), strftime('%s', 'now')),

-- åŒºåŸŸç‰¹å®šæ•°æ®ç±»å‹
('arctic_ocean', 'åŒ—ææµ·æ´‹', 'physical', 'regional', 
 'åŒ—ææµ·æ´‹ç‰©ç†å’Œæµ·å†°ç»¼åˆæ•°æ®', 
 '["u", "v", "temperature", "salinity", "ice_concentration"]',
 'ARCTIC_ANALYSIS_FORECAST_PHYS', 
 '["daily", "monthly"]', 
 'regional', 'L4', 'analysis_forecast', 
 '{"min_continuity": 0.85, "max_fill_ratio": 0.15}', 
 true, strftime('%s', 'now'), strftime('%s', 'now')),

('coastal_ocean', 'è¿‘å²¸æµ·æ´‹', 'physical', 'coastal', 
 'é«˜åˆ†è¾¨ç‡è¿‘å²¸æµ·æ´‹ç‰©ç†æ•°æ®', 
 '["u", "v", "temperature", "salinity", "ssh", "waves"]',
 'COASTAL_ANALYSIS_FORECAST', 
 '["hourly", "daily"]', 
 'coastal', 'L4', 'analysis_forecast', 
 '{"min_continuity": 0.8, "max_fill_ratio": 0.2}', 
 true, strftime('%s', 'now'), strftime('%s', 'now')),

-- æç«¯äº‹ä»¶å’Œç‰¹æ®Šç°è±¡
('ocean_eddies', 'æµ·æ´‹æ¶¡æ—‹', 'physical', 'mesoscale', 
 'ä¸­å°ºåº¦æ¶¡æ—‹è¯†åˆ«å’Œè·Ÿè¸ªæ•°æ®', 
 '["eddy_id", "eddy_type", "eddy_radius", "eddy_intensity", "vorticity"]',
 'GLOBAL_ANALYSIS_FORECAST_PHY', 
 '["daily", "weekly"]', 
 'global', 'L4', 'derived_product', 
 '{"min_continuity": 0.95, "max_fill_ratio": 0.05}', 
 false, strftime('%s', 'now'), strftime('%s', 'now')),

('ocean_sound_speed', 'æµ·æ´‹å£°é€Ÿ', 'physical', 'acoustics', 
 'æµ·æ´‹ä¸­å£°æ³¢ä¼ æ’­é€Ÿåº¦æ•°æ®ï¼ŒåŸºäºæ¸©åº¦ã€ç›åº¦å’Œå‹åŠ›è®¡ç®—', 
 '["sound_speed", "sound_speed_anomaly", "acoustic_impedance"]',
 'GLOBAL_MULTIYEAR_PHY', 
 '["daily", "monthly"]', 
 'global', 'L4', 'derived_product', 
 '{"min_continuity": 0.85, "max_fill_ratio": 0.15}', 
 true, strftime('%s', 'now'), strftime('%s', 'now'));
```

#### ä¼˜å…ˆçº§2ï¼šç´¢å¼•ä¼˜åŒ–
```sql
-- æ—¶é—´åˆ†è¾¨ç‡ç›¸å…³ç´¢å¼•
CREATE INDEX idx_files_temporal_resolution ON nc_files(temporal_resolution, temporal_resolution_seconds);
CREATE INDEX idx_files_time_continuity ON nc_files(dataset_id, time_start, time_end);

-- ç©ºé—´åˆ†è¾¨ç‡ç›¸å…³ç´¢å¼•
CREATE INDEX idx_files_spatial_resolution ON nc_files(spatial_resolution_lon, spatial_resolution_lat);
CREATE INDEX idx_files_grid_type ON nc_files(grid_type);

-- æ•°æ®è´¨é‡ç›¸å…³ç´¢å¼•
CREATE INDEX idx_files_quality ON nc_files(data_completeness, fill_value_ratio);

-- è¿ç»­æ€§ç›¸å…³ç´¢å¼•
CREATE INDEX idx_continuity_dataset ON temporal_continuity(dataset_id, temporal_resolution);
CREATE INDEX idx_continuity_ratio ON temporal_continuity(continuity_ratio, status);
```

### 1.2 å…ƒæ•°æ®æœåŠ¡å¢å¼º

#### æ‰©å±•ç°æœ‰MetadataService
```cpp
// core_services_impl/metadata_service/include/core_services/metadata/impl/metadata_service_impl.h
class MetadataServiceImpl : public IMetadataService {
public:
    // æ–°å¢ï¼šæå–æ—¶é—´åˆ†è¾¨ç‡ä¿¡æ¯
    TemporalResolutionInfo extractTemporalResolution(const std::string& filePath);
    
    // æ–°å¢ï¼šæå–ç©ºé—´åˆ†è¾¨ç‡ä¿¡æ¯
    SpatialResolutionInfo extractSpatialResolution(const std::string& filePath);
    
    // æ–°å¢ï¼šè®¡ç®—æ•°æ®è´¨é‡æŒ‡æ ‡
    DataQualityMetrics calculateQualityMetrics(const std::string& filePath, 
                                              const std::vector<std::string>& variables);
    
    // æ–°å¢ï¼šæ£€æŸ¥æ—¶é—´è¿ç»­æ€§
    ContinuityAnalysis analyzeContinuity(const std::string& datasetId,
                                       const std::string& temporalResolution,
                                       std::time_t startTime,
                                       std::time_t endTime);

private:
    // æ—¶é—´åˆ†è¾¨ç‡æ£€æµ‹ç®—æ³•
    std::string detectTemporalResolution(const std::vector<std::time_t>& timeSteps);
    
    // ç©ºé—´åˆ†è¾¨ç‡è®¡ç®—
    double calculateSpatialResolution(const std::vector<double>& coordinates);
    
    // æ•°æ®å®Œæ•´æ€§è¯„ä¼°
    double assessDataCompleteness(const std::string& filePath, const std::string& variable);
};
```

#### æ•°æ®ç»“æ„å®šä¹‰
```cpp
// core_services_impl/metadata_service/include/core_services/metadata/impl/enhanced_metadata_types.h
struct TemporalResolutionInfo {
    std::string resolutionId;           // "hourly", "daily", "monthly", etc.
    std::string resolutionName;         // "å°æ—¶", "æ—¥", "æœˆ"
    int resolutionSeconds;              // ç§’æ•°
    double resolutionHours;             // å°æ—¶æ•°
    std::string category;               // "sub_hourly", "hourly", "daily", etc.
    bool isRegular;                     // æ˜¯å¦è§„å¾‹é—´éš”
    double detectedInterval;            // æ£€æµ‹åˆ°çš„å®é™…é—´éš”
    double intervalVariance;            // é—´éš”æ–¹å·®ï¼ˆç”¨äºè¯„ä¼°è§„å¾‹æ€§ï¼‰
};

struct SpatialResolutionInfo {
    double lonResolution;               // ç»åº¦åˆ†è¾¨ç‡(åº¦)
    double latResolution;               // çº¬åº¦åˆ†è¾¨ç‡(åº¦)
    double avgResolutionMeters;         // å¹³å‡åˆ†è¾¨ç‡(ç±³)
    std::string resolutionLevel;        // "ultra_high", "high", "medium", "low"
    std::string gridType;               // "regular", "irregular", "curvilinear"
    bool isUniform;                     // æ˜¯å¦å‡åŒ€ç½‘æ ¼
    BoundingBox spatialBounds;          // ç©ºé—´è¾¹ç•Œ
};

struct DataQualityMetrics {
    double completeness;                // æ•°æ®å®Œæ•´æ€§ (0-1)
    double fillValueRatio;              // å¡«å……å€¼æ¯”ä¾‹ (0-1)
    std::map<std::string, VariableQuality> variableQuality;
    double overallScore;                // æ€»ä½“è´¨é‡è¯„åˆ† (0-1)
    std::vector<std::string> qualityIssues;
};

struct VariableQuality {
    double validDataRatio;              // æœ‰æ•ˆæ•°æ®æ¯”ä¾‹
    double minValue;                    // æœ€å°å€¼
    double maxValue;                    // æœ€å¤§å€¼
    double meanValue;                   // å¹³å‡å€¼
    double stdValue;                    // æ ‡å‡†å·®
    bool hasOutliers;                   // æ˜¯å¦æœ‰å¼‚å¸¸å€¼
    std::string qualityLevel;           // "excellent", "good", "fair", "poor"
};

struct ContinuityAnalysis {
    std::string datasetId;
    std::string temporalResolution;
    std::time_t periodStart;
    std::time_t periodEnd;
    
    int expectedSteps;                  // æœŸæœ›çš„æ—¶é—´æ­¥æ•°
    int actualSteps;                    // å®é™…çš„æ—¶é—´æ­¥æ•°
    int missingSteps;                   // ç¼ºå¤±çš„æ—¶é—´æ­¥æ•°
    double continuityRatio;             // è¿ç»­æ€§æ¯”ä¾‹ (0-1)
    
    std::vector<DataGap> gaps;          // æ•°æ®ç¼ºå£åˆ—è¡¨
    std::chrono::hours maxGapDuration;  // æœ€å¤§ç¼ºå£æŒç»­æ—¶é—´
    std::chrono::hours avgGapDuration;  // å¹³å‡ç¼ºå£æŒç»­æ—¶é—´
    
    std::string status;                 // "excellent", "good", "warning", "critical"
    std::vector<std::string> recommendations;
};

struct DataGap {
    std::time_t gapStart;
    std::time_t gapEnd;
    std::chrono::hours duration;
    std::string severity;               // "minor", "moderate", "critical"
    std::string gapType;                // "missing_file", "missing_timestep", "invalid_data"
    std::vector<std::string> affectedVariables;
    std::string recommendedAction;      // "interpolate", "skip", "find_alternative"
};
```

## ç¬¬äºŒé˜¶æ®µï¼šè¿ç»­æ€§æ£€æŸ¥ä¸è´¨é‡è¯„ä¼°ç®—æ³•ï¼ˆ2-3å‘¨ï¼‰

### 2.1 æ—¶é—´è¿ç»­æ€§æ£€æŸ¥ç®—æ³•

#### æ ¸å¿ƒç®—æ³•å®ç°
```cpp
// core_services_impl/metadata_service/src/impl/continuity_analyzer.cpp
class ContinuityAnalyzer {
public:
    ContinuityAnalysis analyzeContinuity(const std::string& datasetId,
                                       const std::string& temporalResolution) {
        // 1. è·å–æ•°æ®é›†ä¸­æ‰€æœ‰æ–‡ä»¶çš„æ—¶é—´ä¿¡æ¯
        auto files = getDatasetFiles(datasetId);
        
        // 2. æ„å»ºå®Œæ•´çš„æ—¶é—´åºåˆ—
        auto timeSteps = buildTimeSequence(files, temporalResolution);
        
        // 3. æ£€æµ‹æ—¶é—´ç¼ºå£
        auto gaps = detectTimeGaps(timeSteps, temporalResolution);
        
        // 4. è¯„ä¼°è¿ç»­æ€§
        auto continuity = evaluateContinuity(timeSteps, gaps);
        
        // 5. ç”Ÿæˆå»ºè®®
        auto recommendations = generateRecommendations(gaps, temporalResolution);
        
        return ContinuityAnalysis{
            .datasetId = datasetId,
            .temporalResolution = temporalResolution,
            .gaps = gaps,
            .continuityRatio = continuity.ratio,
            .status = continuity.status,
            .recommendations = recommendations
        };
    }

private:
    std::vector<DataGap> detectTimeGaps(const std::vector<std::time_t>& timeSteps,
                                       const std::string& temporalResolution) {
        std::vector<DataGap> gaps;
        
        // è·å–æœŸæœ›çš„æ—¶é—´é—´éš”
        auto expectedInterval = getExpectedInterval(temporalResolution);
        
        for (size_t i = 1; i < timeSteps.size(); ++i) {
            auto actualInterval = timeSteps[i] - timeSteps[i-1];
            
            // å¦‚æœå®é™…é—´éš”è¶…è¿‡æœŸæœ›é—´éš”çš„1.5å€ï¼Œè®¤ä¸ºå­˜åœ¨ç¼ºå£
            if (actualInterval > expectedInterval * 1.5) {
                DataGap gap;
                gap.gapStart = timeSteps[i-1] + expectedInterval;
                gap.gapEnd = timeSteps[i];
                gap.duration = std::chrono::hours((actualInterval - expectedInterval) / 3600);
                gap.severity = classifyGapSeverity(gap.duration, temporalResolution);
                gap.gapType = "missing_timestep";
                gap.recommendedAction = suggestAction(gap.severity, gap.duration);
                
                gaps.push_back(gap);
            }
        }
        
        return gaps;
    }
    
    std::string classifyGapSeverity(std::chrono::hours duration, 
                                   const std::string& temporalResolution) {
        // æ ¹æ®æ—¶é—´åˆ†è¾¨ç‡å’Œç¼ºå£æŒç»­æ—¶é—´åˆ†ç±»ä¸¥é‡ç¨‹åº¦
        if (temporalResolution == "hourly") {
            if (duration <= std::chrono::hours(3)) return "minor";
            if (duration <= std::chrono::hours(12)) return "moderate";
            return "critical";
        } else if (temporalResolution == "daily") {
            if (duration <= std::chrono::hours(48)) return "minor";
            if (duration <= std::chrono::hours(168)) return "moderate";  // 1å‘¨
            return "critical";
        }
        // å…¶ä»–åˆ†è¾¨ç‡çš„åˆ†ç±»é€»è¾‘...
        return "moderate";
    }
};
```

### 2.2 æ•°æ®è´¨é‡è¯„ä¼°ç®—æ³•

#### è´¨é‡è¯„åˆ†ç®—æ³•
```cpp
// core_services_impl/metadata_service/src/impl/quality_assessor.cpp
class QualityAssessor {
public:
    DataQualityMetrics assessQuality(const std::string& filePath,
                                   const std::vector<std::string>& variables) {
        DataQualityMetrics metrics;
        
        // 1. è¯„ä¼°æ¯ä¸ªå˜é‡çš„è´¨é‡
        for (const auto& variable : variables) {
            auto varQuality = assessVariableQuality(filePath, variable);
            metrics.variableQuality[variable] = varQuality;
        }
        
        // 2. è®¡ç®—æ•´ä½“å®Œæ•´æ€§
        metrics.completeness = calculateCompleteness(filePath, variables);
        
        // 3. è®¡ç®—å¡«å……å€¼æ¯”ä¾‹
        metrics.fillValueRatio = calculateFillValueRatio(filePath, variables);
        
        // 4. è®¡ç®—æ€»ä½“è´¨é‡è¯„åˆ†
        metrics.overallScore = calculateOverallScore(metrics);
        
        // 5. è¯†åˆ«è´¨é‡é—®é¢˜
        metrics.qualityIssues = identifyQualityIssues(metrics);
        
        return metrics;
    }

private:
    VariableQuality assessVariableQuality(const std::string& filePath,
                                        const std::string& variable) {
        VariableQuality quality;
        
        // ä½¿ç”¨NetCDFè¯»å–å™¨è·å–å˜é‡æ•°æ®ç»Ÿè®¡ä¿¡æ¯
        auto reader = createNetCDFReader(filePath);
        auto stats = reader->getVariableStatistics(variable);
        
        quality.validDataRatio = stats.validDataRatio;
        quality.minValue = stats.minValue;
        quality.maxValue = stats.maxValue;
        quality.meanValue = stats.meanValue;
        quality.stdValue = stats.stdValue;
        
        // å¼‚å¸¸å€¼æ£€æµ‹
        quality.hasOutliers = detectOutliers(stats);
        
        // è´¨é‡ç­‰çº§è¯„ä¼°
        quality.qualityLevel = evaluateQualityLevel(quality);
        
        return quality;
    }
    
    double calculateOverallScore(const DataQualityMetrics& metrics) {
        double score = 0.0;
        double weights = 0.0;
        
        // å®Œæ•´æ€§æƒé‡ï¼š40%
        score += metrics.completeness * 0.4;
        weights += 0.4;
        
        // å¡«å……å€¼æ¯”ä¾‹æƒé‡ï¼š30% (åå‘)
        score += (1.0 - metrics.fillValueRatio) * 0.3;
        weights += 0.3;
        
        // å˜é‡è´¨é‡æƒé‡ï¼š30%
        double avgVariableQuality = 0.0;
        for (const auto& [varName, varQuality] : metrics.variableQuality) {
            avgVariableQuality += varQuality.validDataRatio;
        }
        if (!metrics.variableQuality.empty()) {
            avgVariableQuality /= metrics.variableQuality.size();
            score += avgVariableQuality * 0.3;
            weights += 0.3;
        }
        
        return weights > 0 ? score / weights : 0.0;
    }
};
```

## ç¬¬ä¸‰é˜¶æ®µï¼šæ™ºèƒ½æŸ¥è¯¢æœåŠ¡å®ç°ï¼ˆ2-3å‘¨ï¼‰

### 3.1 å¢å¼ºçš„æŸ¥è¯¢æ¥å£

#### æ¶¡æµåˆ†æä¸“ç”¨æŸ¥è¯¢æœåŠ¡
```cpp
// core_services_impl/data_access_service/include/core_services/data_access/enhanced_query_service.h
class EddyDataQueryService {
public:
    struct EddyAnalysisQuery {
        std::time_t analysisTime;
        BoundingBox analysisRegion;
        std::chrono::hours timeWindow = std::chrono::hours(24);
        
        // æ—¶é—´åˆ†è¾¨ç‡è¦æ±‚
        std::string preferredTemporalResolution = "hourly";
        std::vector<std::string> acceptableTemporalResolutions = {"hourly", "3hourly", "6hourly"};
        double minContinuityRatio = 0.9;
        
        // ç©ºé—´åˆ†è¾¨ç‡è¦æ±‚
        std::string preferredSpatialResolution = "high";
        double maxSpatialResolutionDegrees = 0.1;
        
        // å˜é‡è¦æ±‚
        std::vector<std::string> requiredVariables = {"u", "v", "w"};
        std::vector<std::string> optionalVariables = {"temperature", "salinity"};
        
        // è´¨é‡è¦æ±‚
        double minDataQuality = 0.8;
        double maxFillValueRatio = 0.1;
        
        // æ’å€¼é…ç½®
        bool allowTemporalInterpolation = true;
        bool allowSpatialInterpolation = false;
        std::string interpolationMethod = "linear";
    };
    
    struct EddyDataFileSet {
        std::vector<FileInfo> primaryFiles;
        std::vector<FileInfo> supplementaryFiles;
        ContinuityReport continuityReport;
        InterpolationPlan interpolationPlan;
        QualityAssessment qualityAssessment;
        std::vector<DataGap> identifiedGaps;
        std::vector<std::string> warnings;
        std::vector<std::string> recommendations;
    };
    
    // è·å–æ¶¡æµåˆ†ææ‰€éœ€çš„æ–‡ä»¶é›†åˆ
    EddyDataFileSet getEddyAnalysisFiles(const EddyAnalysisQuery& query);
    
    // éªŒè¯æ•°æ®é›†çš„æ—¶é—´è¿ç»­æ€§
    ContinuityValidationResult validateTimeContinuity(
        const std::vector<FileInfo>& files,
        const std::string& temporalResolution);
    
    // ç”Ÿæˆæ’å€¼å»ºè®®
    InterpolationRecommendation generateInterpolationPlan(
        const EddyAnalysisQuery& query,
        const std::vector<DataGap>& gaps);

private:
    std::shared_ptr<IMetadataService> metadataService_;
    std::shared_ptr<ContinuityAnalyzer> continuityAnalyzer_;
    std::shared_ptr<QualityAssessor> qualityAssessor_;
};
```

#### æŸ¥è¯¢å®ç°
```cpp
// core_services_impl/data_access_service/src/impl/eddy_data_query_service.cpp
EddyDataFileSet EddyDataQueryService::getEddyAnalysisFiles(const EddyAnalysisQuery& query) {
    EddyDataFileSet result;
    
    // 1. æ„å»ºåŸºç¡€æŸ¥è¯¢æ¡ä»¶
    SpatialTemporalQuery baseQuery;
    baseQuery.timeStart = query.analysisTime - query.timeWindow;
    baseQuery.timeEnd = query.analysisTime + query.timeWindow;
    baseQuery.spatialBounds = query.analysisRegion;
    baseQuery.requiredVariables = query.requiredVariables;
    baseQuery.requiredTemporalResolution = query.preferredTemporalResolution;
    baseQuery.maxSpatialResolution = query.maxSpatialResolutionDegrees;
    baseQuery.minDataQuality = query.minDataQuality;
    baseQuery.maxFillValueRatio = query.maxFillValueRatio;
    
    // 2. æŸ¥æ‰¾åŒ¹é…çš„æ–‡ä»¶
    auto candidateFiles = findCandidateFiles(baseQuery);
    
    // 3. æŒ‰æ—¶é—´åˆ†è¾¨ç‡åˆ†ç»„
    auto filesByResolution = groupFilesByTemporalResolution(candidateFiles);
    
    // 4. é€‰æ‹©æœ€ä½³æ—¶é—´åˆ†è¾¨ç‡
    auto bestResolution = selectBestTemporalResolution(filesByResolution, query);
    result.primaryFiles = filesByResolution[bestResolution];
    
    // 5. æ£€æŸ¥æ—¶é—´è¿ç»­æ€§
    result.continuityReport = continuityAnalyzer_->analyzeContinuity(
        result.primaryFiles, bestResolution);
    
    // 6. è¯„ä¼°æ•°æ®è´¨é‡
    result.qualityAssessment = qualityAssessor_->assessFileSetQuality(
        result.primaryFiles, query.requiredVariables);
    
    // 7. è¯†åˆ«æ•°æ®ç¼ºå£
    result.identifiedGaps = result.continuityReport.gaps;
    
    // 8. ç”Ÿæˆæ’å€¼è®¡åˆ’
    if (!result.identifiedGaps.empty() && query.allowTemporalInterpolation) {
        result.interpolationPlan = generateInterpolationPlan(query, result.identifiedGaps);
    }
    
    // 9. ç”Ÿæˆè­¦å‘Šå’Œå»ºè®®
    result.warnings = generateWarnings(result);
    result.recommendations = generateRecommendations(result, query);
    
    return result;
}

std::string EddyDataQueryService::selectBestTemporalResolution(
    const std::map<std::string, std::vector<FileInfo>>& filesByResolution,
    const EddyAnalysisQuery& query) {
    
    // ä¼˜å…ˆé€‰æ‹©é¦–é€‰åˆ†è¾¨ç‡
    if (filesByResolution.count(query.preferredTemporalResolution) > 0) {
        auto& files = filesByResolution.at(query.preferredTemporalResolution);
        auto continuity = continuityAnalyzer_->analyzeContinuity(files, query.preferredTemporalResolution);
        if (continuity.continuityRatio >= query.minContinuityRatio) {
            return query.preferredTemporalResolution;
        }
    }
    
    // å°è¯•å¯æ¥å—çš„åˆ†è¾¨ç‡
    for (const auto& resolution : query.acceptableTemporalResolutions) {
        if (filesByResolution.count(resolution) > 0) {
            auto& files = filesByResolution.at(resolution);
            auto continuity = continuityAnalyzer_->analyzeContinuity(files, resolution);
            if (continuity.continuityRatio >= query.minContinuityRatio) {
                return resolution;
            }
        }
    }
    
    // å¦‚æœæ²¡æœ‰æ»¡è¶³è¿ç»­æ€§è¦æ±‚çš„ï¼Œé€‰æ‹©è¿ç»­æ€§æœ€å¥½çš„
    std::string bestResolution;
    double bestContinuity = 0.0;
    
    for (const auto& [resolution, files] : filesByResolution) {
        auto continuity = continuityAnalyzer_->analyzeContinuity(files, resolution);
        if (continuity.continuityRatio > bestContinuity) {
            bestContinuity = continuity.continuityRatio;
            bestResolution = resolution;
        }
    }
    
    return bestResolution;
}
```

### 3.2 å‰ç«¯æç¤ºä¿¡æ¯ç”Ÿæˆ

#### è­¦å‘Šä¿¡æ¯ç”Ÿæˆå™¨
```cpp
// core_services_impl/data_access_service/src/impl/warning_generator.cpp
class WarningGenerator {
public:
    std::vector<UserWarning> generateWarnings(const EddyDataFileSet& fileSet,
                                             const EddyAnalysisQuery& query) {
        std::vector<UserWarning> warnings;
        
        // 1. è¿ç»­æ€§è­¦å‘Š
        if (fileSet.continuityReport.continuityRatio < query.minContinuityRatio) {
            warnings.push_back(generateContinuityWarning(fileSet.continuityReport, query));
        }
        
        // 2. åˆ†è¾¨ç‡ä¸åŒ¹é…è­¦å‘Š
        if (hasResolutionMismatch(fileSet, query)) {
            warnings.push_back(generateResolutionWarning(fileSet, query));
        }
        
        // 3. æ•°æ®è´¨é‡è­¦å‘Š
        if (fileSet.qualityAssessment.overallScore < query.minDataQuality) {
            warnings.push_back(generateQualityWarning(fileSet.qualityAssessment, query));
        }
        
        // 4. æ’å€¼éœ€æ±‚è­¦å‘Š
        if (fileSet.interpolationPlan.isRequired) {
            warnings.push_back(generateInterpolationWarning(fileSet.interpolationPlan));
        }
        
        return warnings;
    }

private:
    UserWarning generateContinuityWarning(const ContinuityReport& report,
                                         const EddyAnalysisQuery& query) {
        UserWarning warning;
        warning.type = "data_continuity";
        warning.severity = report.continuityRatio < 0.5 ? "critical" : "warning";
        warning.title = "æ£€æµ‹åˆ°æ•°æ®æ—¶é—´åºåˆ—ä¸è¿ç»­";
        
        // æ„å»ºè¯¦ç»†ä¿¡æ¯
        nlohmann::json details;
        details["dataset"] = report.datasetId;
        details["temporal_resolution"] = report.temporalResolution;
        details["continuity_ratio"] = report.continuityRatio;
        details["required_ratio"] = query.minContinuityRatio;
        details["gaps_found"] = report.gaps.size();
        details["max_gap_duration"] = report.maxGapDuration.count();
        
        if (!report.gaps.empty()) {
            auto& firstGap = report.gaps[0];
            details["first_gap_start"] = formatTime(firstGap.gapStart);
            details["first_gap_end"] = formatTime(firstGap.gapEnd);
        }
        
        warning.details = details;
        
        // ç”Ÿæˆå»ºè®®
        warning.recommendations = {
            "è€ƒè™‘ä½¿ç”¨çº¿æ€§æ’å€¼å¡«è¡¥è¾ƒå°çš„æ•°æ®ç¼ºå£",
            "å¯¹äºå…³é”®åˆ†æï¼Œå»ºè®®å¯»æ‰¾æ›¿ä»£æ•°æ®æº",
            "å¯ä»¥è°ƒæ•´åˆ†ææ—¶é—´çª—å£ä»¥é¿å¼€ä¸»è¦æ•°æ®ç¼ºå£"
        };
        
        // ç”Ÿæˆå¯æ‰§è¡Œæ“ä½œ
        if (query.allowTemporalInterpolation) {
            UserAction interpolateAction;
            interpolateAction.type = "interpolate";
            interpolateAction.label = "è‡ªåŠ¨æ’å€¼å¡«è¡¥";
            interpolateAction.apiEndpoint = "/api/data/interpolate";
            interpolateAction.parameters = {
                {"gaps", report.gaps},
                {"method", query.interpolationMethod}
            };
            warning.actions.push_back(interpolateAction);
        }
        
        UserAction findAlternativeAction;
        findAlternativeAction.type = "find_alternative";
        findAlternativeAction.label = "æŸ¥æ‰¾æ›¿ä»£æ•°æ®";
        findAlternativeAction.apiEndpoint = "/api/data/alternatives";
        findAlternativeAction.parameters = {
            {"query", query},
            {"exclude_datasets", {report.datasetId}}
        };
        warning.actions.push_back(findAlternativeAction);
        
        return warning;
    }
};

struct UserWarning {
    std::string type;                   // "data_continuity", "resolution_mismatch", "data_quality"
    std::string severity;               // "info", "warning", "critical"
    std::string title;                  // è­¦å‘Šæ ‡é¢˜
    std::string message;                // è¯¦ç»†æ¶ˆæ¯
    nlohmann::json details;             // è¯¦ç»†ä¿¡æ¯
    std::vector<std::string> recommendations; // å»ºè®®
    std::vector<UserAction> actions;    // å¯æ‰§è¡Œæ“ä½œ
};

struct UserAction {
    std::string type;                   // æ“ä½œç±»å‹
    std::string label;                  // æ˜¾ç¤ºæ ‡ç­¾
    std::string apiEndpoint;            // APIç«¯ç‚¹
    nlohmann::json parameters;          // å‚æ•°
};
```

## ç¬¬å››é˜¶æ®µï¼šAPIæ¥å£ä¸å‰ç«¯é›†æˆï¼ˆ1-2å‘¨ï¼‰

### 4.1 RESTful APIå®ç°

#### æ¶¡æµåˆ†æä¸“ç”¨API
```cpp
// network_service/src/handlers/eddy_data_handler.cpp
class EddyDataHandler {
public:
    // è·å–æ¶¡æµåˆ†ææ•°æ®
    crow::response handleEddyDataQuery(const crow::request& req) {
        try {
            // è§£æè¯·æ±‚
            auto query = parseEddyAnalysisQuery(req.body);
            
            // æ‰§è¡ŒæŸ¥è¯¢
            auto fileSet = eddyQueryService_->getEddyAnalysisFiles(query);
            
            // ç”Ÿæˆå“åº”
            nlohmann::json response;
            response["status"] = "success";
            response["data"] = {
                {"primary_files", fileSet.primaryFiles},
                {"supplementary_files", fileSet.supplementaryFiles},
                {"continuity_report", fileSet.continuityReport},
                {"quality_assessment", fileSet.qualityAssessment},
                {"interpolation_plan", fileSet.interpolationPlan},
                {"warnings", fileSet.warnings},
                {"recommendations", fileSet.recommendations}
            };
            
            return crow::response(200, response.dump());
            
        } catch (const std::exception& e) {
            nlohmann::json error;
            error["status"] = "error";
            error["message"] = e.what();
            return crow::response(400, error.dump());
        }
    }
    
    // éªŒè¯æ•°æ®è¿ç»­æ€§
    crow::response handleContinuityValidation(const crow::request& req) {
        try {
            auto request = nlohmann::json::parse(req.body);
            
            std::vector<std::string> filePaths = request["file_list"];
            std::string temporalResolution = request["temporal_resolution"];
            double requiredContinuity = request.value("required_continuity", 0.9);
            
            // æ‰§è¡Œè¿ç»­æ€§éªŒè¯
            auto result = eddyQueryService_->validateTimeContinuity(filePaths, temporalResolution);
            
            nlohmann::json response;
            response["status"] = "success";
            response["validation_result"] = result;
            response["meets_requirements"] = result.continuityRatio >= requiredContinuity;
            
            if (result.continuityRatio < requiredContinuity) {
                response["warnings"] = generateContinuityWarnings(result, requiredContinuity);
            }
            
            return crow::response(200, response.dump());
            
        } catch (const std::exception& e) {
            nlohmann::json error;
            error["status"] = "error";
            error["message"] = e.what();
            return crow::response(400, error.dump());
        }
    }

private:
    std::shared_ptr<EddyDataQueryService> eddyQueryService_;
};
```

### 4.2 å‰ç«¯é›†æˆç¤ºä¾‹

#### JavaScriptå‰ç«¯ä»£ç ç¤ºä¾‹
```javascript
// æ¶¡æµåˆ†ææ•°æ®æŸ¥è¯¢
class EddyDataManager {
    async queryEddyData(analysisConfig) {
        try {
            const response = await fetch('/api/eddy/data/query', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    analysis_time: analysisConfig.analysisTime,
                    analysis_region: analysisConfig.region,
                    time_window_hours: analysisConfig.timeWindow,
                    temporal_resolution: analysisConfig.temporalResolution,
                    max_spatial_resolution: analysisConfig.maxSpatialResolution,
                    min_continuity_ratio: analysisConfig.minContinuity,
                    min_data_quality: analysisConfig.minQuality,
                    required_variables: ['u', 'v', 'w'],
                    interpolation_config: {
                        allow_temporal: true,
                        allow_spatial: false,
                        method: 'linear'
                    }
                })
            });
            
            const result = await response.json();
            
            if (result.status === 'success') {
                // å¤„ç†æˆåŠŸå“åº”
                this.handleSuccessfulQuery(result.data);
                
                // æ˜¾ç¤ºè­¦å‘Šä¿¡æ¯
                if (result.data.warnings && result.data.warnings.length > 0) {
                    this.displayWarnings(result.data.warnings);
                }
                
                return result.data;
            } else {
                throw new Error(result.message);
            }
            
        } catch (error) {
            console.error('æ¶¡æµæ•°æ®æŸ¥è¯¢å¤±è´¥:', error);
            this.displayError('æ•°æ®æŸ¥è¯¢å¤±è´¥: ' + error.message);
            throw error;
        }
    }
    
    displayWarnings(warnings) {
        warnings.forEach(warning => {
            switch (warning.type) {
                case 'data_continuity':
                    this.showContinuityWarning(warning);
                    break;
                case 'resolution_mismatch':
                    this.showResolutionWarning(warning);
                    break;
                case 'data_quality':
                    this.showQualityWarning(warning);
                    break;
            }
        });
    }
    
    showContinuityWarning(warning) {
        const warningDiv = document.createElement('div');
        warningDiv.className = `alert alert-${warning.severity}`;
        warningDiv.innerHTML = `
            <h5>${warning.title}</h5>
            <p>æ•°æ®è¿ç»­æ€§: ${(warning.details.continuity_ratio * 100).toFixed(1)}%</p>
            <p>å‘ç° ${warning.details.gaps_found} ä¸ªæ•°æ®ç¼ºå£</p>
            <p>æœ€å¤§ç¼ºå£æŒç»­æ—¶é—´: ${warning.details.max_gap_duration} å°æ—¶</p>
            
            <div class="recommendations">
                <h6>å»ºè®®:</h6>
                <ul>
                    ${warning.recommendations.map(rec => `<li>${rec}</li>`).join('')}
                </ul>
            </div>
            
            <div class="actions">
                ${warning.actions.map(action => 
                    `<button class="btn btn-sm btn-outline-primary" 
                             onclick="this.executeAction('${action.type}', ${JSON.stringify(action.parameters)})">
                        ${action.label}
                     </button>`
                ).join('')}
            </div>
        `;
        
        document.getElementById('warnings-container').appendChild(warningDiv);
    }
    
    async executeAction(actionType, parameters) {
        switch (actionType) {
            case 'interpolate':
                await this.executeInterpolation(parameters);
                break;
            case 'find_alternative':
                await this.findAlternativeData(parameters);
                break;
        }
    }
    
    async executeInterpolation(parameters) {
        try {
            const response = await fetch('/api/data/interpolate', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(parameters)
            });
            
            const result = await response.json();
            
            if (result.status === 'success') {
                this.displaySuccess('æ•°æ®æ’å€¼å®Œæˆ');
                // é‡æ–°æŸ¥è¯¢æ•°æ®
                this.refreshData();
            } else {
                this.displayError('æ’å€¼å¤±è´¥: ' + result.message);
            }
            
        } catch (error) {
            this.displayError('æ’å€¼æ“ä½œå¤±è´¥: ' + error.message);
        }
    }
}
```

## éªŒæ”¶æ ‡å‡†ä¸æµ‹è¯•è®¡åˆ’

### åŠŸèƒ½éªŒæ”¶æ ‡å‡†
- [ ] **æ—¶é—´åˆ†è¾¨ç‡è¯†åˆ«å‡†ç¡®ç‡ > 98%**ï¼šè‡ªåŠ¨è¯†åˆ«å°æ—¶ã€æ—¥ã€æœˆç­‰æ—¶é—´åˆ†è¾¨ç‡
- [ ] **ç©ºé—´åˆ†è¾¨ç‡åˆ†ç±»å‡†ç¡®ç‡ > 95%**ï¼šæ­£ç¡®åˆ†ç±»é«˜ã€ä¸­ã€ä½åˆ†è¾¨ç‡ç­‰çº§
- [ ] **è¿ç»­æ€§æ£€æµ‹å‡†ç¡®ç‡ > 95%**ï¼šå‡†ç¡®è¯†åˆ«æ—¶é—´åºåˆ—ä¸­çš„æ•°æ®ç¼ºå£
- [ ] **è´¨é‡è¯„ä¼°ç›¸å…³æ€§ > 0.85**ï¼šè´¨é‡è¯„åˆ†ä¸äººå·¥è¯„ä¼°çš„ç›¸å…³æ€§
- [ ] **å‰ç«¯è­¦å‘ŠåŠæ—¶æ€§ < 2ç§’**ï¼šä»æŸ¥è¯¢åˆ°æ˜¾ç¤ºè­¦å‘Šä¿¡æ¯çš„å“åº”æ—¶é—´

### æ€§èƒ½éªŒæ”¶æ ‡å‡†
- [ ] **è¿ç»­æ€§æ£€æŸ¥æ€§èƒ½ < 10ç§’**ï¼šæ£€æŸ¥1å¹´æ•°æ®çš„è¿ç»­æ€§
- [ ] **è´¨é‡è¯„ä¼°æ€§èƒ½ < 30ç§’**ï¼šè¯„ä¼°å•ä¸ªå¤§æ–‡ä»¶(>1GB)çš„æ•°æ®è´¨é‡
- [ ] **æŸ¥è¯¢å“åº”æ€§èƒ½ < 3ç§’**ï¼šåŒ…å«è´¨é‡å’Œè¿ç»­æ€§è¿‡æ»¤çš„å¤æ‚æŸ¥è¯¢
- [ ] **æ’å€¼å»ºè®®ç”Ÿæˆ < 5ç§’**ï¼šåˆ†ææ•°æ®ç¼ºå£å¹¶ç”Ÿæˆæ’å€¼å»ºè®®

### å‡†ç¡®æ€§éªŒæ”¶æ ‡å‡†
- [ ] **æ•°æ®ç¼ºå£æ£€æµ‹æ— é—æ¼**ï¼šä¸èƒ½é—æ¼ä»»ä½•å®é™…å­˜åœ¨çš„æ•°æ®ç¼ºå£
- [ ] **æ’å€¼ç²¾åº¦é¢„ä¼°è¯¯å·® < 15%**ï¼šæ’å€¼ç²¾åº¦é¢„ä¼°ä¸å®é™…ç²¾åº¦çš„è¯¯å·®
- [ ] **åˆ†è¾¨ç‡åŒ¹é…å‡†ç¡®æ€§ > 98%**ï¼šæ­£ç¡®åŒ¹é…ç”¨æˆ·éœ€æ±‚ä¸å¯ç”¨æ•°æ®åˆ†è¾¨ç‡

## æ€»ç»“

è¿™ä¸ªå®æ–½è®¡åˆ’é‡ç‚¹è§£å†³äº†æ‚¨æå‡ºçš„æ ¸å¿ƒéœ€æ±‚ï¼š

1. **ç½‘æ ¼ç²¾åº¦ç®¡ç†**ï¼šé€šè¿‡ç©ºé—´åˆ†è¾¨ç‡ç­‰çº§è¡¨å’Œè‡ªåŠ¨åˆ†ç±»ç®—æ³•ï¼Œå®ç°ä¸åŒç²¾åº¦æ•°æ®çš„ç»Ÿä¸€ç®¡ç†
2. **æ—¶é—´åˆ†è¾¨ç‡ç»Ÿä¸€**ï¼šé€šè¿‡æ—¶é—´åˆ†è¾¨ç‡å®šä¹‰è¡¨å’Œæ™ºèƒ½åŒ¹é…ç®—æ³•ï¼Œç¡®ä¿åˆ†æä¸­ä½¿ç”¨ç›¸åŒæ—¶é—´åˆ†è¾¨ç‡çš„æ•°æ®
3. **æ•°æ®è¿ç»­æ€§ä¿è¯**ï¼šé€šè¿‡è¿ç»­æ€§æ£€æŸ¥ç®—æ³•å’Œç¼ºå£æ£€æµ‹ï¼Œè‡ªåŠ¨è¯†åˆ«æ—¶é—´åºåˆ—çš„ä¸è¿ç»­æ€§
4. **å‰ç«¯æç¤ºä¿¡æ¯**ï¼šé€šè¿‡è­¦å‘Šç”Ÿæˆå™¨å’Œç”¨æˆ·æ“ä½œå»ºè®®ï¼Œä¸ºç”¨æˆ·æä¾›æ¸…æ™°çš„æ•°æ®è´¨é‡å’Œè¿ç»­æ€§ä¿¡æ¯

è¿™ä¸ªç³»ç»Ÿå°†ä¸ºæ¶¡æµè¯†åˆ«ä¸è·Ÿè¸ªæä¾›å¯é çš„æ•°æ®åŸºç¡€è®¾æ–½ï¼Œç¡®ä¿åˆ†æç»“æœçš„å‡†ç¡®æ€§å’Œå¯é æ€§ã€‚ 

-- 6. å¢å¼ºdatasetsè¡¨ï¼Œæ·»åŠ æµ·æ´‹æ•°æ®ç±»å‹å…³è”
ALTER TABLE datasets ADD COLUMN ocean_data_type_id TEXT;
ALTER TABLE datasets ADD COLUMN cmems_product_id TEXT;
ALTER TABLE datasets ADD COLUMN data_provider TEXT DEFAULT 'CMEMS';
ALTER TABLE datasets ADD COLUMN processing_level TEXT;
ALTER TABLE datasets ADD COLUMN data_format TEXT DEFAULT 'NetCDF';
ALTER TABLE datasets ADD COLUMN update_frequency TEXT;
ALTER TABLE datasets ADD COLUMN geographic_coverage TEXT;

-- æ·»åŠ å¤–é”®çº¦æŸ
ALTER TABLE datasets ADD CONSTRAINT fk_datasets_ocean_data_type 
    FOREIGN KEY (ocean_data_type_id) REFERENCES ocean_data_types(type_id);

-- 7. åˆ›å»ºæ•°æ®ç±»å‹å…¼å®¹æ€§è¡¨
CREATE TABLE data_type_compatibility (
    compatibility_id TEXT PRIMARY KEY,     -- å…¼å®¹æ€§ID
    source_type_id TEXT NOT NULL,          -- æºæ•°æ®ç±»å‹
    target_type_id TEXT NOT NULL,          -- ç›®æ ‡æ•°æ®ç±»å‹
    compatibility_score REAL NOT NULL,     -- å…¼å®¹æ€§è¯„åˆ† (0-1)
    interpolation_method TEXT,             -- æ¨èæ’å€¼æ–¹æ³•
    interpolation_quality TEXT,            -- æ’å€¼è´¨é‡ (excellent, good, fair, poor)
    processing_cost INTEGER DEFAULT 1,     -- å¤„ç†æˆæœ¬ (1-10)
    notes TEXT,                            -- å¤‡æ³¨
    
    FOREIGN KEY (source_type_id) REFERENCES ocean_data_types(type_id),
    FOREIGN KEY (target_type_id) REFERENCES ocean_data_types(type_id)
);

-- æ’å…¥æ•°æ®ç±»å‹å…¼å®¹æ€§å®šä¹‰
INSERT INTO data_type_compatibility VALUES
-- æµ·æ´‹æµåœºå†…éƒ¨å…¼å®¹æ€§
('ocean_current_self', 'ocean_current', 'ocean_current', 1.0, 'bilinear', 'excellent', 1, 'åŒç±»å‹æ•°æ®å®Œå…¨å…¼å®¹'),

-- æµ·æ´‹æµåœºä¸å…¶ä»–ç‰©ç†æ•°æ®çš„å…¼å®¹æ€§
('ocean_current_to_ssh', 'ocean_current', 'sea_surface_height', 0.9, 'geostrophic', 'excellent', 3, 'å¯é€šè¿‡åœ°è½¬å…³ç³»ç›¸äº’è½¬æ¢'),
('ssh_to_ocean_current', 'sea_surface_height', 'ocean_current', 0.9, 'geostrophic', 'excellent', 3, 'å¯é€šè¿‡åœ°è½¬å…³ç³»è®¡ç®—æµåœº'),

-- æ¸©åº¦æ•°æ®å…¼å®¹æ€§
('sst_to_temp_sal', 'sea_surface_temperature', 'ocean_temperature_salinity', 0.8, 'vertical_extrapolation', 'good', 4, 'è¡¨é¢æ¸©åº¦å¯ç”¨äºçº¦æŸä¸‰ç»´æ¸©åº¦åœº'),
('temp_sal_to_sst', 'ocean_temperature_salinity', 'sea_surface_temperature', 1.0, 'surface_extraction', 'excellent', 1, 'ä¸‰ç»´æ¸©ç›åœºå¯ç›´æ¥æå–è¡¨é¢æ¸©åº¦'),

-- æµ·å†°æ•°æ®å…¼å®¹æ€§
('sea_ice_self', 'sea_ice', 'sea_ice', 1.0, 'bilinear', 'excellent', 1, 'æµ·å†°æ•°æ®å†…éƒ¨å®Œå…¨å…¼å®¹'),
('sea_ice_to_edge', 'sea_ice', 'sea_ice_edge', 0.95, 'edge_detection', 'excellent', 2, 'å¯ä»æµ·å†°æµ“åº¦è®¡ç®—è¾¹ç¼˜ä½ç½®'),

-- ç”Ÿç‰©åœ°çƒåŒ–å­¦æ•°æ®å…¼å®¹æ€§
('bgc_to_color', 'ocean_biogeochemistry', 'ocean_color', 0.7, 'bio_optical', 'good', 5, 'è¥å…»ç›å¯å½±å“æµ·æ´‹é¢œè‰²ï¼Œä½†å…³ç³»å¤æ‚'),
('color_to_bgc', 'ocean_color', 'ocean_biogeochemistry', 0.6, 'empirical', 'fair', 6, 'æµ·æ´‹é¢œè‰²å¯ä¼°ç®—éƒ¨åˆ†ç”ŸåŒ–å‚æ•°'),

-- åŒºåŸŸæ•°æ®å…¼å®¹æ€§
('global_to_arctic', 'ocean_current', 'arctic_ocean', 0.7, 'polar_adapted', 'fair', 5, 'å…¨çƒæ•°æ®åœ¨æåœ°åŒºåŸŸç²¾åº¦è¾ƒä½'),
('global_to_coastal', 'ocean_current', 'coastal_ocean', 0.6, 'coastal_adapted', 'fair', 6, 'å…¨çƒæ•°æ®åœ¨è¿‘å²¸åŒºåŸŸéœ€è¦ç‰¹æ®Šå¤„ç†'),

-- æµ·æ´‹å£°é€Ÿå…¼å®¹æ€§
('temp_sal_to_sound_speed', 'ocean_temperature_salinity', 'ocean_sound_speed', 0.95, 'acoustic_formula', 'excellent', 2, 'æ¸©ç›æ•°æ®å¯é€šè¿‡å£°å­¦å…¬å¼è®¡ç®—å£°é€Ÿ'),
('sound_speed_self', 'ocean_sound_speed', 'ocean_sound_speed', 1.0, 'bilinear', 'excellent', 1, 'å£°é€Ÿæ•°æ®å†…éƒ¨å®Œå…¨å…¼å®¹'),

-- æ¶¡æ—‹è¯†åˆ«å…¼å®¹æ€§
('current_to_eddies', 'ocean_current', 'ocean_eddies', 0.95, 'eddy_detection', 'excellent', 3, 'æµåœºæ•°æ®å¯ç”¨äºæ¶¡æ—‹è¯†åˆ«');

-- 8. åˆ›å»ºç›¸å…³ç´¢å¼•ä»¥ä¼˜åŒ–æŸ¥è¯¢æ€§èƒ½
CREATE INDEX idx_ocean_data_types_category ON ocean_data_types(category);
CREATE INDEX idx_ocean_data_types_subcategory ON ocean_data_types(subcategory);
CREATE INDEX idx_ocean_data_types_cmems_family ON ocean_data_types(cmems_product_family);
CREATE INDEX idx_ocean_data_types_spatial_coverage ON ocean_data_types(spatial_coverage);
CREATE INDEX idx_ocean_data_types_data_level ON ocean_data_types(data_level);

CREATE INDEX idx_datasets_ocean_data_type ON datasets(ocean_data_type_id);
CREATE INDEX idx_datasets_cmems_product ON datasets(cmems_product_id);
CREATE INDEX idx_datasets_provider ON datasets(data_provider);
CREATE INDEX idx_datasets_coverage ON datasets(geographic_coverage);

CREATE INDEX idx_compatibility_source ON data_type_compatibility(source_type_id);
CREATE INDEX idx_compatibility_target ON data_type_compatibility(target_type_id);
CREATE INDEX idx_compatibility_score ON data_type_compatibility(compatibility_score);

-- 9. åˆ›å»ºæ•°æ®ç±»å‹æŸ¥è¯¢è§†å›¾
CREATE VIEW v_ocean_data_summary AS
SELECT 
    odt.type_id,
    odt.type_name,
    odt.category,
    odt.subcategory,
    odt.cmems_product_family,
    odt.spatial_coverage,
    odt.data_level,
    COUNT(d.dataset_id) as dataset_count,
    MIN(d.time_start) as earliest_data,
    MAX(d.time_end) as latest_data,
    AVG(d.file_count) as avg_files_per_dataset,
    SUM(d.total_size_mb) as total_size_mb
FROM ocean_data_types odt
LEFT JOIN datasets d ON odt.type_id = d.ocean_data_type_id
GROUP BY odt.type_id, odt.type_name, odt.category, odt.subcategory, 
         odt.cmems_product_family, odt.spatial_coverage, odt.data_level;

-- 10. åˆ›å»ºæ•°æ®å…¼å®¹æ€§æŸ¥è¯¢è§†å›¾
CREATE VIEW v_data_compatibility_matrix AS
SELECT 
    s.type_name as source_type,
    s.category as source_category,
    t.type_name as target_type,
    t.category as target_category,
    c.compatibility_score,
    c.interpolation_method,
    c.interpolation_quality,
    c.processing_cost,
    c.notes
FROM data_type_compatibility c
JOIN ocean_data_types s ON c.source_type_id = s.type_id
JOIN ocean_data_types t ON c.target_type_id = t.type_id
ORDER BY c.compatibility_score DESC;

-- 11. ç¤ºä¾‹æŸ¥è¯¢ï¼šæŸ¥æ‰¾ç‰¹å®šç±»åˆ«çš„æ•°æ®ç±»å‹
-- æŸ¥è¯¢æ‰€æœ‰ç‰©ç†æµ·æ´‹å­¦æ•°æ®ç±»å‹
SELECT type_id, type_name, subcategory, cmems_product_family
FROM ocean_data_types 
WHERE category = 'physical'
ORDER BY type_name;

-- æŸ¥è¯¢å…¨çƒè¦†ç›–çš„L4çº§æ•°æ®
SELECT type_id, type_name, category, cmems_product_family
FROM ocean_data_types 
WHERE spatial_coverage = 'global' AND data_level = 'L4'
ORDER BY category, type_name;

-- æŸ¥è¯¢é€‚åˆæ’å€¼çš„æ•°æ®ç±»å‹
SELECT type_id, type_name, category, interpolation_suitable
FROM ocean_data_types 
WHERE interpolation_suitable = true
ORDER BY category, type_name;

-- 12. ç¤ºä¾‹æŸ¥è¯¢ï¼šæ•°æ®å…¼å®¹æ€§åˆ†æ
-- æŸ¥æ‰¾ä¸æµ·æ´‹æµåœºå…¼å®¹çš„æ•°æ®ç±»å‹
SELECT 
    target_type,
    compatibility_score,
    interpolation_method,
    interpolation_quality
FROM v_data_compatibility_matrix 
WHERE source_type = 'æµ·æ´‹æµåœº'
ORDER BY compatibility_score DESC;

-- æŸ¥æ‰¾é«˜å…¼å®¹æ€§çš„æ•°æ®ç±»å‹å¯¹
SELECT 
    source_type,
    target_type,
    compatibility_score,
    interpolation_quality
FROM v_data_compatibility_matrix 
WHERE compatibility_score >= 0.8
ORDER BY compatibility_score DESC;

-- 13. ç¤ºä¾‹æŸ¥è¯¢ï¼šæ•°æ®é›†ç»Ÿè®¡
-- æŒ‰æ•°æ®ç±»å‹ç»Ÿè®¡æ•°æ®é›†æ•°é‡
SELECT 
    type_name,
    category,
    dataset_count,
    total_size_mb,
    earliest_data,
    latest_data
FROM v_ocean_data_summary
WHERE dataset_count > 0
ORDER BY dataset_count DESC;

-- æŸ¥æ‰¾ç¼ºå°‘æ•°æ®çš„æ•°æ®ç±»å‹
SELECT 
    type_name,
    category,
    cmems_product_family
FROM v_ocean_data_summary
WHERE dataset_count = 0 OR dataset_count IS NULL
ORDER BY category, type_name; 