# 智能并行处理策略详细设计

## 0. 📚 架构关系说明 - 与Common模块底层功能的分层设计

### 0.1 功能分层关系

我们的智能并行处理策略是基于common_utilities中已有底层功能的**高级策略层**，不是重复实现，而是智能化封装和组合使用。

```
┌─────────────────────────────────────────────────────────────────┐
│                     🧠 智能策略层                               │
│                (本设计文档涵盖的内容)                           │
│  ┌─────────────────────┐ ┌─────────────────────┐ ┌─────────────┐ │
│  │ 格式感知并发协调器  │ │  文件特征分析器     │ │ 策略决策引擎│ │
│  │FormatSpecificConcur │ │ FileProfileAnalyzer │ │StrategyEngine│ │
│  │rencyCoordinator     │ │                     │ │             │ │
│  └─────────────────────┘ └─────────────────────┘ └─────────────┘ │
└─────────────────────────┬───────────────────────────────────────┘
                          │ 调用和组合 (不重复实现)
┌─────────────────────────┴───────────────────────────────────────┐
│                    🔧 Common底层功能层                          │
│                  (已实现的基础设施)                             │
│  ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────────┐ │
│  │UnifiedThreadPool│ │  AsyncFramework │ │CommonServicesFactory│ │
│  │    Manager      │ │                 │ │                     │ │
│  │                 │ │                 │ │                     │ │
│  │- submitTask()   │ │- submitTask()   │ │- getSIMDManager()   │ │
│  │- getPool()      │ │- parallel()     │ │- getMemoryManager() │ │
│  │- resize()       │ │- sequence()     │ │- getCacheManager()  │ │
│  └─────────────────┘ └─────────────────┘ └─────────────────────┘ │
│  ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────────┐ │
│  │ FileAccessLock  │ │ SIMD/Memory/    │ │  LargeFileProcessor │ │ 
│  │    Manager      │ │ Cache Managers  │ │                     │ │
│  └─────────────────┘ └─────────────────┘ └─────────────────────┘ │
└─────────────────────────────────────────────────────────────────┘
```

### 0.2 功能关系表

| 我们的设计 | Common中的实现 | 关系说明 |
|-----------|---------------|----------|
| **IntelligentParallelCoordinator** | `UnifiedThreadPoolManager` | 🎯 使用UTPM的底层线程池，添加智能决策 |
| **FileProfileAnalyzer** | `FileFormatDetector` | 🎯 基于FD的格式检测，添加性能特征分析 |
| **NetCDFConcurrencyOptimizer** | `AsyncFramework` | 🎯 使用AF的async能力，添加NetCDF特定策略 |
| **FormatAwareFileAccessManager** | `FileAccessLockManager` (data_access) | 🎯 扩展现有锁管理，添加格式感知 |
| **StrategyEngine** | `CommonServicesFactory` | 🎯 通过CSF获取所有底层服务，组合使用 |

### 0.3 **不重复实现的原则**

```cpp
/**
 * @brief 智能并行协调器 - 组合现有Common功能
 * 
 * ❌ 不会重新实现：
 * - 线程池管理 (使用 UnifiedThreadPoolManager)
 * - 异步任务提交 (使用 AsyncFramework) 
 * - SIMD操作 (使用 SIMDManager)
 * - 内存管理 (使用 MemoryManager)
 * - 缓存策略 (使用 CacheManager)
 * - 文件锁机制 (使用 FileAccessLockManager)
 * 
 * ✅ 我们的价值添加：
 * - 格式感知的智能决策
 * - 性能特征分析和策略选择
 * - 多组件协调优化
 * - 自适应参数调整
 */
class IntelligentParallelCoordinator {
public:
    IntelligentParallelCoordinator(
        // 依赖注入所有Common底层服务，不重新实现
        std::shared_ptr<CommonServicesFactory> commonServices)
        : commonServices_(commonServices) {
        
        // 🔧 从工厂获取所有底层服务
        threadPoolManager_ = commonServices_->getThreadPoolManager();
        asyncFramework_ = commonServices_->getAsyncFramework();
        simdManager_ = commonServices_->getSIMDManager();
        memoryManager_ = commonServices_->getMemoryManager();
        cacheManager_ = commonServices_->createCache<std::string, std::vector<double>>("parallel_cache");
        
        // 🎯 我们只添加智能决策逻辑，不重复实现底层功能
    }
    
    // 🎯 智能策略决策 - 我们的核心价值
    ParallelStrategy analyzeAndDecideStrategy(
        const std::vector<std::string>& filePaths,
        const std::string& operation) {
        
        // 利用现有FileFormatDetector分析文件格式
        std::vector<std::string> formats;
        for (const auto& path : filePaths) {
            formats.push_back(commonServices_->getFileFormatDetector()->detectFormat(path));
        }
        
        // 基于格式和操作类型做智能决策
        return decideOptimalStrategy(formats, operation);
    }
    
    // 🎯 智能任务分发 - 组合使用底层服务
    template<typename Func>
    auto executeIntelligentParallel(Func&& func, ParallelStrategy strategy) {
        switch (strategy) {
            case ParallelStrategy::NETCDF_VERTICAL_PARALLEL:
                // 使用AsyncFramework的parallel功能 + NetCDF特定优化
                return asyncFramework_->parallel(createNetCDFTasks(func));
                
            case ParallelStrategy::GDAL_BLOCK_PARALLEL:
                // 使用ThreadPoolManager的特定池 + GDAL安全策略
                return threadPoolManager_->submitTask(func, PoolType::IO_BOUND);
                
            default:
                return asyncFramework_->submitTask(func);
        }
    }

private:
    // 依赖注入，不重复实现
    std::shared_ptr<CommonServicesFactory> commonServices_;
    std::shared_ptr<UnifiedThreadPoolManager> threadPoolManager_;
    std::shared_ptr<AsyncFramework> asyncFramework_;
    // ... 其他服务引用
};
```

### 0.4 与data_access服务中并发组件的关系

```cpp
// data_access服务已有的FileAccessLockManager
namespace core_services::data_access {
    class FileAccessLockManagerImpl {
        // ✅ 已实现：基础文件锁功能
        std::unique_ptr<FileAccessGuard> createFileGuard(const std::string& filePath);
    };
}

// 🎯 我们的扩展：添加格式感知能力
class FormatAwareFileAccessManager : public FileAccessLockManagerImpl {
    // ✅ 继承基础锁功能，添加格式智能
    std::unique_ptr<FileAccessGuard> createFormatAwareGuard(
        const std::string& filePath, 
        const std::string& fileFormat) override {
        
        // 🎯 基于文件格式选择锁策略（我们的价值添加）
        FileAccessStrategy strategy = determineAccessStrategy(fileFormat);
        
        // 🔧 委托给基类的具体实现（不重复）
        return FileAccessLockManagerImpl::createFileGuard(filePath);
    }
};
```

## 1. 系统架构概览

基于项目现有的 `UnifiedThreadPoolManager`、`FileAccessLockManager` 和 `ReaderPoolManager`，设计了一套三层智能并行处理架构：

```
┌─────────────────────────────────────────────────────────────────┐
│                    智能并行处理协调器                           │
│                (IntelligentParallelCoordinator)                │
└─────────────────────────┬───────────────────────────────────────┘
                          │
┌─────────────────────────┴───────────────────────────────────────┐
│                     智能决策层                                 │
│ ┌─────────────────────┐ ┌─────────────────────┐ ┌─────────────────┐ │
│ │    文件特征分析器   │ │   资源状态监控器    │ │   策略决策引擎  │ │
│ │ FileProfileAnalyzer │ │ ResourceMonitor     │ │ StrategyEngine  │ │
│ └─────────────────────┘ └─────────────────────┘ └─────────────────┘ │
└─────────────────────────┬───────────────────────────────────────┘
                          │
┌─────────────────────────┴───────────────────────────────────────┐
│                    执行层 (基于现有组件)                       │
│ ┌─────────────────────┐ ┌─────────────────────┐ ┌─────────────────┐ │
│ │UnifiedThreadPool    │ │FileAccessLock       │ │ReaderPool       │ │
│ │Manager              │ │Manager              │ │Manager          │ │
│ └─────────────────────┘ └─────────────────────┘ └─────────────────┘ │
└─────────────────────────────────────────────────────────────────┘
```

## 2. 核心组件详细设计

### 2.1 智能并行处理协调器 (IntelligentParallelCoordinator)

```cpp
namespace oscean::workflow_engine::intelligent_parallel {

/**
 * @brief 智能并行处理协调器 - 系统核心调度器
 */
class IntelligentParallelCoordinator {
public:
    // === 基于现有代码的构造函数 ===
    IntelligentParallelCoordinator(
        std::shared_ptr<common_utils::infrastructure::UnifiedThreadPoolManager> threadPoolManager,
        std::shared_ptr<core_services::UnifiedDataAccessServiceImpl::FileAccessLockManager> lockManager,
        std::shared_ptr<core_services::UnifiedDataAccessServiceImpl::ReaderPoolManager> readerPoolManager
    );

    /**
     * @brief 智能任务分配与执行
     */
    struct IntelligentAllocationPlan {
        // 基于文件特征的分类
        std::vector<SingleThreadTask> singleThreadTasks;      // 必须单线程的任务
        std::vector<SharedReadTask> sharedReadTasks;          // 可共享读取的任务
        std::vector<ChunkedParallelTask> chunkedTasks;        // 大文件分块任务
        std::vector<StreamingTask> streamingTasks;            // 流式处理任务
        
        // 资源分配计划
        ThreadAllocationPlan threadAllocation;
        MemoryAllocationPlan memoryAllocation;
        IOSchedulePlan ioSchedule;
        
        // 执行时序
        ExecutionTimeline timeline;
        std::vector<ParallelGroup> parallelGroups;           // 可并行执行的任务组
        std::vector<DependencyChain> dependencyChains;      // 依赖链
    };

    /**
     * @brief 生成智能分配计划
     */
    boost::future<IntelligentAllocationPlan> generateAllocationPlanAsync(
        const std::vector<WorkflowTask>& tasks,
        const SystemResourceSnapshot& currentResources
    );

    /**
     * @brief 执行智能并行工作流
     */
    boost::future<WorkflowExecutionResult> executeIntelligentWorkflowAsync(
        const IntelligentAllocationPlan& plan,
        ProgressCallback progressCallback = nullptr
    );

private:
    // 核心组件
    std::unique_ptr<FileProfileAnalyzer> fileAnalyzer_;
    std::unique_ptr<ResourceMonitor> resourceMonitor_;
    std::unique_ptr<StrategyDecisionEngine> strategyEngine_;
    
    // 基于现有代码的服务
    std::shared_ptr<common_utils::infrastructure::UnifiedThreadPoolManager> threadPoolManager_;
    std::shared_ptr<core_services::UnifiedDataAccessServiceImpl::FileAccessLockManager> lockManager_;
    std::shared_ptr<core_services::UnifiedDataAccessServiceImpl::ReaderPoolManager> readerPoolManager_;
};

} // namespace
```

### 2.2 文件特征分析器 (FileProfileAnalyzer)

```cpp
/**
 * @brief 文件特征分析器 - 基于文件特征决定访问策略
 */
class FileProfileAnalyzer {
public:
    /**
     * @brief 文件访问特征分析
     */
    struct FileAccessProfile {
        // 基础属性
        std::string filePath;
        std::string fileFormat;           // NC, SHP, TIFF, etc.
        size_t fileSizeBytes;
        FileComplexity complexity;        // SIMPLE, MODERATE, COMPLEX, VERY_COMPLEX
        
        // 访问模式分析
        AccessPattern expectedPattern;    // SEQUENTIAL, RANDOM, MIXED
        size_t estimatedReadOps;         // 预期读取操作数
        size_t estimatedSeekOps;         // 预期寻址操作数
        
        // 并发适配性
        ConcurrencyCompatibility concurrencyType;
        bool supportsMultipleReaders;    // 是否支持多读取器
        bool requiresExclusiveAccess;    // 是否需要独占访问
        size_t optimalChunkSize;         // 最优分块大小
        
        // 性能预测
        std::chrono::milliseconds estimatedReadTime;
        double ioIntensityRatio;         // I/O密集度 (0.0-1.0)
        double cpuIntensityRatio;        // CPU密集度 (0.0-1.0)
        
        // 智能访问策略推荐
        RecommendedAccessStrategy strategy;
        ParallelismLevel recommendedParallelism;
        size_t recommendedThreadCount;
    };

    /**
     * @brief 分析文件访问特征 (核心方法)
     */
    boost::future<FileAccessProfile> analyzeFileAsync(const std::string& filePath);

    /**
     * @brief 批量文件特征分析
     */
    boost::future<std::vector<FileAccessProfile>> analyzeBatchAsync(
        const std::vector<std::string>& filePaths
    );

private:
    /**
     * @brief 基于文件格式的启发式分析
     */
    FileAccessProfile analyzeByFormat(const std::string& filePath, const std::string& format);
    
    /**
     * @brief 基于文件大小的策略推荐
     */
    RecommendedAccessStrategy recommendBySize(size_t fileSizeBytes, const std::string& format);
    
    /**
     * @brief 历史性能数据学习
     */
    void updatePerformanceModel(const FileAccessProfile& profile, 
                                const ActualPerformanceData& performance);

    // 性能预测模型
    std::unique_ptr<FilePerformancePredictor> performancePredictor_;
    
    // 缓存最近分析结果
    LRUCache<std::string, FileAccessProfile> analysisCache_;
    
    // 性能历史数据
    PerformanceHistoryDB performanceHistory_;
};
```

### 2.3 资源状态监控器 (ResourceMonitor)

```cpp
/**
 * @brief 系统资源状态监控器 - 实时监控系统资源状态
 */
class ResourceMonitor {
public:
    /**
     * @brief 系统资源快照
     */
    struct SystemResourceSnapshot {
        // CPU 状态
        struct CPUStatus {
            double utilizationPercent;           // CPU使用率
            size_t availableCores;              // 可用核心数
            std::vector<double> perCoreLoad;    // 每核负载
            double thermalThrottling;           // 热调节状态
        } cpu;
        
        // 内存状态
        struct MemoryStatus {
            size_t totalMemoryMB;               // 总内存
            size_t availableMemoryMB;           // 可用内存
            size_t buffersAndCacheMB;           // 缓冲区和缓存
            double swapUsagePercent;            // 交换空间使用率
            bool memoryPressure;                // 内存压力状态
        } memory;
        
        // I/O 状态 (基于现有代码)
        struct IOStatus {
            double diskReadMBps;                // 磁盘读取速度
            double diskWriteMBps;               // 磁盘写入速度
            double diskUtilizationPercent;     // 磁盘利用率
            size_t pendingIOOperations;        // 待处理I/O操作
            double averageIOLatencyMs;          // 平均I/O延迟
        } io;
        
        // 线程池状态 (基于 UnifiedThreadPoolManager)
        struct ThreadPoolStatus {
            std::map<common_utils::infrastructure::PoolType, 
                     common_utils::infrastructure::ThreadPoolStatistics> poolStats;
            double overallUtilization;         // 整体利用率
            size_t totalActiveThreads;         // 总活跃线程数
            size_t totalQueuedTasks;           // 总排队任务数
        } threadPools;
        
        // 文件访问状态 (基于 FileAccessLockManager)
        struct FileAccessStatus {
            size_t activeFileHandles;          // 活跃文件句柄数
            size_t queuedFileRequests;         // 排队文件请求数
            std::vector<std::string> contendedFiles; // 争用的文件列表
            double averageFileAccessTime;      // 平均文件访问时间
        } fileAccess;
        
        std::chrono::steady_clock::time_point timestamp;
    };

    /**
     * @brief 获取当前资源快照
     */
    boost::future<SystemResourceSnapshot> getCurrentSnapshotAsync();

    /**
     * @brief 启动持续监控
     */
    void startContinuousMonitoring(std::chrono::milliseconds interval = std::chrono::milliseconds(1000));

    /**
     * @brief 停止监控
     */
    void stopMonitoring();

    /**
     * @brief 获取资源变化趋势
     */
    ResourceTrend getResourceTrend(std::chrono::minutes duration) const;

    /**
     * @brief 资源容量评估
     */
    CapacityAssessment assessCurrentCapacity() const;

private:
    // 监控状态
    std::atomic<bool> monitoring_{false};
    std::thread monitoringThread_;
    
    // 资源历史数据
    CircularBuffer<SystemResourceSnapshot> resourceHistory_;
    static constexpr size_t MAX_HISTORY_SIZE = 1000;
    
    // 平台特定监控器
    #ifdef _WIN32
    std::unique_ptr<WindowsResourceMonitor> platformMonitor_;
    #else
    std::unique_ptr<LinuxResourceMonitor> platformMonitor_;
    #endif
    
    // 基于现有组件的集成
    std::weak_ptr<common_utils::infrastructure::UnifiedThreadPoolManager> threadPoolManager_;
    std::weak_ptr<core_services::UnifiedDataAccessServiceImpl::FileAccessLockManager> lockManager_;
};
```

### 2.4 策略决策引擎 (StrategyDecisionEngine)

```cpp
/**
 * @brief 策略决策引擎 - 基于文件特征和资源状态做出最优决策
 */
class StrategyDecisionEngine {
public:
    /**
     * @brief 并行处理策略
     */
    enum class ParallelStrategy {
        SINGLE_THREADED,        // 单线程 (小文件或需要独占访问)
        MULTI_READER_SHARED,    // 多读取器共享 (支持并发读取的格式)
        CHUNKED_PARALLEL,       // 分块并行 (大文件分块处理)
        STREAMING_PIPELINE,     // 流水线处理 (超大文件流式处理)
        HYBRID_ADAPTIVE         // 混合自适应 (根据运行时状态动态调整)
    };

    /**
     * @brief 决策结果
     */
    struct StrategyDecision {
        ParallelStrategy primaryStrategy;
        ParallelStrategy fallbackStrategy;        // 备用策略
        
        // 执行参数
        size_t recommendedThreadCount;
        size_t maxConcurrentFiles;
        size_t chunkSizeBytes;
        size_t bufferSizeBytes;
        
        // 资源限制
        size_t maxMemoryUsageMB;
        double maxCPUUtilization;
        double maxIOUtilization;
        
        // 时序控制
        std::chrono::milliseconds taskStartDelay;
        std::chrono::milliseconds resourceCheckInterval;
        
        // 自适应参数
        bool enableDynamicAdjustment;
        std::vector<AdaptationTrigger> adaptationTriggers;
        
        // 预期性能
        EstimatedPerformance expectedPerformance;
        
        // 决策置信度
        double confidence;                        // 决策置信度 [0.0, 1.0]
        std::string rationale;                   // 决策理由
    };

    /**
     * @brief 核心决策方法
     */
    boost::future<StrategyDecision> makeDecisionAsync(
        const std::vector<FileProfileAnalyzer::FileAccessProfile>& fileProfiles,
        const ResourceMonitor::SystemResourceSnapshot& resourceSnapshot,
        const WorkflowObjectives& objectives
    );

    /**
     * @brief 运行时策略调整
     */
    boost::future<StrategyAdjustment> adjustStrategyAsync(
        const StrategyDecision& currentStrategy,
        const RuntimePerformanceData& performanceData,
        const ResourceMonitor::SystemResourceSnapshot& newResourceSnapshot
    );

private:
    /**
     * @brief 决策算法组合
     */
    
    // 1. 基于规则的快速决策
    StrategyDecision makeRuleBasedDecision(
        const std::vector<FileProfileAnalyzer::FileAccessProfile>& profiles,
        const ResourceMonitor::SystemResourceSnapshot& resources
    );
    
    // 2. 基于历史性能的学习决策
    StrategyDecision makeLearningBasedDecision(
        const std::vector<FileProfileAnalyzer::FileAccessProfile>& profiles,
        const ResourceMonitor::SystemResourceSnapshot& resources
    );
    
    // 3. 基于优化算法的精细决策
    StrategyDecision makeOptimizationBasedDecision(
        const std::vector<FileProfileAnalyzer::FileAccessProfile>& profiles,
        const ResourceMonitor::SystemResourceSnapshot& resources,
        const WorkflowObjectives& objectives
    );
    
    /**
     * @brief 资源约束检查
     */
    bool validateResourceConstraints(
        const StrategyDecision& decision,
        const ResourceMonitor::SystemResourceSnapshot& resources
    );
    
    /**
     * @brief 决策融合算法
     */
    StrategyDecision fuseDecisions(
        const std::vector<StrategyDecision>& candidateDecisions
    );

    // 决策组件
    std::unique_ptr<RuleBasedDecisionMaker> ruleEngine_;
    std::unique_ptr<MachineLearningDecisionMaker> mlEngine_;
    std::unique_ptr<OptimizationDecisionMaker> optimizationEngine_;
    
    // 性能历史和学习
    PerformanceDatabase performanceDB_;
    std::unique_ptr<AdaptiveLearningModel> learningModel_;
};
```

## 3. 智能文件访问策略实现

### 3.1 基于现有 FileAccessLockManager 的智能锁定

```cpp
/**
 * @brief 智能文件访问管理器 (扩展现有实现)
 */
class IntelligentFileAccessManager {
public:
    /**
     * @brief 智能文件访问守卫 (基于现有 FileAccessGuard)
     */
    class IntelligentFileAccessGuard {
    public:
        IntelligentFileAccessGuard(
            const std::string& filePath,
            const FileProfileAnalyzer::FileAccessProfile& profile,
            std::shared_ptr<core_services::UnifiedDataAccessServiceImpl::FileAccessLockManager> lockManager
        );
        
        ~IntelligentFileAccessGuard();
        
        /**
         * @brief 动态调整访问策略
         */
        void adjustAccessStrategy(const StrategyDecisionEngine::StrategyDecision& newStrategy);
        
        /**
         * @brief 获取访问性能统计
         */
        FileAccessPerformanceStats getPerformanceStats() const;

    private:
        std::string filePath_;
        FileProfileAnalyzer::FileAccessProfile profile_;
        std::unique_ptr<core_services::UnifiedDataAccessServiceImpl::FileAccessGuard> baseGuard_;
        std::chrono::steady_clock::time_point startTime_;
        std::atomic<size_t> accessCount_{0};
    };

    /**
     * @brief 创建智能文件访问守卫
     */
    std::unique_ptr<IntelligentFileAccessGuard> createIntelligentGuard(
        const std::string& filePath,
        const FileProfileAnalyzer::FileAccessProfile& profile
    );

    /**
     * @brief 批量文件访问优化
     */
    struct BatchAccessPlan {
        std::vector<std::string> sequentialFiles;    // 顺序访问文件
        std::vector<std::string> parallelFiles;      // 可并行访问文件
        std::vector<std::pair<std::string, size_t>> delayedFiles; // 延迟访问文件及延迟时间
        std::map<std::string, size_t> resourceReservation; // 资源预留
    };

    /**
     * @brief 生成批量访问计划
     */
    boost::future<BatchAccessPlan> generateBatchAccessPlanAsync(
        const std::vector<std::string>& filePaths,
        const ResourceMonitor::SystemResourceSnapshot& resources
    );

private:
    std::shared_ptr<core_services::UnifiedDataAccessServiceImpl::FileAccessLockManager> baseLockManager_;
    std::shared_ptr<FileProfileAnalyzer> fileAnalyzer_;
    std::shared_ptr<ResourceMonitor> resourceMonitor_;
    
    // 文件访问历史和统计
    std::unordered_map<std::string, FileAccessPerformanceStats> accessHistory_;
    mutable std::shared_mutex historyMutex_;
};
```

### 3.2 智能线程池调度 (基于现有 UnifiedThreadPoolManager)

```cpp
/**
 * @brief 智能线程池调度器 (扩展现有实现)
 */
class IntelligentThreadPoolScheduler {
public:
    /**
     * @brief 构造函数 - 基于现有组件
     */
    IntelligentThreadPoolScheduler(
        std::shared_ptr<common_utils::infrastructure::UnifiedThreadPoolManager> threadPoolManager
    );

    /**
     * @brief 智能任务调度
     */
    template<typename TaskType>
    boost::future<void> scheduleIntelligentTask(
        TaskType&& task,
        const FileProfileAnalyzer::FileAccessProfile& fileProfile,
        const StrategyDecisionEngine::StrategyDecision& strategy
    ) {
        // 根据文件特征和策略选择最优线程池
        auto poolType = selectOptimalPoolType(fileProfile, strategy);
        
        // 检查线程池状态
        auto poolStats = threadPoolManager_->getPoolStatistics(poolType);
        
        // 如果负载过高，考虑降级或延迟
        if (poolStats.utilizationRatio > strategy.maxCPUUtilization) {
            return scheduleWithLoadBalancing(std::forward<TaskType>(task), poolType, strategy);
        }
        
        // 正常调度
        return threadPoolManager_->submitTask(poolType, std::forward<TaskType>(task));
    }

    /**
     * @brief 动态线程池调整
     */
    void adjustThreadPoolSizes(const ResourceMonitor::SystemResourceSnapshot& resources);

    /**
     * @brief 负载均衡调度
     */
    template<typename TaskType>
    boost::future<void> scheduleWithLoadBalancing(
        TaskType&& task,
        common_utils::infrastructure::PoolType primaryPool,
        const StrategyDecisionEngine::StrategyDecision& strategy
    );

private:
    /**
     * @brief 基于文件特征选择最优线程池
     */
    common_utils::infrastructure::PoolType selectOptimalPoolType(
        const FileProfileAnalyzer::FileAccessProfile& profile,
        const StrategyDecisionEngine::StrategyDecision& strategy
    );

    /**
     * @brief 线程池性能预测
     */
    std::chrono::milliseconds predictExecutionTime(
        const FileProfileAnalyzer::FileAccessProfile& profile,
        common_utils::infrastructure::PoolType poolType
    );

    std::shared_ptr<common_utils::infrastructure::UnifiedThreadPoolManager> threadPoolManager_;
    
    // 调度历史和性能预测
    SchedulePerformancePredictor performancePredictor_;
    LoadBalancingStats loadStats_;
};
```

## 4. 智能读取器池管理 (基于现有 ReaderPoolManager)

```cpp
/**
 * @brief 智能读取器池管理器 (扩展现有实现)
 */
class IntelligentReaderPoolManager {
public:
    /**
     * @brief 构造函数 - 基于现有组件
     */
    IntelligentReaderPoolManager(
        std::shared_ptr<core_services::UnifiedDataAccessServiceImpl::ReaderPoolManager> baseManager
    );

    /**
     * @brief 智能读取器获取
     */
    boost::future<std::shared_ptr<core_services::data_access::readers::UnifiedDataReader>>
    getIntelligentReaderAsync(
        const std::string& filePath,
        const std::string& readerType,
        const FileProfileAnalyzer::FileAccessProfile& profile,
        const StrategyDecisionEngine::StrategyDecision& strategy
    );

    /**
     * @brief 动态池大小调整
     */
    void adjustPoolSizes(
        const std::map<std::string, size_t>& formatUsageStats,
        const ResourceMonitor::SystemResourceSnapshot& resources
    );

    /**
     * @brief 预热常用读取器
     */
    boost::future<void> preWarmReadersAsync(
        const std::vector<std::pair<std::string, std::string>>& frequentFormats
    );

private:
    /**
     * @brief 读取器创建策略
     */
    enum class ReaderCreationStrategy {
        IMMEDIATE,           // 立即创建
        LAZY,               // 延迟创建
        BATCH,              // 批量创建
        PREDICTIVE          // 预测性创建
    };

    /**
     * @brief 选择读取器创建策略
     */
    ReaderCreationStrategy selectCreationStrategy(
        const FileProfileAnalyzer::FileAccessProfile& profile,
        const ResourceMonitor::SystemResourceSnapshot& resources
    );

    std::shared_ptr<core_services::UnifiedDataAccessServiceImpl::ReaderPoolManager> baseManager_;
    
    // 智能预测和统计
    ReaderUsagePredictor usagePredictor_;
    std::unordered_map<std::string, ReaderPerformanceStats> readerStats_;
};
```

## 5. 运行时自适应调整

### 5.1 自适应监控与调整

```cpp
/**
 * @brief 运行时自适应调整器
 */
class RuntimeAdaptiveAdjuster {
public:
    /**
     * @brief 启动自适应监控
     */
    void startAdaptiveMonitoring(
        std::chrono::milliseconds checkInterval = std::chrono::milliseconds(5000)
    );

    /**
     * @brief 实时性能反馈
     */
    void reportPerformanceFeedback(
        const std::string& taskId,
        const ActualPerformanceData& performance
    );

    /**
     * @brief 触发策略调整
     */
    void triggerStrategyAdjustment(
        const std::string& reason,
        const AdjustmentParameters& params
    );

private:
    /**
     * @brief 自适应调整循环
     */
    void adaptiveAdjustmentLoop();

    /**
     * @brief 检测性能异常
     */
    bool detectPerformanceAnomaly(const ActualPerformanceData& performance);

    std::atomic<bool> monitoring_{false};
    std::thread adaptiveThread_;
    
    // 性能反馈收集
    ThreadSafeQueue<PerformanceFeedback> feedbackQueue_;
    
    // 调整历史
    std::vector<AdjustmentRecord> adjustmentHistory_;
};
```

## 6. 配置和使用示例

### 6.1 智能并行处理配置

```json
{
  "intelligent_parallel_config": {
    "name": "IntelligentParallelProcessing",
    "version": "1.0",
    
    "file_analysis": {
      "enable_deep_profiling": true,
      "cache_analysis_results": true,
      "cache_ttl_minutes": 60,
      "performance_prediction": {
        "enable_ml_prediction": true,
        "model_update_interval_hours": 24,
        "confidence_threshold": 0.8
      }
    },
    
    "resource_monitoring": {
      "monitoring_interval_ms": 1000,
      "history_retention_minutes": 60,
      "enable_predictive_scaling": true,
      "thresholds": {
        "cpu_high_utilization": 0.8,
        "memory_pressure": 0.85,
        "io_saturation": 0.9
      }
    },
    
    "strategy_engine": {
      "decision_algorithms": ["rule_based", "ml_based", "optimization"],
      "decision_fusion_method": "weighted_voting",
      "enable_runtime_adjustment": true,
      "adjustment_sensitivity": 0.15
    },
    
    "parallel_execution": {
      "max_concurrent_files": "auto",
      "chunk_size_strategy": "adaptive",
      "thread_allocation": {
        "cpu_intensive_ratio": 0.4,
        "io_bound_ratio": 0.4,
        "background_ratio": 0.2
      },
      "fallback_strategies": {
        "memory_pressure": "reduce_parallelism",
        "cpu_overload": "increase_chunk_size",
        "io_bottleneck": "sequential_fallback"
      }
    }
  }
}
```

### 6.2 使用示例

```cpp
// 初始化智能并行处理器
auto coordinator = std::make_shared<IntelligentParallelCoordinator>(
    threadPoolManager,  // 现有的线程池管理器
    lockManager,       // 现有的文件锁管理器
    readerPoolManager  // 现有的读取器池管理器
);

// 创建工作流任务
std::vector<WorkflowTask> tasks = {
    {"/data/large_file1.nc", "temperature", QueryCriteria{...}},
    {"/data/large_file2.nc", "salinity", QueryCriteria{...}},
    {"/data/shapefile.shp", "boundaries", QueryCriteria{...}}
};

// 生成智能分配计划
auto plan = coordinator->generateAllocationPlanAsync(tasks, currentResources).get();

// 执行智能并行工作流
auto result = coordinator->executeIntelligentWorkflowAsync(
    plan, 
    [](const WorkflowProgress& progress) {
        std::cout << "Progress: " << progress.completionPercent << "%" << std::endl;
    }
).get();

// 分析执行结果
if (result.success) {
    std::cout << "Workflow completed successfully" << std::endl;
    std::cout << "Performance metrics: " << result.metrics.toString() << std::endl;
} else {
    std::cout << "Workflow failed: " << result.errorMessage << std::endl;
}
```

## 7. 性能优化关键点

### 7.1 零锁路径优化
- 对于小文件和缓存命中，提供无锁快速路径
- 使用原子操作减少锁竞争
- 读写分离的数据结构设计

### 7.2 内存优化
- 基于现有 `MemoryPoolConfig` 的智能内存分配
- 数据对齐和缓存行优化
- 大文件的流式处理避免内存压力

### 7.3 I/O优化
- 基于文件系统特征的I/O调度
- 批量I/O操作合并
- 异步I/O与计算的流水线重叠

### 7.4 自适应学习
- 性能数据的实时收集和分析
- 机器学习模型的在线更新
- 用户场景的自动优化

这个设计充分利用了项目现有的基础设施，通过智能决策层的添加，实现了真正的智能化并行处理。所有的设计都考虑了与现有代码的兼容性和扩展性。

## 5. 文件格式特定优化策略

基于代码分析，项目已实现了高级的NetCDF和GDAL读取器，现在设计针对不同文件格式的专门优化策略。

### 5.1 NetCDF格式优化策略

#### 5.1.1 NetCDF并发特性分析

```cpp
/**
 * @brief NetCDF格式并发特性配置
 * 基于 NetCDFAdvancedReader 的现有实现
 */
struct NetCDFConcurrencyProfile {
    // 基于现有NetCDFAdvancedConfig的扩展
    size_t maxConcurrentReads = 8;           // 从现有配置继承
    size_t chunkCacheSize = 256 * 1024 * 1024; // 256MB块缓存
    bool supportsConcurrentRead = true;       // NetCDF-4支持并发读取
    bool requiresThreadSafety = false;       // NetCDF-4库本身是线程安全的
    size_t optimalChunkSize = 64 * 1024;     // 流式处理块大小
    
    // NetCDF特定的并发优化参数
    bool enableVariableCache = true;         // 启用变量缓存
    bool enableTimeOptimization = true;      // 启用时间维度优化
    bool enableStreamingMode = false;        // 大文件启用流式处理
    size_t memoryThresholdMB = 512;         // 启用流式模式的内存阈值
    
    // 垂直层处理优化
    bool enableVerticalParallel = true;      // 启用垂直层并行读取
    size_t maxVerticalThreads = 4;          // 垂直层最大并行线程数
    size_t verticalChunkSize = 10;          // 垂直层分块大小
};
```

#### 5.1.2 NetCDF智能并发策略

```cpp
/**
 * @brief NetCDF智能并发处理器
 * 基于现有NetCDFAdvancedReader实现的优化策略
 */
class NetCDFConcurrencyOptimizer {
public:
    enum class ReadStrategy {
        SINGLE_THREADED,        // 小文件或NetCDF-3格式
        CONCURRENT_VARIABLES,   // 多变量并发读取
        CONCURRENT_CHUNKS,      // 大变量分块并发读取
        STREAMING_MODE,         // 超大文件流式处理
        VERTICAL_PARALLEL       // 垂直层并行读取
    };
    
    /**
     * @brief 分析NetCDF文件特征并确定最优策略
     */
    ReadStrategy analyzeNetCDFFile(const std::string& filePath) {
        // 利用现有的 NetCDFAdvancedReader::getFileMetadataAsync
        auto metadata = getNetCDFMetadata(filePath);
        
        // 文件大小判断
        if (metadata.fileSize < 50 * 1024 * 1024) {  // 50MB以下
            return ReadStrategy::SINGLE_THREADED;
        }
        
        // NetCDF版本判断
        if (metadata.netcdfVersion == 3) {
            return ReadStrategy::SINGLE_THREADED;  // NetCDF-3不支持并发
        }
        
        // 变量数量判断
        if (metadata.variableCount > 5 && metadata.avgVariableSize < 100 * 1024 * 1024) {
            return ReadStrategy::CONCURRENT_VARIABLES;
        }
        
        // 垂直层数判断
        if (metadata.verticalLevels > 10) {
            return ReadStrategy::VERTICAL_PARALLEL;
        }
        
        // 单变量大小判断
        if (metadata.maxVariableSize > 500 * 1024 * 1024) {
            return ReadStrategy::STREAMING_MODE;
        }
        
        return ReadStrategy::CONCURRENT_CHUNKS;
    }
    
    /**
     * @brief 执行NetCDF并发读取
     */
    boost::future<std::shared_ptr<GridData>> executeNetCDFRead(
        const std::string& filePath,
        const std::string& variableName,
        const ReadStrategy strategy,
        const std::optional<BoundingBox>& bounds = std::nullopt) {
        
        switch (strategy) {
            case ReadStrategy::SINGLE_THREADED:
                return executeSingleThreadedRead(filePath, variableName, bounds);
                
            case ReadStrategy::CONCURRENT_VARIABLES:
                return executeConcurrentVariablesRead(filePath, variableName, bounds);
                
            case ReadStrategy::CONCURRENT_CHUNKS:
                return executeConcurrentChunksRead(filePath, variableName, bounds);
                
            case ReadStrategy::STREAMING_MODE:
                return executeStreamingRead(filePath, variableName, bounds);
                
            case ReadStrategy::VERTICAL_PARALLEL:
                return executeVerticalParallelRead(filePath, variableName, bounds);
                
            default:
                return executeSingleThreadedRead(filePath, variableName, bounds);
        }
    }

private:
    /**
     * @brief 垂直层并行读取实现
     * 利用现有的 NetCDFAdvancedReader::getVerticalLevelsAsync
     */
    boost::future<std::shared_ptr<GridData>> executeVerticalParallelRead(
        const std::string& filePath,
        const std::string& variableName,
        const std::optional<BoundingBox>& bounds) {
        
        return boost::async(boost::launch::async, [=]() {
            auto reader = std::make_shared<NetCDFAdvancedReader>(filePath, commonServices_);
            auto verticalLevels = reader->getVerticalLevelsAsync().get();
            
            if (verticalLevels.empty()) {
                // 无垂直层，回退到标准读取
                return reader->readGridDataAsync(variableName, bounds).get();
            }
            
            // 计算并行策略
            size_t numLevels = verticalLevels.size();
            size_t numThreads = std::min(config_.maxVerticalThreads, 
                                       (numLevels + config_.verticalChunkSize - 1) / config_.verticalChunkSize);
            
            std::vector<boost::future<std::vector<double>>> levelFutures;
            
            // 为每个垂直层组启动并行读取任务
            for (size_t i = 0; i < numLevels; i += config_.verticalChunkSize) {
                size_t endLevel = std::min(i + config_.verticalChunkSize, numLevels);
                
                levelFutures.push_back(boost::async(boost::launch::async, [=]() {
                    return readVerticalChunk(reader, variableName, i, endLevel, bounds);
                }));
            }
            
            // 合并结果
            return mergeVerticalResults(levelFutures, verticalLevels);
        });
    }
    
    NetCDFConcurrencyProfile config_;
    std::shared_ptr<CommonServicesFactory> commonServices_;
};
```

### 5.2 GDAL格式优化策略

#### 5.2.1 GDAL并发特性分析

```cpp
/**
 * @brief GDAL格式并发特性配置
 * 基于 GdalRasterReader 的现有实现
 */
struct GDALConcurrencyProfile {
    // GDAL特定的并发限制
    bool isThreadSafe = false;              // GDAL默认不是线程安全的
    bool supportsBlockReading = true;       // 支持块读取
    bool requiresGlobalLock = true;         // 需要全局锁保护
    size_t optimalBlockSize = 512;          // 最优块大小
    
    // 格式特定配置
    std::unordered_map<std::string, bool> formatThreadSafety = {
        {"GEOTIFF", true},     // GeoTIFF相对安全
        {"HDF5", false},       // HDF5需要特殊处理
        {"GRIB", false},       // GRIB格式不支持并发
        {"SHAPEFILE", false}   // Shapefile需要文件锁
    };
    
    // 内存和性能配置
    size_t maxMemoryUsageMB = 1024;        // 最大内存使用
    bool enableSIMDOptimization = true;     // 启用SIMD优化
    size_t simdAlignment = 32;             // SIMD对齐大小
};
```

#### 5.2.2 GDAL智能并发策略

```cpp
/**
 * @brief GDAL智能并发处理器
 * 基于现有GdalRasterReader和GdalVectorReader实现
 */
class GDALConcurrencyOptimizer {
public:
    enum class GDALStrategy {
        SINGLE_FILE_LOCK,       // 整个文件加锁，单线程访问
        BLOCK_PARALLEL,         // 空间分块并行读取
        BAND_PARALLEL,          // 多波段并行读取
        REGION_PARALLEL,        // 区域并行读取
        STREAMING_BLOCKS        // 流式块读取
    };
    
    /**
     * @brief 分析GDAL文件特征并确定策略
     */
    GDALStrategy analyzeGDALFile(const std::string& filePath) {
        auto metadata = getGDALMetadata(filePath);
        
        // 检查格式线程安全性
        std::string format = metadata.driverName;
        if (!config_.formatThreadSafety[format]) {
            return GDALStrategy::SINGLE_FILE_LOCK;
        }
        
        // 文件大小判断
        if (metadata.fileSize < 100 * 1024 * 1024) {  // 100MB以下
            return GDALStrategy::SINGLE_FILE_LOCK;
        }
        
        // 多波段判断
        if (metadata.bandCount > 3) {
            return GDALStrategy::BAND_PARALLEL;
        }
        
        // 大文件分块判断
        if (metadata.width * metadata.height > 10000 * 10000) {
            return GDALStrategy::BLOCK_PARALLEL;
        }
        
        return GDALStrategy::REGION_PARALLEL;
    }
    
    /**
     * @brief 执行GDAL安全并发读取
     */
    boost::future<std::shared_ptr<GridData>> executeGDALRead(
        const std::string& filePath,
        const GDALStrategy strategy,
        const std::optional<BoundingBox>& bounds = std::nullopt) {
        
        switch (strategy) {
            case GDALStrategy::SINGLE_FILE_LOCK:
                return executeSingleFileLockRead(filePath, bounds);
                
            case GDALStrategy::BLOCK_PARALLEL:
                return executeBlockParallelRead(filePath, bounds);
                
            case GDALStrategy::BAND_PARALLEL:
                return executeBandParallelRead(filePath, bounds);
                
            case GDALStrategy::REGION_PARALLEL:
                return executeRegionParallelRead(filePath, bounds);
                
            case GDALStrategy::STREAMING_BLOCKS:
                return executeStreamingBlocksRead(filePath, bounds);
                
            default:
                return executeSingleFileLockRead(filePath, bounds);
        }
    }

private:
    /**
     * @brief 单文件锁定读取
     * 利用现有的 FileAccessLockManager
     */
    boost::future<std::shared_ptr<GridData>> executeSingleFileLockRead(
        const std::string& filePath,
        const std::optional<BoundingBox>& bounds) {
        
        return boost::async(boost::launch::async, [=]() {
            // 使用现有的文件访问锁管理器
            auto fileGuard = lockManager_->createFileGuard(filePath);
            
            // 创建GDAL读取器（现有实现）
            auto reader = std::make_shared<GdalRasterReader>(filePath, commonServices_);
            
            // 执行读取
            return reader->readGridDataAsync("", bounds).get();
        });
    }
    
    /**
     * @brief 块并行读取实现
     * 利用GDAL的块读取特性
     */
    boost::future<std::shared_ptr<GridData>> executeBlockParallelRead(
        const std::string& filePath,
        const std::optional<BoundingBox>& bounds) {
        
        return boost::async(boost::launch::async, [=]() {
            auto reader = std::make_shared<GdalRasterReader>(filePath, commonServices_);
            auto metadata = reader->getFileMetadataAsync().get();
            
            if (!metadata) {
                throw std::runtime_error("无法获取GDAL文件元数据");
            }
            
            // 计算最优块分割策略
            auto blockStrategy = calculateBlockStrategy(*metadata, bounds);
            
            std::vector<boost::future<std::vector<double>>> blockFutures;
            
            // 为每个块启动并行读取任务
            for (const auto& block : blockStrategy.blocks) {
                blockFutures.push_back(boost::async(boost::launch::async, [=]() {
                    // 使用独立的文件句柄避免冲突
                    auto blockReader = std::make_shared<GdalRasterReader>(filePath, commonServices_);
                    return readGDALBlock(blockReader, block);
                }));
            }
            
            // 合并块结果
            return mergeBlockResults(blockFutures, blockStrategy);
        });
    }
    
    GDALConcurrencyProfile config_;
    std::shared_ptr<FileAccessLockManagerImpl> lockManager_;
    std::shared_ptr<CommonServicesFactory> commonServices_;
};
```

### 5.3 格式特定文件访问策略

#### 5.3.1 智能文件锁管理器扩展

```cpp
/**
 * @brief 格式感知的文件访问管理器
 * 扩展现有的 FileAccessLockManagerImpl
 */
class FormatAwareFileAccessManager : public FileAccessLockManagerImpl {
public:
    /**
     * @brief 格式特定的文件访问策略
     */
    enum class FileAccessStrategy {
        EXCLUSIVE_LOCK,         // 独占锁（如Shapefile）
        SHARED_READ_LOCK,       // 共享读锁（如NetCDF-4）
        NO_LOCK_REQUIRED,       // 无锁（如只读GeoTIFF）
        SEQUENTIAL_ACCESS,      // 顺序访问（如GRIB）
        BLOCK_LEVEL_LOCK       // 块级锁（如大型HDF5）
    };
    
    /**
     * @brief 根据文件格式创建适当的文件保护
     */
    std::unique_ptr<FileAccessGuard> createFormatAwareGuard(
        const std::string& filePath, 
        const std::string& fileFormat) override {
        
        FileAccessStrategy strategy = determineAccessStrategy(fileFormat);
        
        switch (strategy) {
            case FileAccessStrategy::EXCLUSIVE_LOCK:
                return createExclusiveGuard(filePath);
                
            case FileAccessStrategy::SHARED_READ_LOCK:
                return createSharedGuard(filePath);
                
            case FileAccessStrategy::NO_LOCK_REQUIRED:
                return createNoLockGuard(filePath);
                
            case FileAccessStrategy::SEQUENTIAL_ACCESS:
                return createSequentialGuard(filePath);
                
            case FileAccessStrategy::BLOCK_LEVEL_LOCK:
                return createBlockLevelGuard(filePath);
                
            default:
                return createSharedGuard(filePath);
        }
    }

private:
    FileAccessStrategy determineAccessStrategy(const std::string& format) const {
        static const std::unordered_map<std::string, FileAccessStrategy> formatStrategies = {
            // NetCDF格式 - 支持并发读取
            {"NETCDF", FileAccessStrategy::SHARED_READ_LOCK},
            {"NC", FileAccessStrategy::SHARED_READ_LOCK},
            {"NC4", FileAccessStrategy::SHARED_READ_LOCK},
            
            // Shapefile - 需要独占访问
            {"SHAPEFILE", FileAccessStrategy::EXCLUSIVE_LOCK},
            
            // GeoTIFF - 通常安全并发
            {"GEOTIFF", FileAccessStrategy::SHARED_READ_LOCK},
            
            // HDF5 - 取决于具体实现
            {"HDF5", FileAccessStrategy::BLOCK_LEVEL_LOCK},
            
            // GRIB - 通常需要顺序访问
            {"GRIB", FileAccessStrategy::SEQUENTIAL_ACCESS}
        };
        
        auto it = formatStrategies.find(format);
        return (it != formatStrategies.end()) ? it->second : FileAccessStrategy::SHARED_READ_LOCK;
    }
};
```

### 5.4 综合优化协调器

```cpp
/**
 * @brief 文件格式特定的并发协调器
 * 整合NetCDF和GDAL的优化策略
 */
class FormatSpecificConcurrencyCoordinator {
public:
    /**
     * @brief 执行格式感知的并发读取
     */
    boost::future<std::shared_ptr<GridData>> executeOptimizedRead(
        const std::string& filePath,
        const std::string& variableName = "",
        const std::optional<BoundingBox>& bounds = std::nullopt,
        const std::optional<std::vector<size_t>>& verticalLevels = std::nullopt) {
        
        // 检测文件格式
        std::string format = formatDetector_->detectFormat(filePath);
        
        // 根据格式选择优化器
        if (isNetCDFFormat(format)) {
            return netcdfOptimizer_->executeNetCDFRead(filePath, variableName, 
                netcdfOptimizer_->analyzeNetCDFFile(filePath), bounds);
        }
        else if (isGDALFormat(format)) {
            return gdalOptimizer_->executeGDALRead(filePath, 
                gdalOptimizer_->analyzeGDALFile(filePath), bounds);
        }
        else {
            // 回退到默认单线程处理
            return executeDefaultRead(filePath, variableName, bounds);
        }
    }
    
    /**
     * @brief 批量文件并发处理
     */
    boost::future<std::vector<std::shared_ptr<GridData>>> executeBatchOptimizedRead(
        const std::vector<std::string>& filePaths,
        const std::string& variableName = "",
        const std::optional<BoundingBox>& bounds = std::nullopt) {
        
        return boost::async(boost::launch::async, [=]() {
            // 按格式分组文件
            auto fileGroups = groupFilesByFormat(filePaths);
            
            std::vector<boost::future<std::shared_ptr<GridData>>> futures;
            
            // 为每组文件应用最优策略
            for (const auto& [format, files] : fileGroups) {
                auto strategy = determineGroupStrategy(format, files);
                
                for (const auto& file : files) {
                    futures.push_back(executeOptimizedRead(file, variableName, bounds));
                }
            }
            
            // 等待所有结果
            std::vector<std::shared_ptr<GridData>> results;
            for (auto& future : futures) {
                results.push_back(future.get());
            }
            
            return results;
        });
    }

private:
    std::unique_ptr<NetCDFConcurrencyOptimizer> netcdfOptimizer_;
    std::unique_ptr<GDALConcurrencyOptimizer> gdalOptimizer_;
    std::shared_ptr<FormatAwareFileAccessManager> accessManager_;
    std::shared_ptr<FileFormatDetector> formatDetector_;
};
```

## 5.5 性能监控和优化反馈

```cpp
/**
 * @brief 格式特定性能监控器
 */
class FormatSpecificPerformanceMonitor {
public:
    struct FormatPerformanceMetrics {
        std::string format;
        size_t totalFilesProcessed = 0;
        size_t totalBytesRead = 0;
        std::chrono::milliseconds totalProcessingTime{0};
        double averageThroughput = 0.0;  // MB/s
        size_t concurrentReadCount = 0;
        size_t singleThreadedCount = 0;
        
        // 格式特定指标
        size_t verticalLevelsProcessed = 0;  // NetCDF特有
        size_t blocksProcessed = 0;          // GDAL特有
        size_t simdOptimizedOperations = 0;
    };
    
    /**
     * @brief 收集性能指标并优化策略
     */
    void collectMetricsAndOptimize() {
        auto netcdfMetrics = collectNetCDFMetrics();
        auto gdalMetrics = collectGDALMetrics();
        
        // 基于指标动态调整策略
        optimizeNetCDFStrategy(netcdfMetrics);
        optimizeGDALStrategy(gdalMetrics);
        
        // 生成性能报告
        generatePerformanceReport(netcdfMetrics, gdalMetrics);
    }

private:
    std::unordered_map<std::string, FormatPerformanceMetrics> formatMetrics_;
};
```

这个文件格式特定优化策略设计充分利用了您项目现有的优秀架构，包括：

1. **NetCDF优化**: 基于现有的`NetCDFAdvancedReader`，支持垂直层并行、变量缓存、流式处理
2. **GDAL优化**: 基于现有的`GdalRasterReader`，考虑线程安全性、块读取、SIMD优化
3. **智能锁管理**: 扩展现有的`FileAccessLockManagerImpl`，提供格式感知的锁策略
4. **性能监控**: 集成到现有的性能统计系统中

这样的设计既保持了与现有代码的兼容性，又提供了高度优化的并发处理能力。您希望我进一步详细讨论哪个方面的实现？ 